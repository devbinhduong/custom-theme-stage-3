"use strict";
(self["webpackChunkbigcommerce_hera"] = self["webpackChunkbigcommerce_hera"] || []).push([["vendors-node_modules_fancyapps_ui_src_Fancybox_Fancybox_js"],{

/***/ "./node_modules/@fancyapps/ui/src/Carousel/Carousel.js":
/*!*************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/Carousel.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Carousel: () => (/* binding */ Carousel)
/* harmony export */ });
/* harmony import */ var _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/Base/Base.js */ "./node_modules/@fancyapps/ui/src/shared/Base/Base.js");
/* harmony import */ var _Panzoom_Panzoom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Panzoom/Panzoom.js */ "./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js");
/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils/extend.js */ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js");
/* harmony import */ var _shared_utils_round_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/utils/round.js */ "./node_modules/@fancyapps/ui/src/shared/utils/round.js");
/* harmony import */ var _shared_utils_throttle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils/throttle.js */ "./node_modules/@fancyapps/ui/src/shared/utils/throttle.js");
/* harmony import */ var _plugins_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/index.js */ "./node_modules/@fancyapps/ui/src/Carousel/plugins/index.js");
/* harmony import */ var _l10n_en_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./l10n/en.js */ "./node_modules/@fancyapps/ui/src/Carousel/l10n/en.js");









// Default language


const defaults = {
  // Virtual slides. Each object should have at least `html` property that will be used to set content,
  // example: `slides: [{html: 'First slide'}, {html: 'Second slide'}]`
  slides: [],

  // Number of slides to preload before/after visible slides
  preload: 0,

  // Number of slides to group into the page,
  // if `auto` - group all slides that fit into the viewport
  slidesPerPage: "auto",

  // Index of initial page
  initialPage: null,

  // Index of initial slide
  initialSlide: null,

  // Panzoom friction while changing page
  friction: 0.92,

  // Should center active page
  center: true,

  // Should carousel scroll infinitely
  infinite: true,

  // Should the gap be filled before first and after last slide if `infinite: false`
  fill: true,

  // Should Carousel settle at any position after a swipe.
  dragFree: false,

  // Prefix for CSS classes, must be the same as the  SCSS `$carousel-prefix` variable
  prefix: "",

  // Class names for DOM elements (without prefix)
  classNames: {
    viewport: "carousel__viewport",
    track: "carousel__track",
    slide: "carousel__slide",

    // Classname toggled for slides inside current page
    slideSelected: "is-selected",
  },

  // Localization of strings
  l10n: _l10n_en_js__WEBPACK_IMPORTED_MODULE_6__["default"],
};

class Carousel extends _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_0__.Base {
  /**
   * Carousel constructor
   * @constructs Carousel
   * @param {HTMLElement} $container - Carousel container
   * @param {Object} [options] - Options for Carousel
   */
  constructor($container, options = {}) {
    options = (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_2__.extend)(true, {}, defaults, options);

    super(options);

    this.state = "init";

    this.$container = $container;

    if (!(this.$container instanceof HTMLElement)) {
      throw new Error("No root element provided");
    }

    this.slideNext = (0,_shared_utils_throttle_js__WEBPACK_IMPORTED_MODULE_4__.throttle)(this.slideNext.bind(this), 250, true);
    this.slidePrev = (0,_shared_utils_throttle_js__WEBPACK_IMPORTED_MODULE_4__.throttle)(this.slidePrev.bind(this), 250, true);

    this.init();

    $container.__Carousel = this;
  }

  /**
   * Perform initialization
   */
  init() {
    this.pages = [];
    this.page = this.pageIndex = null;
    this.prevPage = this.prevPageIndex = null;

    this.attachPlugins(Carousel.Plugins);

    this.trigger("init");

    this.initLayout();

    this.initSlides();

    this.updateMetrics();

    if (this.$track && this.pages.length) {
      this.$track.style.transform = `translate3d(${this.pages[this.page].left * -1}px, 0px, 0) scale(1)`;
    }

    this.manageSlideVisiblity();

    this.initPanzoom();

    this.state = "ready";

    this.trigger("ready");
  }

  /**
   * Initialize layout; create necessary elements
   */
  initLayout() {
    const prefix = this.option("prefix");
    const classNames = this.option("classNames");

    this.$viewport = this.option("viewport") || this.$container.querySelector(`.${prefix}${classNames.viewport}`);

    if (!this.$viewport) {
      this.$viewport = document.createElement("div");
      this.$viewport.classList.add(...(prefix + classNames.viewport).split(" "));

      this.$viewport.append(...this.$container.childNodes);

      this.$container.appendChild(this.$viewport);
    }

    this.$track = this.option("track") || this.$container.querySelector(`.${prefix}${classNames.track}`);

    if (!this.$track) {
      this.$track = document.createElement("div");
      this.$track.classList.add(...(prefix + classNames.track).split(" "));

      this.$track.append(...this.$viewport.childNodes);

      this.$viewport.appendChild(this.$track);
    }
  }

  /**
   * Fill `slides` array with objects from existing nodes and/or `slides` option
   */
  initSlides() {
    this.slides = [];

    // Get existing slides from the DOM
    const elems = this.$viewport.querySelectorAll(`.${this.option("prefix")}${this.option("classNames.slide")}`);

    elems.forEach((el) => {
      const slide = {
        $el: el,
        isDom: true,
      };

      this.slides.push(slide);

      this.trigger("createSlide", slide, this.slides.length);
    });

    // Add virtual slides, but do not create DOM elements yet,
    // because they will be created dynamically based on current carousel position
    if (Array.isArray(this.options.slides)) {
      this.slides = (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_2__.extend)(true, [...this.slides], this.options.slides);
    }
  }

  /**
   * Do all calculations related to slide size and paging
   */
  updateMetrics() {
    // Calculate content width, viewport width
    // ===
    let contentWidth = 0;
    let indexes = [];
    let lastSlideWidth;

    this.slides.forEach((slide, index) => {
      const $el = slide.$el;
      const slideWidth = slide.isDom || !lastSlideWidth ? this.getSlideMetrics($el) : lastSlideWidth;

      slide.index = index;
      slide.width = slideWidth;
      slide.left = contentWidth;

      lastSlideWidth = slideWidth;
      contentWidth += slideWidth;

      indexes.push(index);
    });

    let viewportWidth = Math.max(this.$track.offsetWidth, (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_3__.round)(this.$track.getBoundingClientRect().width));

    let viewportStyles = getComputedStyle(this.$track);
    viewportWidth = viewportWidth - (parseFloat(viewportStyles.paddingLeft) + parseFloat(viewportStyles.paddingRight));

    this.contentWidth = contentWidth;
    this.viewportWidth = viewportWidth;

    // Split slides into pages
    // ===
    const pages = [];
    const slidesPerPage = this.option("slidesPerPage");

    if (Number.isInteger(slidesPerPage) && contentWidth > viewportWidth) {
      // Fixed number of slides in the page
      for (let i = 0; i < this.slides.length; i += slidesPerPage) {
        pages.push({
          indexes: indexes.slice(i, i + slidesPerPage),
          slides: this.slides.slice(i, i + slidesPerPage),
        });
      }
    } else {
      // Slides that fit inside viewport
      let currentPage = 0;
      let currentWidth = 0;

      for (let i = 0; i < this.slides.length; i += 1) {
        let slide = this.slides[i];

        // Add next page
        if (!pages.length || currentWidth + slide.width > viewportWidth) {
          pages.push({
            indexes: [],
            slides: [],
          });

          currentPage = pages.length - 1;
          currentWidth = 0;
        }

        currentWidth += slide.width;

        pages[currentPage].indexes.push(i);
        pages[currentPage].slides.push(slide);
      }
    }

    const shouldCenter = this.option("center");
    const shouldFill = this.option("fill");

    // Calculate width and start position for each page
    // ===
    pages.forEach((page, index) => {
      page.index = index;
      page.width = page.slides.reduce((sum, slide) => sum + slide.width, 0);

      page.left = page.slides[0].left;

      if (shouldCenter) {
        page.left += (viewportWidth - page.width) * 0.5 * -1;
      }

      if (shouldFill && !this.option("infiniteX", this.option("infinite")) && contentWidth > viewportWidth) {
        page.left = Math.max(page.left, 0);
        page.left = Math.min(page.left, contentWidth - viewportWidth);
      }
    });

    // Merge pages
    // ===
    const rez = [];
    let prevPage;

    pages.forEach((page2) => {
      const page = { ...page2 };

      if (prevPage && page.left === prevPage.left) {
        prevPage.width += page.width;

        prevPage.slides = [...prevPage.slides, ...page.slides];
        prevPage.indexes = [...prevPage.indexes, ...page.indexes];
      } else {
        page.index = rez.length;

        prevPage = page;

        rez.push(page);
      }
    });

    this.pages = rez;

    let page = this.page;

    if (page === null) {
      const initialSlide = this.option("initialSlide");

      if (initialSlide !== null) {
        page = this.findPageForSlide(initialSlide);
      } else {
        page = parseInt(this.option("initialPage", 0), 10) || 0;
      }

      if (!rez[page]) {
        page = rez.length && page > rez.length ? rez[rez.length - 1].index : 0;
      }

      this.page = page;
      this.pageIndex = page;
    }

    this.updatePanzoom();

    this.trigger("refresh");
  }

  /**
   * Calculate slide element width (including left, right margins)
   * @param {Object} node
   * @returns {Number} Width in px
   */
  getSlideMetrics(node) {
    if (!node) {
      const firstSlide = this.slides[0];

      node = document.createElement("div");

      node.dataset.isTestEl = 1;
      node.style.visibility = "hidden";
      node.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" "));

      // Assume all slides have the same custom class, if any
      if (firstSlide.customClass) {
        node.classList.add(...firstSlide.customClass.split(" "));
      }

      this.$track.prepend(node);
    }

    let width = Math.max(node.offsetWidth, (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_3__.round)(node.getBoundingClientRect().width));

    // Add left/right margin
    const style = node.currentStyle || window.getComputedStyle(node);
    width = width + (parseFloat(style.marginLeft) || 0) + (parseFloat(style.marginRight) || 0);

    if (node.dataset.isTestEl) {
      node.remove();
    }

    return width;
  }

  /**
   *
   * @param {Integer} index Index of the slide
   * @returns {Integer|null} Index of the page if found, or null
   */
  findPageForSlide(index) {
    index = parseInt(index, 10) || 0;

    const page = this.pages.find((page) => {
      return page.indexes.indexOf(index) > -1;
    });

    return page ? page.index : null;
  }

  /**
   * Slide to next page, if possible
   */
  slideNext() {
    this.slideTo(this.pageIndex + 1);
  }

  /**
   * Slide to previous page, if possible
   */
  slidePrev() {
    this.slideTo(this.pageIndex - 1);
  }

  /**
   * Slides carousel to given page
   * @param {Number} page - New index of active page
   * @param {Object} [params] - Additional options
   */
  slideTo(page, params = {}) {
    const { x = this.setPage(page, true) * -1, y = 0, friction = this.option("friction") } = params;

    if (this.Panzoom.content.x === x && !this.Panzoom.velocity.x && friction) {
      return;
    }

    this.Panzoom.panTo({
      x,
      y,
      friction,
      ignoreBounds: true,
    });

    if (this.state === "ready" && this.Panzoom.state === "ready") {
      this.trigger("settle");
    }
  }

  /**
   * Initialise main Panzoom instance
   */
  initPanzoom() {
    if (this.Panzoom) {
      this.Panzoom.destroy();
    }

    // Create fresh object containing options for Pazoom instance
    const options = (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_2__.extend)(
      true,
      {},
      {
        // Track element will be set as Panzoom $content
        content: this.$track,
        wrapInner: false,
        resizeParent: false,

        // Disable any user interaction
        zoom: false,
        click: false,

        // Right now, only horizontal navigation is supported
        lockAxis: "x",

        x: this.pages.length ? this.pages[this.page].left * -1 : 0,
        centerOnStart: false,

        // Make `textSelection` option more easy to customize
        textSelection: () => this.option("textSelection", false),

        // Disable dragging if content (e.g. all slides) fits inside viewport
        panOnlyZoomed: function () {
          return this.content.width <= this.viewport.width;
        },
      },
      this.option("Panzoom")
    );

    // Create new Panzoom instance
    this.Panzoom = new _Panzoom_Panzoom_js__WEBPACK_IMPORTED_MODULE_1__.Panzoom(this.$container, options);

    this.Panzoom.on({
      // Bubble events
      "*": (name, ...details) => this.trigger(`Panzoom.${name}`, ...details),
      // The rest of events to be processed
      afterUpdate: () => {
        this.updatePage();
      },
      beforeTransform: this.onBeforeTransform.bind(this),
      touchEnd: this.onTouchEnd.bind(this),
      endAnimation: () => {
        this.trigger("settle");
      },
    });

    // The contents of the slides may cause the page scroll bar to appear, so the carousel width may change
    // and slides have to be repositioned
    this.updateMetrics();
    this.manageSlideVisiblity();
  }

  updatePanzoom() {
    if (!this.Panzoom) {
      return;
    }

    this.Panzoom.content = {
      ...this.Panzoom.content,
      fitWidth: this.contentWidth,
      origWidth: this.contentWidth,
      width: this.contentWidth,
    };

    if (this.pages.length > 1 && this.option("infiniteX", this.option("infinite"))) {
      this.Panzoom.boundX = null;
    } else if (this.pages.length) {
      this.Panzoom.boundX = {
        from: this.pages[this.pages.length - 1].left * -1,
        to: this.pages[0].left * -1,
      };
    }

    if (this.option("infiniteY", this.option("infinite"))) {
      this.Panzoom.boundY = null;
    } else {
      this.Panzoom.boundY = {
        from: 0,
        to: 0,
      };
    }

    this.Panzoom.handleCursor();
  }

  manageSlideVisiblity() {
    const contentWidth = this.contentWidth;
    const viewportWidth = this.viewportWidth;

    let currentX = this.Panzoom ? this.Panzoom.content.x * -1 : this.pages.length ? this.pages[this.page].left : 0;

    const preload = this.option("preload");
    const infinite = this.option("infiniteX", this.option("infinite"));

    const paddingLeft = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-left"));
    const paddingRight = parseFloat(getComputedStyle(this.$viewport, null).getPropertyValue("padding-right"));

    // Check visibility of each slide
    this.slides.forEach((slide) => {
      let leftBoundary, rightBoundary;

      let hasDiff = 0;

      // #1 - slides in current viewport; this does not include infinite items
      leftBoundary = currentX - paddingLeft;
      rightBoundary = currentX + viewportWidth + paddingRight;

      leftBoundary -= preload * (viewportWidth + paddingLeft + paddingRight);
      rightBoundary += preload * (viewportWidth + paddingLeft + paddingRight);

      const insideCurrentInterval = slide.left + slide.width > leftBoundary && slide.left < rightBoundary;

      // #2 - infinite items inside current viewport; from previous interval
      leftBoundary = currentX + contentWidth - paddingLeft;
      rightBoundary = currentX + contentWidth + viewportWidth + paddingRight;

      // Include slides that have to be preloaded
      leftBoundary -= preload * (viewportWidth + paddingLeft + paddingRight);

      const insidePrevInterval = infinite && slide.left + slide.width > leftBoundary && slide.left < rightBoundary;

      // #2 - infinite items inside current viewport; from next interval
      leftBoundary = currentX - contentWidth - paddingLeft;
      rightBoundary = currentX - contentWidth + viewportWidth + paddingRight;

      // Include slides that have to be preloaded
      leftBoundary -= preload * (viewportWidth + paddingLeft + paddingRight);

      const insideNextInterval = infinite && slide.left + slide.width > leftBoundary && slide.left < rightBoundary;

      // Create virtual slides that should be visible or preloaded, remove others
      if (insidePrevInterval || insideCurrentInterval || insideNextInterval) {
        this.createSlideEl(slide);

        if (insideCurrentInterval) {
          hasDiff = 0;
        }

        if (insidePrevInterval) {
          hasDiff = -1;
        }

        if (insideNextInterval) {
          hasDiff = 1;
        }

        // Bring preloaded slides back to viewport, if needed
        if (slide.left + slide.width > currentX && slide.left <= currentX + viewportWidth + paddingRight) {
          hasDiff = 0;
        }
      } else {
        this.removeSlideEl(slide);
      }

      slide.hasDiff = hasDiff;
    });

    // Reposition slides for continuity
    let nextIndex = 0;
    let nextPos = 0;

    this.slides.forEach((slide, index) => {
      let updatedX = 0;

      if (slide.$el) {
        if (index !== nextIndex || slide.hasDiff) {
          updatedX = nextPos + slide.hasDiff * contentWidth;
        } else {
          nextPos = 0;
        }

        slide.$el.style.left = Math.abs(updatedX) > 0.1 ? `${nextPos + slide.hasDiff * contentWidth}px` : "";

        nextIndex++;
      } else {
        nextPos += slide.width;
      }
    });

    this.markSelectedSlides();
  }

  /**
   * Creates main DOM element for virtual slides,
   * lazy loads images inside regular slides
   * @param {Object} slide
   */
  createSlideEl(slide) {
    if (!slide) {
      return;
    }

    if (slide.$el) {
      let curentIndex = slide.$el.dataset.index;

      if (!curentIndex || parseInt(curentIndex, 10) !== slide.index) {
        slide.$el.dataset.index = slide.index;

        // Lazy load images
        // ===
        slide.$el.querySelectorAll("[data-lazy-srcset]").forEach((node) => {
          node.srcset = node.dataset.lazySrcset;
        });

        slide.$el.querySelectorAll("[data-lazy-src]").forEach((node) => {
          let lazySrc = node.dataset.lazySrc;

          if (node instanceof HTMLImageElement) {
            node.src = lazySrc;
          } else {
            node.style.backgroundImage = `url('${lazySrc}')`;
          }
        });

        // Lazy load slide background image
        // ===
        let lazySrc;

        if ((lazySrc = slide.$el.dataset.lazySrc)) {
          slide.$el.style.backgroundImage = `url('${lazySrc}')`;
        }

        slide.state = "ready";
      }

      return;
    }

    const div = document.createElement("div");

    div.dataset.index = slide.index;
    div.classList.add(...(this.option("prefix") + this.option("classNames.slide")).split(" "));

    if (slide.customClass) {
      div.classList.add(...slide.customClass.split(" "));
    }

    if (slide.html) {
      div.innerHTML = slide.html;
    }

    const allElelements = [];

    this.slides.forEach((slide, index) => {
      if (slide.$el) {
        allElelements.push(index);
      }
    });

    // Find a place in DOM to insert an element
    const goal = slide.index;
    let refSlide = null;

    if (allElelements.length) {
      let refIndex = allElelements.reduce((prev, curr) =>
        Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev
      );
      refSlide = this.slides[refIndex];
    }

    this.$track.insertBefore(
      div,
      refSlide && refSlide.$el ? (refSlide.index < slide.index ? refSlide.$el.nextSibling : refSlide.$el) : null
    );

    slide.$el = div;

    this.trigger("createSlide", slide, goal);

    return slide;
  }

  /**
   * Removes main DOM element of given slide
   * @param {Object} slide
   */
  removeSlideEl(slide) {
    if (slide.$el && !slide.isDom) {
      this.trigger("removeSlide", slide);

      slide.$el.remove();
      slide.$el = null;
    }
  }

  /**
   * Toggles selected class name and aria-hidden attribute for slides based on visibility
   */
  markSelectedSlides() {
    const selectedClass = this.option("classNames.slideSelected");
    const attr = "aria-hidden";

    this.slides.forEach((slide, index) => {
      const $el = slide.$el;

      if (!$el) {
        return;
      }

      const page = this.pages[this.page];

      if (page && page.indexes && page.indexes.indexOf(index) > -1) {
        if (selectedClass && !$el.classList.contains(selectedClass)) {
          $el.classList.add(selectedClass);
          this.trigger("selectSlide", slide);
        }

        $el.removeAttribute(attr);
      } else {
        if (selectedClass && $el.classList.contains(selectedClass)) {
          $el.classList.remove(selectedClass);
          this.trigger("unselectSlide", slide);
        }

        $el.setAttribute(attr, true);
      }
    });
  }

  /**
   * Perform all calculations and center current page
   */
  updatePage() {
    this.updateMetrics();

    this.slideTo(this.page, { friction: 0 });
  }

  /**
   * Process `Panzoom.beforeTransform` event to remove slides moved out of viewport and
   * to create necessary ones
   */
  onBeforeTransform() {
    if (this.option("infiniteX", this.option("infinite"))) {
      this.manageInfiniteTrack();
    }

    this.manageSlideVisiblity();
  }

  /**
   * Seamlessly flip position of infinite carousel, if needed; this way x position stays low
   */
  manageInfiniteTrack() {
    const contentWidth = this.contentWidth;
    const viewportWidth = this.viewportWidth;

    if (!this.option("infiniteX", this.option("infinite")) || this.pages.length < 2 || contentWidth < viewportWidth) {
      return;
    }

    const panzoom = this.Panzoom;

    let isFlipped = false;

    if (panzoom.content.x < (contentWidth - viewportWidth) * -1) {
      panzoom.content.x += contentWidth;

      this.pageIndex = this.pageIndex - this.pages.length;

      isFlipped = true;
    }

    if (panzoom.content.x > viewportWidth) {
      panzoom.content.x -= contentWidth;

      this.pageIndex = this.pageIndex + this.pages.length;

      isFlipped = true;
    }

    if (isFlipped && panzoom.state === "pointerdown") {
      panzoom.resetDragPosition();
    }

    return isFlipped;
  }

  /**
   * Process `Panzoom.touchEnd` event; slide to next/prev page if needed
   * @param {object} panzoom
   */
  onTouchEnd(panzoom, event) {
    const dragFree = this.option("dragFree");

    // If this is a quick horizontal flick, slide to next/prev slide
    if (
      !dragFree &&
      this.pages.length > 1 &&
      panzoom.dragOffset.time < 350 &&
      Math.abs(panzoom.dragOffset.y) < 1 &&
      Math.abs(panzoom.dragOffset.x) > 5
    ) {
      this[panzoom.dragOffset.x < 0 ? "slideNext" : "slidePrev"]();
      return;
    }

    // Set the slide at the end of the animation as the current one,
    // or slide to closest page
    if (dragFree) {
      const [, nextPageIndex] = this.getPageFromPosition(panzoom.transform.x * -1);
      this.setPage(nextPageIndex);
    } else {
      this.slideToClosest();
    }
  }

  /**
   * Slides to the closest page (useful, if carousel is changed manually)
   * @param {Object} [params] - Object containing additional options
   */
  slideToClosest(params = {}) {
    let [, nextPageIndex] = this.getPageFromPosition(this.Panzoom.content.x * -1);

    this.slideTo(nextPageIndex, params);
  }

  /**
   * Returns index of closest page to given x position
   * @param {Number} xPos
   */
  getPageFromPosition(xPos) {
    const pageCount = this.pages.length;
    const center = this.option("center");

    if (center) {
      xPos += this.viewportWidth * 0.5;
    }

    const interval = Math.floor(xPos / this.contentWidth);

    xPos -= interval * this.contentWidth;

    let slide = this.slides.find((slide) => slide.left <= xPos && slide.left + slide.width > xPos);

    if (slide) {
      let pageIndex = this.findPageForSlide(slide.index);

      return [pageIndex, pageIndex + interval * pageCount];
    }

    return [0, 0];
  }

  /**
   * Changes active page
   * @param {Number} page - New index of active page
   * @param {Boolean} toClosest - to closest page based on scroll distance (for infinite navigation)
   */
  setPage(page, toClosest) {
    let nextPosition = 0;
    let pageIndex = parseInt(page, 10) || 0;

    const prevPage = this.page,
      prevPageIndex = this.pageIndex,
      pageCount = this.pages.length;

    const contentWidth = this.contentWidth;
    const viewportWidth = this.viewportWidth;

    page = ((pageIndex % pageCount) + pageCount) % pageCount;

    if (this.option("infiniteX", this.option("infinite")) && contentWidth > viewportWidth) {
      const nextInterval = Math.floor(pageIndex / pageCount) || 0,
        elemDimWidth = contentWidth;

      nextPosition = this.pages[page].left + nextInterval * elemDimWidth;

      if (toClosest === true && pageCount > 2) {
        let currPosition = this.Panzoom.content.x * -1;

        // * Find closest interval
        const decreasedPosition = nextPosition - elemDimWidth,
          increasedPosition = nextPosition + elemDimWidth,
          diff1 = Math.abs(currPosition - nextPosition),
          diff2 = Math.abs(currPosition - decreasedPosition),
          diff3 = Math.abs(currPosition - increasedPosition);

        if (diff3 < diff1 && diff3 <= diff2) {
          nextPosition = increasedPosition;
          pageIndex += pageCount;
        } else if (diff2 < diff1 && diff2 < diff3) {
          nextPosition = decreasedPosition;
          pageIndex -= pageCount;
        }
      }
    } else {
      page = pageIndex = Math.max(0, Math.min(pageIndex, pageCount - 1));

      nextPosition = this.pages.length ? this.pages[page].left : 0;
    }

    this.page = page;
    this.pageIndex = pageIndex;

    if (prevPage !== null && page !== prevPage) {
      this.prevPage = prevPage;
      this.prevPageIndex = prevPageIndex;

      this.trigger("change", page, prevPage);
    }

    return nextPosition;
  }

  /**
   * Clean up
   */
  destroy() {
    this.state = "destroy";

    this.slides.forEach((slide) => {
      this.removeSlideEl(slide);
    });

    this.slides = [];

    this.Panzoom.destroy();

    this.detachPlugins();
  }
}

// Expose version
Carousel.version = "__VERSION__";

// Static properties are a recent addition that dont work in all browsers yet
Carousel.Plugins = _plugins_index_js__WEBPACK_IMPORTED_MODULE_5__.Plugins;


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/l10n/en.js":
/*!************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/l10n/en.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  NEXT: "Next slide",
  PREV: "Previous slide",
  GOTO: "Go to slide #%d",
});


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Dots/Dots.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/plugins/Dots/Dots.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dots: () => (/* binding */ Dots)
/* harmony export */ });
const defaults = {
  // The minimum number of slides to display dots
  minSlideCount: 2,
};

class Dots {
  constructor(carousel) {
    this.carousel = carousel;

    this.$list = null;

    this.events = {
      change: this.onChange.bind(this),
      refresh: this.onRefresh.bind(this),
    };
  }

  /**
   * Build wrapping DOM element containing all dots
   */
  buildList() {
    if (this.carousel.pages.length < this.carousel.option("Dots.minSlideCount")) {
      return;
    }

    const $list = document.createElement("ol");

    $list.classList.add("carousel__dots");

    $list.addEventListener("click", (e) => {
      if (!("page" in e.target.dataset)) {
        return;
      }

      e.preventDefault();
      e.stopPropagation();

      const page = parseInt(e.target.dataset.page, 10);
      const carousel = this.carousel;

      if (page === carousel.page) {
        return;
      }

      if (carousel.pages.length < 3 && carousel.option("infinite")) {
        carousel[page == 0 ? "slidePrev" : "slideNext"]();
      } else {
        carousel.slideTo(page);
      }
    });

    this.$list = $list;

    this.carousel.$container.appendChild($list);
    this.carousel.$container.classList.add("has-dots");

    return $list;
  }

  /**
   * Remove wrapping DOM element
   */
  removeList() {
    if (this.$list) {
      this.$list.parentNode.removeChild(this.$list);
      this.$list = null;
    }

    this.carousel.$container.classList.remove("has-dots");
  }

  /**
   * Remove existing dots and create fresh ones
   */
  rebuildDots() {
    let $list = this.$list;

    const listExists = !!$list;
    const pagesCount = this.carousel.pages.length;

    if (pagesCount < 2) {
      if (listExists) {
        this.removeList();
      }

      return;
    }

    if (!listExists) {
      $list = this.buildList();
    }

    // Remove existing dots
    const dotCount = this.$list.children.length;

    if (dotCount > pagesCount) {
      for (let i = pagesCount; i < dotCount; i++) {
        this.$list.removeChild(this.$list.lastChild);
      }

      return;
    }

    // Create fresh DOM elements (dots) for each page
    for (let index = dotCount; index < pagesCount; index++) {
      const $dot = document.createElement("li");

      $dot.classList.add("carousel__dot");
      $dot.dataset.page = index;

      $dot.setAttribute("role", "button");
      $dot.setAttribute("tabindex", "0");
      $dot.setAttribute("title", this.carousel.localize("{{GOTO}}", [["%d", index + 1]]));

      $dot.addEventListener("keydown", (event) => {
        const code = event.code;

        let $el;

        if (code === "Enter" || code === "NumpadEnter") {
          $el = $dot;
        } else if (code === "ArrowRight") {
          $el = $dot.nextSibling;
        } else if (code === "ArrowLeft") {
          $el = $dot.previousSibling;
        }

        $el && $el.click();
      });

      this.$list.appendChild($dot);
    }

    this.setActiveDot();
  }

  /**
   * Mark active dot by toggling class name
   */
  setActiveDot() {
    if (!this.$list) {
      return;
    }

    this.$list.childNodes.forEach(($dot) => {
      $dot.classList.remove("is-selected");
    });

    const $activeDot = this.$list.childNodes[this.carousel.page];

    if ($activeDot) {
      $activeDot.classList.add("is-selected");
    }
  }

  /**
   * Process carousel `change` event
   */
  onChange() {
    this.setActiveDot();
  }

  /**
   * Process carousel `refresh` event
   */
  onRefresh() {
    this.rebuildDots();
  }

  attach() {
    this.carousel.on(this.events);
  }

  detach() {
    this.removeList();

    this.carousel.off(this.events);
    this.carousel = null;
  }
}


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Navigation/Navigation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/plugins/Navigation/Navigation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Navigation: () => (/* binding */ Navigation)
/* harmony export */ });
const defaults = {
  prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>',
  nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',

  classNames: {
    main: "carousel__nav",
    button: "carousel__button",

    next: "is-next",
    prev: "is-prev",
  },
};

class Navigation {
  constructor(carousel) {
    this.$container = null;

    this.$prev = null;
    this.$next = null;

    this.carousel = carousel;

    this.onRefresh = this.onRefresh.bind(this);
  }

  /**
   * Shortcut to get option for this plugin
   * @param {String} name option name
   * @returns option value
   */
  option(name) {
    return this.carousel.option(`Navigation.${name}`);
  }

  /**
   * Creates and returns new button element with default class names and click event
   * @param {String} type
   */
  createButton(type) {
    const $btn = document.createElement("button");

    $btn.setAttribute("title", this.carousel.localize(`{{${type.toUpperCase()}}}`));

    const classNames = this.option("classNames.button") + " " + this.option(`classNames.${type}`);

    $btn.classList.add(...classNames.split(" "));
    $btn.setAttribute("tabindex", "0");
    $btn.innerHTML = this.carousel.localize(this.option(`${type}Tpl`));

    $btn.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();

      this.carousel[`slide${type === "next" ? "Next" : "Prev"}`]();
    });

    return $btn;
  }

  /**
   * Build necessary DOM elements
   */
  build() {
    if (!this.$container) {
      this.$container = document.createElement("div");
      this.$container.classList.add(...this.option("classNames.main").split(" "));

      this.carousel.$container.appendChild(this.$container);
    }

    if (!this.$next) {
      this.$next = this.createButton("next");

      this.$container.appendChild(this.$next);
    }

    if (!this.$prev) {
      this.$prev = this.createButton("prev");

      this.$container.appendChild(this.$prev);
    }
  }

  /**
   *  Process carousel `refresh` and `change` events to enable/disable buttons if needed
   */
  onRefresh() {
    const pageCount = this.carousel.pages.length;

    if (
      pageCount <= 1 ||
      (pageCount > 1 &&
        this.carousel.elemDimWidth < this.carousel.wrapDimWidth &&
        !Number.isInteger(this.carousel.option("slidesPerPage")))
    ) {
      this.cleanup();

      return;
    }

    this.build();

    this.$prev.removeAttribute("disabled");
    this.$next.removeAttribute("disabled");

    if (this.carousel.option("infiniteX", this.carousel.option("infinite"))) {
      return;
    }

    if (this.carousel.page <= 0) {
      this.$prev.setAttribute("disabled", "");
    }

    if (this.carousel.page >= pageCount - 1) {
      this.$next.setAttribute("disabled", "");
    }
  }

  cleanup() {
    if (this.$prev) {
      this.$prev.remove();
    }

    this.$prev = null;

    if (this.$next) {
      this.$next.remove();
    }

    this.$next = null;

    if (this.$container) {
      this.$container.remove();
    }

    this.$container = null;
  }

  attach() {
    this.carousel.on("refresh change", this.onRefresh);
  }

  detach() {
    this.carousel.off("refresh change", this.onRefresh);

    this.cleanup();
  }
}

// Expose defaults
Navigation.defaults = defaults;


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Sync/Sync.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/plugins/Sync/Sync.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sync: () => (/* binding */ Sync)
/* harmony export */ });
const defaults = {
  friction: 0.92,
};

class Sync {
  constructor(carousel) {
    this.carousel = carousel;

    this.selectedIndex = null;
    this.friction = 0;

    this.onNavReady = this.onNavReady.bind(this);
    this.onNavClick = this.onNavClick.bind(this);
    this.onNavCreateSlide = this.onNavCreateSlide.bind(this);

    this.onTargetChange = this.onTargetChange.bind(this);
  }

  /**
   * Make this one as main carousel and selected carousel as navigation
   * @param {Object} nav Carousel
   */
  addAsTargetFor(nav) {
    this.target = this.carousel;
    this.nav = nav;

    this.attachEvents();
  }

  /**
   * Make this one as navigation carousel for selected carousel
   * @param {Object} target
   */
  addAsNavFor(target) {
    this.target = target;
    this.nav = this.carousel;

    this.attachEvents();
  }

  /**
   * Attach event listeners on both carousels
   */
  attachEvents() {
    this.nav.options.initialSlide = this.target.options.initialPage;

    this.nav.on("ready", this.onNavReady);
    this.nav.on("createSlide", this.onNavCreateSlide);
    this.nav.on("Panzoom.click", this.onNavClick);

    this.target.on("change", this.onTargetChange);
    this.target.on("Panzoom.afterUpdate", this.onTargetChange);
  }

  /**
   * Process main carousel `ready` event; bind events and set initial page
   */
  onNavReady() {
    this.onTargetChange(true);
  }

  /**
   * Process main carousel `click` event
   * @param {Object} panzoom
   * @param {Object} event
   */
  onNavClick(carousel, panzoom, event) {
    const clickedNavSlide = event.target.closest(".carousel__slide");

    if (!clickedNavSlide) {
      return;
    }

    event.stopPropagation();

    const selectedNavIndex = parseInt(clickedNavSlide.dataset.index, 10);
    const selectedSyncPage = this.target.findPageForSlide(selectedNavIndex);

    if (this.target.page !== selectedSyncPage) {
      this.target.slideTo(selectedSyncPage, { friction: this.friction });
    }

    this.markSelectedSlide(selectedNavIndex);
  }

  /**
   * Process main carousel `createSlide` event
   * @param {Object} carousel
   * @param {Object} slide
   */
  onNavCreateSlide(carousel, slide) {
    if (slide.index === this.selectedIndex) {
      this.markSelectedSlide(slide.index);
    }
  }

  /**
   * Process target carousel `change` event
   * @param {Object} target
   */
  onTargetChange() {
    const targetIndex = this.target.pages[this.target.page].indexes[0];
    const selectedNavPage = this.nav.findPageForSlide(targetIndex);

    this.nav.slideTo(selectedNavPage);

    this.markSelectedSlide(targetIndex);
  }

  /**
   * Toggle classname for slides that marks currently selected slides
   * @param {Number} selectedIndex
   */
  markSelectedSlide(selectedIndex) {
    this.selectedIndex = selectedIndex;

    [...this.nav.slides].filter((slide) => slide.$el && slide.$el.classList.remove("is-nav-selected"));

    const slide = this.nav.slides[selectedIndex];

    if (slide && slide.$el) slide.$el.classList.add("is-nav-selected");
  }

  attach(carousel) {
    const sync = carousel.options.Sync;

    if (!sync.target && !sync.nav) {
      return;
    }

    if (sync.target) {
      this.addAsNavFor(sync.target);
    } else if (sync.nav) {
      this.addAsTargetFor(sync.nav);
    }

    this.friction = sync.friction;
  }

  detach() {
    if (this.nav) {
      this.nav.off("ready", this.onNavReady);
      this.nav.off("Panzoom.click", this.onNavClick);
      this.nav.off("createSlide", this.onNavCreateSlide);
    }

    if (this.target) {
      this.target.off("Panzoom.afterUpdate", this.onTargetChange);
      this.target.off("change", this.onTargetChange);
    }
  }
}

// Expose defaults
Sync.defaults = defaults;


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Carousel/plugins/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Carousel/plugins/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Plugins: () => (/* binding */ Plugins)
/* harmony export */ });
/* harmony import */ var _Navigation_Navigation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Navigation/Navigation.js */ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Navigation/Navigation.js");
/* harmony import */ var _Dots_Dots_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dots/Dots.js */ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Dots/Dots.js");
/* harmony import */ var _Sync_Sync_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Sync/Sync.js */ "./node_modules/@fancyapps/ui/src/Carousel/plugins/Sync/Sync.js");




const Plugins = { Navigation: _Navigation_Navigation_js__WEBPACK_IMPORTED_MODULE_0__.Navigation, Dots: _Dots_Dots_js__WEBPACK_IMPORTED_MODULE_1__.Dots, Sync: _Sync_Sync_js__WEBPACK_IMPORTED_MODULE_2__.Sync };


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/Fancybox.js":
/*!*************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/Fancybox.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fancybox: () => (/* binding */ Fancybox)
/* harmony export */ });
/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils/extend.js */ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js");
/* harmony import */ var _shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils/canUseDOM.js */ "./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js");
/* harmony import */ var _shared_utils_setFocusOn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils/setFocusOn.js */ "./node_modules/@fancyapps/ui/src/shared/utils/setFocusOn.js");
/* harmony import */ var _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/Base/Base.js */ "./node_modules/@fancyapps/ui/src/shared/Base/Base.js");
/* harmony import */ var _Carousel_Carousel_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Carousel/Carousel.js */ "./node_modules/@fancyapps/ui/src/Carousel/Carousel.js");
/* harmony import */ var _plugins_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/index.js */ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/index.js");
/* harmony import */ var _l10n_en_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./l10n/en.js */ "./node_modules/@fancyapps/ui/src/Fancybox/l10n/en.js");










// Default language


// Default settings
const defaults = {
  // Index of active slide on the start
  startIndex: 0,

  // Number of slides to preload before and after active slide
  preload: 1,

  // Should navigation be infinite
  infinite: true,

  // Class name to be applied to the content to reveal it
  showClass: "fancybox-zoomInUp", // "fancybox-fadeIn" | "fancybox-zoomInUp" | false

  // Class name to be applied to the content to hide it
  hideClass: "fancybox-fadeOut", // "fancybox-fadeOut" | "fancybox-zoomOutDown" | false

  // Should backdrop and UI elements fade in/out on start/close
  animated: true,

  // If browser scrollbar should be hidden
  hideScrollbar: true,

  // Element containing main structure
  parentEl: null,

  // Custom class name or multiple space-separated class names for the container
  mainClass: null,

  // Set focus on first focusable element after displaying content
  autoFocus: true,

  // Trap focus inside Fancybox
  trapFocus: true,

  // Set focus back to trigger element after closing Fancybox
  placeFocusBack: true,

  // Action to take when the user clicks on the backdrop
  click: "close", // "close" | "next" | null

  // Position of the close button - over the content or at top right corner of viewport
  closeButton: "inside", // "inside" | "outside"

  // Allow user to drag content up/down to close instance
  dragToClose: true,

  // Enable keyboard navigation
  keyboard: {
    Escape: "close",
    Delete: "close",
    Backspace: "close",
    PageUp: "next",
    PageDown: "prev",
    ArrowUp: "next",
    ArrowDown: "prev",
    ArrowRight: "next",
    ArrowLeft: "prev",
  },

  // HTML templates for various elements
  template: {
    // Close button icon
    closeButton:
      '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg>',
    // Loading indicator icon
    spinner:
      '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="25 25 50 50" tabindex="-1"><circle cx="50" cy="50" r="20"/></svg>',

    // Main container element
    main: null,
  },

  /* Note: If the `template.main` option is not provided, the structure is generated as follows by default:
  <div class="fancybox__container" role="dialog" aria-modal="true" aria-hidden="true" aria-label="{{MODAL}}" tabindex="-1">
    <div class="fancybox__backdrop"></div>
    <div class="fancybox__carousel"></div>
  </div>
  */

  // Localization of strings
  l10n: _l10n_en_js__WEBPACK_IMPORTED_MODULE_6__["default"],
};

// Object that contains all active instances of Fancybox
const instances = new Map();

// Number of Fancybox instances created, it is used to generate new instance "id"
let called = 0;

class Fancybox extends _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_3__.Base {
  /**
   * Fancybox constructor
   * @constructs Fancybox
   * @param {Object} [options] - Options for Fancybox
   */
  constructor(items, options = {}) {
    // Quick hack to fix variable naming collision
    items = items.map((item) => {
      if (item.width) item._width = item.width;
      if (item.height) item._height = item.height;

      return item;
    });

    super((0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)(true, {}, defaults, options));

    this.bindHandlers();

    this.state = "init";

    this.setItems(items);

    this.attachPlugins(Fancybox.Plugins);

    // "init" event marks the start of initialization and is available to plugins
    this.trigger("init");

    if (this.option("hideScrollbar") === true) {
      this.hideScrollbar();
    }

    this.initLayout();

    this.initCarousel();

    this.attachEvents();

    instances.set(this.id, this);

    // "prepare" event will trigger the creation of additional layout elements, such as thumbnails and toolbar
    this.trigger("prepare");

    this.state = "ready";

    // "ready" event will trigger the content to load
    this.trigger("ready");

    // Reveal container
    this.$container.setAttribute("aria-hidden", "false");

    // Set focus on the first focusable element inside this instance
    if (this.option("trapFocus")) {
      this.focus();
    }
  }

  /**
   * Override `option` method to get value from the current slide
   * @param {String} name option name
   * @param  {...any} rest optional extra parameters
   * @returns {any}
   */
  option(name, ...rest) {
    const slide = this.getSlide();

    let value = slide ? slide[name] : undefined;

    if (value !== undefined) {
      if (typeof value === "function") {
        value = value.call(this, this, ...rest);
      }

      return value;
    }

    return super.option(name, ...rest);
  }

  /**
   * Bind event handlers for referencability
   */
  bindHandlers() {
    for (const methodName of [
      "onMousedown",
      "onKeydown",
      "onClick",

      "onFocus",

      "onCreateSlide",
      "onSettle",

      "onTouchMove",
      "onTouchEnd",

      "onTransform",
    ]) {
      this[methodName] = this[methodName].bind(this);
    }
  }

  /**
   * Set up a functions that will be called whenever the specified event is delivered
   */
  attachEvents() {
    document.addEventListener("mousedown", this.onMousedown);
    document.addEventListener("keydown", this.onKeydown, true);

    // Trap keyboard focus inside of the modal
    if (this.option("trapFocus")) {
      document.addEventListener("focus", this.onFocus, true);
    }

    this.$container.addEventListener("click", this.onClick);
  }

  /**
   * Removes previously registered event listeners
   */
  detachEvents() {
    document.removeEventListener("mousedown", this.onMousedown);
    document.removeEventListener("keydown", this.onKeydown, true);

    document.removeEventListener("focus", this.onFocus, true);

    this.$container.removeEventListener("click", this.onClick);
  }

  /**
   * Initialize layout; create main container, backdrop nd layout for main carousel
   */
  initLayout() {
    this.$root = this.option("parentEl") || document.body;

    // Container
    let mainTemplate = this.option("template.main");

    if (mainTemplate) {
      this.$root.insertAdjacentHTML("beforeend", this.localize(mainTemplate));

      this.$container = this.$root.querySelector(".fancybox__container");
    }

    if (!this.$container) {
      this.$container = document.createElement("div");
      this.$root.appendChild(this.$container);
    }

    // Normally we would not need this, but Safari does not support `preventScroll:false` option for `focus` method
    // and that causes layout issues
    this.$container.onscroll = () => {
      this.$container.scrollLeft = 0;
      return false;
    };

    Object.entries({
      class: "fancybox__container",
      role: "dialog",
      tabIndex: "-1",
      "aria-modal": "true",
      "aria-hidden": "true",
      "aria-label": this.localize("{{MODAL}}"),
    }).forEach((args) => this.$container.setAttribute(...args));

    if (this.option("animated")) {
      this.$container.classList.add("is-animated");
    }

    // Backdrop
    this.$backdrop = this.$container.querySelector(".fancybox__backdrop");

    if (!this.$backdrop) {
      this.$backdrop = document.createElement("div");
      this.$backdrop.classList.add("fancybox__backdrop");

      this.$container.appendChild(this.$backdrop);
    }

    // Carousel
    this.$carousel = this.$container.querySelector(".fancybox__carousel");

    if (!this.$carousel) {
      this.$carousel = document.createElement("div");
      this.$carousel.classList.add("fancybox__carousel");

      this.$container.appendChild(this.$carousel);
    }

    // Make instance reference accessible
    this.$container.Fancybox = this;

    // Make sure the container has an ID
    this.id = this.$container.getAttribute("id");

    if (!this.id) {
      this.id = this.options.id || ++called;
      this.$container.setAttribute("id", "fancybox-" + this.id);
    }

    // Add custom class name to main element
    const mainClass = this.option("mainClass");

    if (mainClass) {
      this.$container.classList.add(...mainClass.split(" "));
    }

    // Add class name for <html> element
    document.documentElement.classList.add("with-fancybox");

    this.trigger("initLayout");

    return this;
  }

  /**
   * Prepares slides for the corousel
   * @returns {Array} Slides
   */
  setItems(items) {
    const slides = [];

    for (const slide of items) {
      const $trigger = slide.$trigger;

      if ($trigger) {
        const dataset = $trigger.dataset || {};

        slide.src = dataset.src || $trigger.getAttribute("href") || slide.src;
        slide.type = dataset.type || slide.type;

        // Support items without `src`, e.g., when `data-fancybox` attribute added directly to `<img>` element
        if (!slide.src && $trigger instanceof HTMLImageElement) {
          slide.src = $trigger.currentSrc || slide.$trigger.src;
        }
      }

      // Check for thumbnail element
      let $thumb = slide.$thumb;

      if (!$thumb) {
        let origTarget = slide.$trigger && slide.$trigger.origTarget;

        if (origTarget) {
          if (origTarget instanceof HTMLImageElement) {
            $thumb = origTarget;
          } else {
            $thumb = origTarget.querySelector("img:not([aria-hidden])");
          }
        }

        if (!$thumb && slide.$trigger) {
          $thumb =
            slide.$trigger instanceof HTMLImageElement
              ? slide.$trigger
              : slide.$trigger.querySelector("img:not([aria-hidden])");
        }
      }

      slide.$thumb = $thumb || null;

      // Get thumbnail image source
      let thumb = slide.thumb;

      if (!thumb && $thumb) {
        thumb = $thumb.currentSrc || $thumb.src;

        if (!thumb && $thumb.dataset) {
          thumb = $thumb.dataset.lazySrc || $thumb.dataset.src;
        }
      }

      // Assume we have image, then use it as thumbnail
      if (!thumb && slide.type === "image") {
        thumb = slide.src;
      }

      slide.thumb = thumb || null;

      // Add empty caption to make things simpler
      slide.caption = slide.caption || "";

      slides.push(slide);
    }

    this.items = slides;
  }

  /**
   * Initialize main Carousel that will be used to display the content
   * @param {Array} slides
   */
  initCarousel() {
    this.Carousel = new _Carousel_Carousel_js__WEBPACK_IMPORTED_MODULE_4__.Carousel(
      this.$carousel,
      (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)(
        true,
        {},
        {
          prefix: "",

          classNames: {
            viewport: "fancybox__viewport",
            track: "fancybox__track",
            slide: "fancybox__slide",
          },

          textSelection: true,
          preload: this.option("preload"),

          friction: 0.88,

          slides: this.items,
          initialPage: this.options.startIndex,
          slidesPerPage: 1,

          infiniteX: this.option("infinite"),
          infiniteY: true,

          l10n: this.option("l10n"),

          Dots: false,
          Navigation: {
            classNames: {
              main: "fancybox__nav",
              button: "carousel__button",

              next: "is-next",
              prev: "is-prev",
            },
          },

          Panzoom: {
            textSelection: true,

            panOnlyZoomed: () => {
              return (
                this.Carousel && this.Carousel.pages && this.Carousel.pages.length < 2 && !this.option("dragToClose")
              );
            },

            lockAxis: () => {
              if (this.Carousel) {
                let rez = "x";

                if (this.option("dragToClose")) {
                  rez += "y";
                }

                return rez;
              }
            },
          },

          on: {
            "*": (name, ...details) => this.trigger(`Carousel.${name}`, ...details),
            init: (carousel) => (this.Carousel = carousel),
            createSlide: this.onCreateSlide,
            settle: this.onSettle,
          },
        },

        this.option("Carousel")
      )
    );

    if (this.option("dragToClose")) {
      this.Carousel.Panzoom.on({
        // Stop further touch event handling if content is scaled
        touchMove: this.onTouchMove,

        // Update backdrop opacity depending on vertical distance
        afterTransform: this.onTransform,

        // Close instance if drag distance exceeds limit
        touchEnd: this.onTouchEnd,
      });
    }

    this.trigger("initCarousel");

    return this;
  }

  /**
   * Process `createSlide` event to create caption element inside new slide
   */
  onCreateSlide(carousel, slide) {
    let caption = slide.caption || "";

    if (typeof this.options.caption === "function") {
      caption = this.options.caption.call(this, this, this.Carousel, slide);
    }

    if (typeof caption === "string" && caption.length) {
      const $caption = document.createElement("div");
      const id = `fancybox__caption_${this.id}_${slide.index}`;

      $caption.className = "fancybox__caption";
      $caption.innerHTML = caption;
      $caption.setAttribute("id", id);

      slide.$caption = slide.$el.appendChild($caption);

      slide.$el.classList.add("has-caption");
      slide.$el.setAttribute("aria-labelledby", id);
    }
  }

  /**
   * Handle Carousel `settle` event
   */
  onSettle() {
    if (this.option("autoFocus")) {
      this.focus();
    }
  }

  /**
   * Handle focus event
   * @param {Event} event - Focus event
   */
  onFocus(event) {
    if (!this.isTopmost()) {
      return;
    }

    this.focus(event);
  }

  /**
   * Handle click event on the container
   * @param {Event} event - Click event
   */
  onClick(event) {
    if (event.defaultPrevented) {
      return;
    }

    let eventTarget = event.composedPath()[0];

    if (eventTarget.matches("[data-fancybox-close]")) {
      event.preventDefault();
      Fancybox.close(false, event);

      return;
    }

    if (eventTarget.matches("[data-fancybox-next]")) {
      event.preventDefault();
      Fancybox.next();

      return;
    }

    if (eventTarget.matches("[data-fancybox-prev]")) {
      event.preventDefault();
      Fancybox.prev();

      return;
    }

    const activeElement = document.activeElement;

    if (activeElement) {
      if (activeElement.closest("[contenteditable]")) {
        return;
      }

      if (!eventTarget.matches(_shared_utils_setFocusOn_js__WEBPACK_IMPORTED_MODULE_2__.FOCUSABLE_ELEMENTS)) {
        activeElement.blur();
      }
    }

    // Skip if clicked inside content area
    if (eventTarget.closest(".fancybox__content")) {
      return;
    }

    // Skip if text is selected
    if (getSelection().toString().length) {
      return;
    }

    if (this.trigger("click", event) === false) {
      return;
    }

    const action = this.option("click");

    switch (action) {
      case "close":
        this.close();
        break;
      case "next":
        this.next();
        break;
    }
  }

  /**
   * Handle panzoom `touchMove` event; Disable dragging if content of current slide is scaled
   */
  onTouchMove() {
    const panzoom = this.getSlide().Panzoom;

    return panzoom && panzoom.content.scale !== 1 ? false : true;
  }

  /**
   * Handle panzoom `touchEnd` event; close when quick flick up/down is detected
   * @param {Object} panzoom - Panzoom instance
   */
  onTouchEnd(panzoom) {
    const distanceY = panzoom.dragOffset.y;

    if (Math.abs(distanceY) >= 150 || (Math.abs(distanceY) >= 35 && panzoom.dragOffset.time < 350)) {
      if (this.option("hideClass")) {
        this.getSlide().hideClass = `fancybox-throwOut${panzoom.content.y < 0 ? "Up" : "Down"}`;
      }

      this.close();
    } else if (panzoom.lockAxis === "y") {
      panzoom.panTo({ y: 0 });
    }
  }

  /**
   * Handle `afterTransform` event; change backdrop opacity based on current y position of panzoom
   * @param {Object} panzoom - Panzoom instance
   */
  onTransform(panzoom) {
    const $backdrop = this.$backdrop;

    if ($backdrop) {
      const yPos = Math.abs(panzoom.content.y);
      const opacity = yPos < 1 ? "" : Math.max(0.33, Math.min(1, 1 - (yPos / panzoom.content.fitHeight) * 1.5));

      this.$container.style.setProperty("--fancybox-ts", opacity ? "0s" : "");
      this.$container.style.setProperty("--fancybox-opacity", opacity);
    }
  }

  /**
   * Handle `mousedown` event to mark that the mouse is in use
   */
  onMousedown() {
    if (this.state === "ready") {
      document.body.classList.add("is-using-mouse");
    }
  }

  /**
   * Handle `keydown` event; trap focus
   * @param {Event} event Keydown event
   */
  onKeydown(event) {
    if (!this.isTopmost()) {
      return;
    }

    document.body.classList.remove("is-using-mouse");

    const key = event.key;
    const keyboard = this.option("keyboard");

    if (!keyboard || event.ctrlKey || event.altKey || event.shiftKey) {
      return;
    }

    const target = event.composedPath()[0];

    const classList = document.activeElement && document.activeElement.classList;
    const isUIElement = classList && classList.contains("carousel__button");

    // Allow to close using Escape button
    if (key !== "Escape" && !isUIElement) {
      let ignoreElements =
        event.target.isContentEditable ||
        ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(target.nodeName) !== -1;

      if (ignoreElements) {
        return;
      }
    }

    if (this.trigger("keydown", key, event) === false) {
      return;
    }

    const action = keyboard[key];

    if (typeof this[action] === "function") {
      this[action]();
    }
  }

  /**
   * Get the active slide. This will be the first slide from the current page of the main carousel.
   */
  getSlide() {
    const carousel = this.Carousel;

    if (!carousel) return null;

    const page = carousel.page === null ? carousel.option("initialPage") : carousel.page;
    const pages = carousel.pages || [];

    if (pages.length && pages[page]) {
      return pages[page].slides[0];
    }

    return null;
  }

  /**
   * Place focus on the first focusable element inside current slide
   * @param {Event} [event] - Focus event
   */
  focus(event) {
    if (Fancybox.ignoreFocusChange) {
      return;
    }

    if (["init", "closing", "customClosing", "destroy"].indexOf(this.state) > -1) {
      return;
    }

    const $container = this.$container;
    const currentSlide = this.getSlide();
    const $currentSlide = currentSlide.state === "done" ? currentSlide.$el : null;

    // Skip if the DOM element that is currently in focus is already inside the current slide
    if ($currentSlide && $currentSlide.contains(document.activeElement)) {
      return;
    }

    if (event) {
      event.preventDefault();
    }

    Fancybox.ignoreFocusChange = true;

    const allFocusableElems = Array.from($container.querySelectorAll(_shared_utils_setFocusOn_js__WEBPACK_IMPORTED_MODULE_2__.FOCUSABLE_ELEMENTS));

    let enabledElems = [];
    let $firstEl;

    for (let node of allFocusableElems) {
      // Enable element if it's visible and
      // is inside the current slide or is outside main carousel (for example, inside the toolbar)
      const isNodeVisible = node.offsetParent;
      const isNodeInsideCurrentSlide = $currentSlide && $currentSlide.contains(node);
      const isNodeOutsideCarousel = !this.Carousel.$viewport.contains(node);

      if (isNodeVisible && (isNodeInsideCurrentSlide || isNodeOutsideCarousel)) {
        enabledElems.push(node);

        if (node.dataset.origTabindex !== undefined) {
          node.tabIndex = node.dataset.origTabindex;
          node.removeAttribute("data-orig-tabindex");
        }

        if (
          node.hasAttribute("autoFocus") ||
          (!$firstEl && isNodeInsideCurrentSlide && !node.classList.contains("carousel__button"))
        ) {
          $firstEl = node;
        }
      } else {
        // Element is either hidden or is inside preloaded slide (e.g., not inside current slide, but next/prev)
        node.dataset.origTabindex =
          node.dataset.origTabindex === undefined ? node.getAttribute("tabindex") : node.dataset.origTabindex;

        node.tabIndex = -1;
      }
    }

    if (!event) {
      if (this.option("autoFocus") && $firstEl) {
        (0,_shared_utils_setFocusOn_js__WEBPACK_IMPORTED_MODULE_2__.setFocusOn)($firstEl);
      } else if (enabledElems.indexOf(document.activeElement) < 0) {
        (0,_shared_utils_setFocusOn_js__WEBPACK_IMPORTED_MODULE_2__.setFocusOn)($container);
      }
    } else {
      if (enabledElems.indexOf(event.target) > -1) {
        this.lastFocus = event.target;
      } else {
        if (this.lastFocus === $container) {
          (0,_shared_utils_setFocusOn_js__WEBPACK_IMPORTED_MODULE_2__.setFocusOn)(enabledElems[enabledElems.length - 1]);
        } else {
          (0,_shared_utils_setFocusOn_js__WEBPACK_IMPORTED_MODULE_2__.setFocusOn)($container);
        }
      }
    }

    this.lastFocus = document.activeElement;

    Fancybox.ignoreFocusChange = false;
  }

  /**
   * Hide vertical page scrollbar and adjust right padding value of `body` element to prevent content from shifting
   * (otherwise the `body` element may become wider and the content may expand horizontally).
   */
  hideScrollbar() {
    if (!_shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_1__.canUseDOM) {
      return;
    }

    const scrollbarWidth = window.innerWidth - document.documentElement.getBoundingClientRect().width;
    const id = "fancybox-style-noscroll";

    let $style = document.getElementById(id);

    if ($style) {
      return;
    }

    if (scrollbarWidth > 0) {
      $style = document.createElement("style");

      $style.id = id;
      $style.type = "text/css";
      $style.innerHTML = `.compensate-for-scrollbar {padding-right: ${scrollbarWidth}px;}`;

      document.getElementsByTagName("head")[0].appendChild($style);

      document.body.classList.add("compensate-for-scrollbar");
    }
  }

  /**
   * Stop hiding vertical page scrollbar
   */
  revealScrollbar() {
    document.body.classList.remove("compensate-for-scrollbar");

    const el = document.getElementById("fancybox-style-noscroll");

    if (el) {
      el.remove();
    }
  }

  /**
   * Remove content for given slide
   * @param {Object} slide - Carousel slide
   */
  clearContent(slide) {
    // * Clear previously added content and class name
    this.Carousel.trigger("removeSlide", slide);

    if (slide.$content) {
      slide.$content.remove();
      slide.$content = null;
    }

    if (slide.$closeButton) {
      slide.$closeButton.remove();
      slide.$closeButton = null;
    }

    if (slide._className) {
      slide.$el.classList.remove(slide._className);
    }
  }

  /**
   * Set new content for given slide
   * @param {Object} slide - Carousel slide
   * @param {HTMLElement|String} html - HTML element or string containing HTML code
   * @param {Object} [opts] - Options
   */
  setContent(slide, html, opts = {}) {
    let $content;

    const $el = slide.$el;

    if (html instanceof HTMLElement) {
      if (["img", "iframe", "video", "audio"].indexOf(html.nodeName.toLowerCase()) > -1) {
        $content = document.createElement("div");
        $content.appendChild(html);
      } else {
        $content = html;
      }
    } else {
      const $fragment = document.createRange().createContextualFragment(html);

      $content = document.createElement("div");
      $content.appendChild($fragment);
    }

    if (slide.filter && !slide.error) {
      $content = $content.querySelector(slide.filter);
    }

    if (!($content instanceof Element)) {
      this.setError(slide, "{{ELEMENT_NOT_FOUND}}");

      return;
    }

    // * Add class name indicating content type, for example `has-image`
    slide._className = `has-${opts.suffix || slide.type || "unknown"}`;

    $el.classList.add(slide._className);

    // * Set content
    $content.classList.add("fancybox__content");

    // Make sure that content is not hidden and will be visible
    if ($content.style.display === "none" || getComputedStyle($content).getPropertyValue("display") === "none") {
      $content.style.display = slide.display || this.option("defaultDisplay") || "flex";
    }

    if (slide.id) {
      $content.setAttribute("id", slide.id);
    }

    slide.$content = $content;

    $el.prepend($content);

    this.manageCloseButton(slide);

    if (slide.state !== "loading") {
      this.revealContent(slide);
    }

    return $content;
  }

  /**
   * Create close button if needed
   * @param {Object} slide
   */
  manageCloseButton(slide) {
    const position = slide.closeButton === undefined ? this.option("closeButton") : slide.closeButton;

    if (!position || (position === "top" && this.$closeButton)) {
      return;
    }

    const $btn = document.createElement("button");

    $btn.classList.add("carousel__button", "is-close");
    $btn.setAttribute("title", this.options.l10n.CLOSE);
    $btn.innerHTML = this.option("template.closeButton");

    $btn.addEventListener("click", (e) => this.close(e));

    if (position === "inside") {
      // Remove existing one to avoid scope issues
      if (slide.$closeButton) {
        slide.$closeButton.remove();
      }

      slide.$closeButton = slide.$content.appendChild($btn);
    } else {
      this.$closeButton = this.$container.insertBefore($btn, this.$container.firstChild);
    }
  }

  /**
   * Make content visible for given slide and optionally start CSS animation
   * @param {Object} slide - Carousel slide
   */
  revealContent(slide) {
    this.trigger("reveal", slide);

    slide.$content.style.visibility = "";

    // Add CSS class name that reveals content (default animation is "fadeIn")
    let showClass = false;

    if (
      !(
        slide.error ||
        slide.state === "loading" ||
        this.Carousel.prevPage !== null ||
        slide.index !== this.options.startIndex
      )
    ) {
      showClass = slide.showClass === undefined ? this.option("showClass") : slide.showClass;
    }

    if (!showClass) {
      this.done(slide);

      return;
    }

    slide.state = "animating";

    this.animateCSS(slide.$content, showClass, () => {
      this.done(slide);
    });
  }

  /**
   * Add class name to given HTML element and wait for `animationend` event to execute callback
   * @param {HTMLElement} $el
   * @param {String} className
   * @param {Function} callback - A callback to run
   */
  animateCSS($element, className, callback) {
    if ($element) {
      $element.dispatchEvent(new CustomEvent("animationend", { bubbles: true, cancelable: true }));
    }

    if (!$element || !className) {
      if (typeof callback === "function") {
        callback();
      }

      return;
    }

    const handleAnimationEnd = function (event) {
      if (event.currentTarget === this) {
        $element.removeEventListener("animationend", handleAnimationEnd);

        if (callback) {
          callback();
        }

        $element.classList.remove(className);
      }
    };

    $element.addEventListener("animationend", handleAnimationEnd);
    $element.classList.add(className);
  }

  /**
   * Mark given slide as `done`, e.g., content is loaded and displayed completely
   * @param {Object} slide - Carousel slide
   */
  done(slide) {
    slide.state = "done";

    this.trigger("done", slide);

    // Trigger focus for current slide (and ignore preloaded slides)
    const currentSlide = this.getSlide();

    if (currentSlide && slide.index === currentSlide.index && this.option("autoFocus")) {
      this.focus();
    }
  }

  /**
   * Set error message as slide content
   * @param {Object} slide - Carousel slide
   * @param {String} message - Error message, can contain HTML code and template variables
   */
  setError(slide, message) {
    slide.error = message;

    this.hideLoading(slide);
    this.clearContent(slide);

    // Create new content
    const div = document.createElement("div");
    div.classList.add("fancybox-error");
    div.innerHTML = this.localize(message || "<p>{{ERROR}}</p>");

    this.setContent(slide, div, { suffix: "error" });
  }

  /**
   * Create loading indicator inside given slide
   * @param {Object} slide - Carousel slide
   */
  showLoading(slide) {
    slide.state = "loading";

    slide.$el.classList.add("is-loading");

    let $spinner = slide.$el.querySelector(".fancybox__spinner");

    if ($spinner) {
      return;
    }

    $spinner = document.createElement("div");

    $spinner.classList.add("fancybox__spinner");
    $spinner.innerHTML = this.option("template.spinner");

    $spinner.addEventListener("click", () => {
      if (!this.Carousel.Panzoom.velocity) this.close();
    });

    slide.$el.prepend($spinner);
  }

  /**
   * Remove loading indicator from given slide
   * @param {Object} slide - Carousel slide
   */
  hideLoading(slide) {
    const $spinner = slide.$el && slide.$el.querySelector(".fancybox__spinner");

    if ($spinner) {
      $spinner.remove();

      slide.$el.classList.remove("is-loading");
    }

    if (slide.state === "loading") {
      this.trigger("load", slide);

      slide.state = "ready";
    }
  }

  /**
   * Slide carousel to next page
   */
  next() {
    const carousel = this.Carousel;

    if (carousel && carousel.pages.length > 1) {
      carousel.slideNext();
    }
  }

  /**
   * Slide carousel to previous page
   */
  prev() {
    const carousel = this.Carousel;

    if (carousel && carousel.pages.length > 1) {
      carousel.slidePrev();
    }
  }

  /**
   * Slide carousel to selected page with optional parameters
   * Examples:
   *    Fancybox.getInstance().jumpTo(2);
   *    Fancybox.getInstance().jumpTo(3, {friction: 0})
   * @param  {...any} args - Arguments for Carousel `slideTo` method
   */
  jumpTo(...args) {
    if (this.Carousel) this.Carousel.slideTo(...args);
  }

  /**
   * Check if current instance is trying to close or is already closed
   * @returns {Boolean}
   */
  isClosing() {
    return ["closing", "customClosing", "destroy"].includes(this.state);
  }

  /**
   * Check if the current instance is not blocked by another instance
   * @returns {Boolean}
   */
  isTopmost() {
    return Fancybox.getInstance().id == this.id;
  }

  /**
   * Start closing the current instance
   * @param {Event} [event] - Optional click event
   */
  close(event) {
    if (event) event.preventDefault();

    // First, stop further execution if this instance is already closing
    // (this can happen if, for example, user clicks close button multiple times really fast)
    if (this.isClosing()) {
      return;
    }

    // Allow callbacks and/or plugins to prevent closing
    if (this.trigger("shouldClose", event) === false) {
      return;
    }

    this.state = "closing";

    this.Carousel.Panzoom.destroy();

    this.detachEvents();

    this.trigger("closing", event);

    if (this.state === "destroy") {
      return;
    }

    // Trigger default CSS closing animation for backdrop and interface elements
    this.$container.setAttribute("aria-hidden", "true");

    this.$container.classList.add("is-closing");

    // Clear inactive slides
    const currentSlide = this.getSlide();

    this.Carousel.slides.forEach((slide) => {
      if (slide.$content && slide.index !== currentSlide.index) {
        this.Carousel.trigger("removeSlide", slide);
      }
    });

    // Start default closing animation
    if (this.state === "closing") {
      const hideClass = currentSlide.hideClass === undefined ? this.option("hideClass") : currentSlide.hideClass;

      this.animateCSS(
        currentSlide.$content,
        hideClass,
        () => {
          this.destroy();
        },
        true
      );
    }
  }

  /**
   * Clean up after closing fancybox
   */
  destroy() {
    if (this.state === "destroy") {
      return;
    }

    this.state = "destroy";

    this.trigger("destroy");

    const $trigger = this.option("placeFocusBack") ? this.option("triggerTarget", this.getSlide().$trigger) : null;

    // Destroy Carousel and then detach plugins;
    // * Note: this order allows plugins to receive `removeSlide` event
    this.Carousel.destroy();

    this.detachPlugins();

    this.Carousel = null;

    this.options = {};
    this.events = {};

    this.$container.remove();

    this.$container = this.$backdrop = this.$carousel = null;

    if ($trigger) {
      (0,_shared_utils_setFocusOn_js__WEBPACK_IMPORTED_MODULE_2__.setFocusOn)($trigger);
    }

    instances.delete(this.id);

    const nextInstance = Fancybox.getInstance();

    if (nextInstance) {
      nextInstance.focus();
      return;
    }

    document.documentElement.classList.remove("with-fancybox");
    document.body.classList.remove("is-using-mouse");

    this.revealScrollbar();
  }

  /**
   * Create new Fancybox instance with provided options
   * Example:
   *   Fancybox.show([{ src : 'https://lipsum.app/id/1/300x225' }]);
   * @param {Array} items - Gallery items
   * @param {Object} [options] - Optional custom options
   * @returns {Object} Fancybox instance
   */
  static show(items, options = {}) {
    return new Fancybox(items, options);
  }

  /**
   * Starts Fancybox if event target matches any opener or target is `trigger element`
   * @param {Event} event - Click event
   * @param {Object} [options] - Optional custom options
   */
  static fromEvent(event, options = {}) {
    //  Allow other scripts to prevent starting fancybox on click
    if (event.defaultPrevented) {
      return;
    }

    // Don't run if right-click
    if (event.button && event.button !== 0) {
      return;
    }

    // Ignore command/control + click
    if (event.ctrlKey || event.metaKey || event.shiftKey) {
      return;
    }

    const origTarget = event.composedPath()[0];
    let eventTarget = origTarget;

    // Support `trigger` element, e.g., start fancybox from different DOM element, for example,
    // to have one preview image for hidden image gallery
    let triggerGroupName;

    if (
      eventTarget.matches("[data-fancybox-trigger]") ||
      (eventTarget = eventTarget.closest("[data-fancybox-trigger]"))
    ) {
      options.triggerTarget = eventTarget;
      triggerGroupName = eventTarget && eventTarget.dataset && eventTarget.dataset.fancyboxTrigger;
    }

    if (triggerGroupName) {
      const triggerItems = document.querySelectorAll(`[data-fancybox="${triggerGroupName}"]`);
      const triggerIndex = parseInt(eventTarget.dataset.fancyboxIndex, 10) || 0;

      eventTarget = triggerItems.length ? triggerItems[triggerIndex] : eventTarget;
    }

    // * Try to find matching openener
    let matchingOpener;
    let target;

    Array.from(Fancybox.openers.keys())
      .reverse()
      .some((opener) => {
        target = eventTarget || origTarget;

        let found = false;

        try {
          if (target instanceof Element && (typeof opener === "string" || opener instanceof String)) {
            // Chain closest() to event.target to find and return the parent element,
            // regardless if clicking on the child elements (icon, label, etc)
            found = target.matches(opener) || (target = target.closest(opener));
          }
        } catch (error) {}

        if (found) {
          event.preventDefault();
          matchingOpener = opener;
          return true;
        }

        return false;
      });

    let rez = false;

    if (matchingOpener) {
      options.event = event;
      options.target = target;

      target.origTarget = origTarget;

      rez = Fancybox.fromOpener(matchingOpener, options);

      // Check if the mouse is being used
      // Waiting for better browser support for `:focus-visible` -
      // https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo
      const nextInstance = Fancybox.getInstance();

      if (nextInstance && nextInstance.state === "ready" && event.detail) {
        document.body.classList.add("is-using-mouse");
      }
    }

    return rez;
  }

  /**
   * Starts Fancybox using selector
   * @param {String} opener - Valid CSS selector string
   * @param {Object} [options] - Optional custom options
   */
  static fromOpener(opener, options = {}) {
    // Callback function called once for each group element that
    // 1) converts data attributes to boolean or JSON
    // 2) removes values that could cause issues
    const mapCallback = function (el) {
      const falseValues = ["false", "0", "no", "null", "undefined"];
      const trueValues = ["true", "1", "yes"];

      const dataset = Object.assign({}, el.dataset);
      const options = {};

      for (let [key, value] of Object.entries(dataset)) {
        if (key === "fancybox") {
          continue;
        }

        if (key === "width" || key === "height") {
          options[`_${key}`] = value;
        } else if (typeof value === "string" || value instanceof String) {
          if (falseValues.indexOf(value) > -1) {
            options[key] = false;
          } else if (trueValues.indexOf(options[key]) > -1) {
            options[key] = true;
          } else {
            try {
              options[key] = JSON.parse(value);
            } catch (e) {
              options[key] = value;
            }
          }
        } else {
          options[key] = value;
        }
      }

      if (el instanceof Element) {
        options.$trigger = el;
      }

      return options;
    };

    let items = [],
      index = options.startIndex || 0,
      target = options.target || null;

    // Get options
    // ===
    options = (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, Fancybox.openers.get(opener));

    // Get matching nodes
    // ===
    const groupAll = options.groupAll === undefined ? false : options.groupAll;

    const groupAttr = options.groupAttr === undefined ? "data-fancybox" : options.groupAttr;
    const groupValue = groupAttr && target ? target.getAttribute(`${groupAttr}`) : "";

    if (!target || groupValue || groupAll) {
      const $root = options.root || (target ? target.getRootNode() : document.body);

      items = [].slice.call($root.querySelectorAll(opener));
    }

    if (target && !groupAll) {
      if (groupValue) {
        items = items.filter((el) => el.getAttribute(`${groupAttr}`) === groupValue);
      } else {
        items = [target];
      }
    }

    if (!items.length) {
      return false;
    }

    // Exit if current instance is triggered from the same element
    // ===
    const currentInstance = Fancybox.getInstance();

    if (currentInstance && items.indexOf(currentInstance.options.$trigger) > -1) {
      return false;
    }

    // Start Fancybox
    // ===

    // Get index of current item in the gallery
    index = target ? items.indexOf(target) : index;

    // Convert items in a format supported by fancybox
    items = items.map(mapCallback);

    // * Create new fancybox instance
    return new Fancybox(
      items,
      (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, {
        startIndex: index,
        $trigger: target,
      })
    );
  }

  /**
   * Attach a click handler function that starts Fancybox to the selected items, as well as to all future matching elements.
   * @param {String} selector - Selector that should match trigger elements
   * @param {Object} [options] - Custom options
   */
  static bind(selector, options = {}) {
    function attachClickEvent() {
      document.body.addEventListener("click", Fancybox.fromEvent, false);
    }

    if (!_shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_1__.canUseDOM) {
      return;
    }

    if (!Fancybox.openers.size) {
      if (/complete|interactive|loaded/.test(document.readyState)) {
        attachClickEvent();
      } else {
        document.addEventListener("DOMContentLoaded", attachClickEvent);
      }
    }

    Fancybox.openers.set(selector, options);
  }

  /**
   * Remove the click handler that was attached with `bind()`
   * @param {String} selector - A selector which should match the one originally passed to .bind()
   */
  static unbind(selector) {
    Fancybox.openers.delete(selector);

    if (!Fancybox.openers.size) {
      Fancybox.destroy();
    }
  }

  /**
   * Immediately destroy all instances (without closing animation) and clean up all bindings..
   */
  static destroy() {
    let fb;

    while ((fb = Fancybox.getInstance())) {
      fb.destroy();
    }

    Fancybox.openers = new Map();

    document.body.removeEventListener("click", Fancybox.fromEvent, false);
  }

  /**
   * Retrieve instance by identifier or the top most instance, if identifier is not provided
   * @param {String|Numeric} [id] - Optional instance identifier
   */
  static getInstance(id) {
    if (id) {
      return instances.get(id);
    }

    const instance = Array.from(instances.values())
      .reverse()
      .find((instance) => {
        if (!instance.isClosing()) {
          return instance;
        }

        return false;
      });

    return instance || null;
  }

  /**
   * Close all or topmost currently active instance.
   * @param {boolean} [all] - All or only topmost active instance
   * @param {any} [arguments] - Optional data
   */
  static close(all = true, args) {
    if (all) {
      for (const instance of instances.values()) {
        instance.close(args);
      }
    } else {
      const instance = Fancybox.getInstance();

      if (instance) {
        instance.close(args);
      }
    }
  }

  /**
   * Slide topmost currently active instance to next page
   */
  static next() {
    const instance = Fancybox.getInstance();

    if (instance) {
      instance.next();
    }
  }

  /**
   * Slide topmost currently active instance to previous page
   */
  static prev() {
    const instance = Fancybox.getInstance();

    if (instance) {
      instance.prev();
    }
  }
}

// Expose version
Fancybox.version = "__VERSION__";

// Expose defaults
Fancybox.defaults = defaults;

// Expose openers
Fancybox.openers = new Map();

// Add default plugins
Fancybox.Plugins = _plugins_index_js__WEBPACK_IMPORTED_MODULE_5__.Plugins;

// Auto init with default options
Fancybox.bind("[data-fancybox]");

// Prepare plugins
for (const [key, Plugin] of Object.entries(Fancybox.Plugins || {})) {
  if (typeof Plugin.create === "function") {
    Plugin.create(Fancybox);
  }
}




/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/l10n/en.js":
/*!************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/l10n/en.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  CLOSE: "Close",
  NEXT: "Next",
  PREV: "Previous",
  MODAL: "You can close this modal content with the ESC key",
  ERROR: "Something Went Wrong, Please Try Again Later",
  IMAGE_ERROR: "Image Not Found",
  ELEMENT_NOT_FOUND: "HTML Element Not Found",
  AJAX_NOT_FOUND: "Error Loading AJAX : Not Found",
  AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden",
  IFRAME_ERROR: "Error Loading Page",
  TOGGLE_ZOOM: "Toggle zoom level",
  TOGGLE_THUMBS: "Toggle thumbnails",
  TOGGLE_SLIDESHOW: "Toggle slideshow",
  TOGGLE_FULLSCREEN: "Toggle full-screen mode",
  DOWNLOAD: "Download",
});


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Hash/Hash.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Hash/Hash.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hash: () => (/* binding */ Hash)
/* harmony export */ });
/* harmony import */ var _shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/canUseDOM.js */ "./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js");


class Hash {
  constructor(fancybox) {
    this.fancybox = fancybox;

    for (const methodName of ["onChange", "onClosing"]) {
      this[methodName] = this[methodName].bind(this);
    }

    this.events = {
      initCarousel: this.onChange,
      "Carousel.change": this.onChange,
      closing: this.onClosing,
    };

    this.hasCreatedHistory = false;
    this.origHash = "";
    this.timer = null;
  }

  /**
   * Process `Carousel.ready` and `Carousel.change` events to update URL hash
   * @param {Object} fancybox
   * @param {Object} carousel
   */
  onChange(fancybox) {
    const carousel = fancybox.Carousel;

    if (this.timer) {
      clearTimeout(this.timer);
    }

    const firstRun = carousel.prevPage === null;
    const currentSlide = fancybox.getSlide();

    const currentHash = new URL(document.URL).hash;

    let newHash = false;

    if (currentSlide.slug) {
      newHash = "#" + currentSlide.slug;
    } else {
      const dataset = currentSlide.$trigger && currentSlide.$trigger.dataset;
      const slug = fancybox.option("slug") || (dataset && dataset.fancybox);

      if (slug && slug.length && slug !== "true") {
        newHash = "#" + slug + (carousel.slides.length > 1 ? "-" + (currentSlide.index + 1) : "");
      }
    }

    if (firstRun) {
      this.origHash = currentHash !== newHash ? currentHash : "";
    }

    if (newHash && currentHash !== newHash) {
      this.timer = setTimeout(() => {
        try {
          window.history[firstRun ? "pushState" : "replaceState"](
            {},
            document.title,
            window.location.pathname + window.location.search + newHash
          );

          if (firstRun) {
            this.hasCreatedHistory = true;
          }
        } catch (e) {}
      }, 300);
    }
  }

  /**
   * Process `closing` event to clean up
   */
  onClosing() {
    if (this.timer) {
      clearTimeout(this.timer);
    }

    // Skip if closing is triggered by pressing  browser back button or by changing hash manually
    if (this.hasSilentClose === true) {
      return;
    }

    // Restore original url
    try {
      window.history.replaceState(
        {},
        document.title,
        window.location.pathname + window.location.search + (this.origHash || "")
      );

      return;
    } catch (e) {}
  }

  attach(fancybox) {
    fancybox.on(this.events);
  }

  detach(fancybox) {
    fancybox.off(this.events);
  }

  /**
   * Start fancybox from current URL hash,
   * this will be called on page load OR/AND after changing URL hash
   * @param {Class} Fancybox
   */
  static startFromUrl() {
    const Fancybox = Hash.Fancybox;

    if (!Fancybox || Fancybox.getInstance() || Fancybox.defaults.Hash === false) {
      return;
    }

    const { hash, slug, index } = Hash.getParsedURL();

    if (!slug) {
      return;
    }

    // Support custom slug
    // ===
    let selectedElem = document.querySelector(`[data-slug="${hash}"]`);

    if (selectedElem) {
      selectedElem.dispatchEvent(new CustomEvent("click", { bubbles: true, cancelable: true }));
    }

    if (Fancybox.getInstance()) {
      return;
    }

    // If elements are not found by custom slug, use URL hash value as group name
    // ===
    const groupElems = document.querySelectorAll(`[data-fancybox="${slug}"]`);

    if (!groupElems.length) {
      return;
    }

    if (index === null && groupElems.length === 1) {
      selectedElem = groupElems[0];
    } else if (index) {
      selectedElem = groupElems[index - 1];
    }

    if (selectedElem) {
      selectedElem.dispatchEvent(new CustomEvent("click", { bubbles: true, cancelable: true }));
    }
  }

  /**
   * Handle `hash` change, change gallery item to current index or start/close current instance
   */
  static onHashChange() {
    const { slug, index } = Hash.getParsedURL();

    const Fancybox = Hash.Fancybox;
    const instance = Fancybox && Fancybox.getInstance();

    if (instance && instance.plugins.Hash) {
      // Check if hash matches currently active gallery
      if (slug) {
        const carousel = instance.Carousel;

        /**
         * Support manually opened gallery
         */
        if (slug === instance.option("slug")) {
          return carousel.slideTo(index - 1);
        }

        /**
         * Check if URL hash matches `data-slug` value of active element
         */
        for (let slide of carousel.slides) {
          if (slide.slug && slide.slug === slug) {
            return carousel.slideTo(slide.index);
          }
        }

        /**
         * Check if URL hash matches `data-fancybox` value of active element
         */
        const slide = instance.getSlide();
        const dataset = slide.$trigger && slide.$trigger.dataset;

        if (dataset && dataset.fancybox === slug) {
          return carousel.slideTo(index - 1);
        }
      }

      /**
       * Close if no matching element found
       */
      instance.plugins.Hash.hasSilentClose = true;

      instance.close();
    }

    /**
     * Attempt to start
     */
    Hash.startFromUrl();
  }

  /**
   * Add event bindings that will start new Fancybox instance based in the current URL
   */
  static create(Fancybox) {
    Hash.Fancybox = Fancybox;

    function proceed() {
      window.addEventListener("hashchange", Hash.onHashChange, false);

      Hash.startFromUrl();
    }

    if (_shared_utils_canUseDOM_js__WEBPACK_IMPORTED_MODULE_0__.canUseDOM) {
      window.requestAnimationFrame(() => {
        if (/complete|interactive|loaded/.test(document.readyState)) {
          proceed();
        } else {
          document.addEventListener("DOMContentLoaded", proceed);
        }
      });
    }
  }

  static destroy() {
    window.removeEventListener("hashchange", Hash.onHashChange, false);
  }

  /**
   * Helper method to split URL hash into useful pieces
   */
  static getParsedURL() {
    const hash = window.location.hash.substr(1),
      tmp = hash.split("-"),
      index = tmp.length > 1 && /^\+?\d+$/.test(tmp[tmp.length - 1]) ? parseInt(tmp.pop(-1), 10) || null : null,
      slug = tmp.join("-");

    return {
      hash,
      slug,
      index,
    };
  }
}


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Html/Html.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Html/Html.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Html: () => (/* binding */ Html)
/* harmony export */ });
/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/extend.js */ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js");


const buildURLQuery = (src, obj) => {
  const url = new URL(src);
  const params = new URLSearchParams(url.search);

  let rez = new URLSearchParams();

  for (const [key, value] of [...params, ...Object.entries(obj)]) {
    // Youtube
    if (key === "t") {
      rez.set("start", parseInt(value));
    } else {
      rez.set(key, value);
    }
  }

  // Convert to 'foo=1&bar=2&baz=3'
  rez = rez.toString();

  // Vimeo
  // https://vimeo.zendesk.com/hc/en-us/articles/360000121668-Starting-playback-at-a-specific-timecode
  let matches = src.match(/#t=((.*)?\d+s)/);

  if (matches) {
    rez += `#t=${matches[1]}`;
  }

  return rez;
};

const defaults = {
  // General options for any video content (Youtube, Vimeo, HTML5 video)
  video: {
    autoplay: true,
    ratio: 16 / 9,
  },
  // Youtube embed parameters
  youtube: {
    autohide: 1,
    fs: 1,
    rel: 0,
    hd: 1,
    wmode: "transparent",
    enablejsapi: 1,
    html5: 1,
  },
  // Vimeo embed parameters
  vimeo: {
    hd: 1,
    show_title: 1,
    show_byline: 1,
    show_portrait: 0,
    fullscreen: 1,
  },
  // HTML5 video parameters
  html5video: {
    tpl: `<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">
  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn't support embedded videos.</video>`,
    format: "",
  },
};

class Html {
  constructor(fancybox) {
    this.fancybox = fancybox;

    for (const methodName of [
      "onInit",
      "onReady",

      "onCreateSlide",
      "onRemoveSlide",

      "onSelectSlide",
      "onUnselectSlide",

      "onRefresh",

      // For communication with iframed video (youtube/vimeo)
      "onMessage",
    ]) {
      this[methodName] = this[methodName].bind(this);
    }

    this.events = {
      init: this.onInit,
      ready: this.onReady,

      "Carousel.createSlide": this.onCreateSlide,
      "Carousel.removeSlide": this.onRemoveSlide,

      "Carousel.selectSlide": this.onSelectSlide,
      "Carousel.unselectSlide": this.onUnselectSlide,

      "Carousel.refresh": this.onRefresh,
    };
  }

  /**
   * Check if each gallery item has type when fancybox starts
   */
  onInit() {
    for (const slide of this.fancybox.items) {
      this.processType(slide);
    }
  }

  /**
   * Set content type for the slide
   * @param {Object} slide
   */
  processType(slide) {
    // Add support for `new Fancybox({items : [{html : 'smth'}]});`
    if (slide.html) {
      slide.src = slide.html;
      slide.type = "html";

      delete slide.html;

      return;
    }

    const src = slide.src || "";

    let type = slide.type || this.fancybox.options.type,
      rez = null;

    if (src && typeof src !== "string") {
      return;
    }

    if (
      (rez = src.match(
        /(?:youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i
      ))
    ) {
      const params = buildURLQuery(src, this.fancybox.option("Html.youtube"));
      const videoId = encodeURIComponent(rez[1]);

      slide.videoId = videoId;
      slide.src = `https://www.youtube-nocookie.com/embed/${videoId}?${params}`;
      slide.thumb = slide.thumb || `https://i.ytimg.com/vi/${videoId}/mqdefault.jpg`;
      slide.vendor = "youtube";

      type = "video";
    } else if ((rez = src.match(/^.+vimeo.com\/(?:\/)?([\d]+)(.*)?/))) {
      const params = buildURLQuery(src, this.fancybox.option("Html.vimeo"));
      const videoId = encodeURIComponent(rez[1]);

      slide.videoId = videoId;
      slide.src = `https://player.vimeo.com/video/${videoId}?${params}`;
      slide.vendor = "vimeo";

      type = "video";
    } else if (
      (rez = src.match(
        /(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i
      ))
    ) {
      slide.src = `//maps.google.${rez[1]}/?ll=${(rez[2]
        ? rez[2] + "&z=" + Math.floor(rez[3]) + (rez[4] ? rez[4].replace(/^\//, "&") : "")
        : rez[4] + ""
      ).replace(/\?/, "&")}&output=${rez[4] && rez[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`;

      type = "map";
    } else if ((rez = src.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i))) {
      slide.src = `//maps.google.${rez[1]}/maps?q=${rez[2].replace("query=", "q=").replace("api=1", "")}&output=embed`;

      type = "map";
    }

    // Guess content type
    if (!type) {
      if (src.charAt(0) === "#") {
        type = "inline";
      } else if ((rez = src.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i))) {
        type = "html5video";

        slide.format = slide.format || "video/" + (rez[1] === "ogv" ? "ogg" : rez[1]);
      } else if (src.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)) {
        type = "image";
      } else if (src.match(/\.(pdf)((\?|#).*)?$/i)) {
        type = "pdf";
      }
    }

    slide.type = type || this.fancybox.option("defaultType", "image");

    if (type === "html5video" || type === "video") {
      slide.video = (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.fancybox.option("Html.video"), slide.video);

      if (slide._width && slide._height) {
        slide.ratio = parseFloat(slide._width) / parseFloat(slide._height);
      } else {
        slide.ratio = slide.ratio || slide.video.ratio || defaults.video.ratio;
      }
    }
  }

  /**
   * Start loading content when Fancybox is ready
   */
  onReady() {
    this.fancybox.Carousel.slides.forEach((slide) => {
      if (slide.$el) {
        this.setContent(slide);

        if (slide.index === this.fancybox.getSlide().index) {
          this.playVideo(slide);
        }
      }
    });
  }

  /**
   * Process `Carousel.createSlide` event to create image content
   * @param {Object} fancybox
   * @param {Object} carousel
   * @param {Object} slide
   */
  onCreateSlide(fancybox, carousel, slide) {
    if (this.fancybox.state !== "ready") {
      return;
    }

    this.setContent(slide);
  }

  /**
   * Retrieve and set slide content
   * @param {Object} slide
   */
  loadInlineContent(slide) {
    let $content;

    if (slide.src instanceof HTMLElement) {
      $content = slide.src;
    } else if (typeof slide.src === "string") {
      const tmp = slide.src.split("#", 2);
      const id = tmp.length === 2 && tmp[0] === "" ? tmp[1] : tmp[0];

      $content = document.getElementById(id);
    }

    if ($content) {
      if (slide.type === "clone" || $content.$placeHolder) {
        $content = $content.cloneNode(true);
        let attrId = $content.getAttribute("id");

        attrId = attrId ? `${attrId}--clone` : `clone-${this.fancybox.id}-${slide.index}`;

        $content.setAttribute("id", attrId);
      } else {
        const $placeHolder = document.createElement("div");
        $placeHolder.classList.add("fancybox-placeholder");
        $content.parentNode.insertBefore($placeHolder, $content);
        $content.$placeHolder = $placeHolder;
      }

      this.fancybox.setContent(slide, $content);
    } else {
      this.fancybox.setError(slide, "{{ELEMENT_NOT_FOUND}}");
    }
  }

  /**
   * Makes AJAX request and sets response as slide content
   * @param {Object} slide
   */
  loadAjaxContent(slide) {
    const fancybox = this.fancybox;
    const xhr = new XMLHttpRequest();

    fancybox.showLoading(slide);

    xhr.onreadystatechange = function () {
      if (xhr.readyState === XMLHttpRequest.DONE) {
        if (fancybox.state === "ready") {
          fancybox.hideLoading(slide);

          if (xhr.status === 200) {
            fancybox.setContent(slide, xhr.responseText);
          } else {
            fancybox.setError(slide, xhr.status === 404 ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}");
          }
        }
      }
    };

    const data = slide.ajax || null;

    xhr.open(data ? "POST" : "GET", slide.src);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    xhr.send(data);

    slide.xhr = xhr;
  }

  /**
   * Creates iframe as slide content, preloads if needed before displaying
   * @param {Object} slide
   */
  loadIframeContent(slide) {
    const fancybox = this.fancybox;
    const $iframe = document.createElement("iframe");

    $iframe.className = "fancybox__iframe";

    $iframe.setAttribute("id", `fancybox__iframe_${fancybox.id}_${slide.index}`);

    $iframe.setAttribute("allow", "autoplay; fullscreen");
    $iframe.setAttribute("scrolling", "auto");

    slide.$iframe = $iframe;

    if (slide.type !== "iframe" || slide.preload === false) {
      $iframe.setAttribute("src", slide.src);

      this.fancybox.setContent(slide, $iframe);

      this.resizeIframe(slide);

      return;
    }

    fancybox.showLoading(slide);

    const $content = document.createElement("div");
    $content.style.visibility = "hidden";

    this.fancybox.setContent(slide, $content);

    $content.appendChild($iframe);

    $iframe.onerror = () => {
      fancybox.setError(slide, "{{IFRAME_ERROR}}");
    };

    $iframe.onload = () => {
      fancybox.hideLoading(slide);

      let isFirstLoad = false;

      if (!$iframe.isReady) {
        $iframe.isReady = true;
        isFirstLoad = true;
      }

      if (!$iframe.src.length) {
        return;
      }

      $iframe.parentNode.style.visibility = "";

      this.resizeIframe(slide);

      if (isFirstLoad) {
        fancybox.revealContent(slide);
      }
    };

    $iframe.setAttribute("src", slide.src);
  }

  /**
   * Set CSS max/min width/height properties of the content to have the correct aspect ratio
   * @param {Object} slide
   */
  setAspectRatio(slide) {
    const $content = slide.$content;
    const ratio = slide.ratio;

    if (!$content) {
      return;
    }

    let width = slide._width;
    let height = slide._height;

    if (ratio || (width && height)) {
      Object.assign($content.style, {
        width: width && height ? "100%" : "",
        height: width && height ? "100%" : "",
        maxWidth: "",
        maxHeight: "",
      });

      let maxWidth = $content.offsetWidth;
      let maxHeight = $content.offsetHeight;

      width = width || maxWidth;
      height = height || maxHeight;

      // Resize to fit
      if (width > maxWidth || height > maxHeight) {
        let maxRatio = Math.min(maxWidth / width, maxHeight / height);

        width = width * maxRatio;
        height = height * maxRatio;
      }

      // Recheck ratio
      if (Math.abs(width / height - ratio) > 0.01) {
        if (ratio < width / height) {
          width = height * ratio;
        } else {
          height = width / ratio;
        }
      }

      Object.assign($content.style, {
        width: `${width}px`,
        height: `${height}px`,
      });
    }
  }

  /**
   * Adjust the width and height of the iframe according to the content dimensions, or defined sizes
   * @param {Object} slide
   */
  resizeIframe(slide) {
    const $iframe = slide.$iframe;

    if (!$iframe) {
      return;
    }

    let width_ = slide._width || 0;
    let height_ = slide._height || 0;

    if (width_ && height_) {
      slide.autoSize = false;
    }

    const $parent = $iframe.parentNode;
    const parentStyle = $parent && $parent.style;

    if (slide.preload !== false && slide.autoSize !== false && parentStyle) {
      try {
        const compStyles = window.getComputedStyle($parent),
          paddingX = parseFloat(compStyles.paddingLeft) + parseFloat(compStyles.paddingRight),
          paddingY = parseFloat(compStyles.paddingTop) + parseFloat(compStyles.paddingBottom);

        const document = $iframe.contentWindow.document,
          $html = document.getElementsByTagName("html")[0],
          $body = document.body;

        // Allow content to expand horizontally
        parentStyle.width = "";

        // Get rid of vertical scrollbar
        $body.style.overflow = "hidden";

        width_ = width_ || $html.scrollWidth + paddingX;

        parentStyle.width = `${width_}px`;

        $body.style.overflow = "";

        parentStyle.flex = "0 0 auto";
        parentStyle.height = `${$body.scrollHeight}px`;

        height_ = $html.scrollHeight + paddingY;
      } catch (error) {
        //
      }
    }

    if (width_ || height_) {
      const newStyle = {
        flex: "0 1 auto",
      };

      if (width_) {
        newStyle.width = `${width_}px`;
      }

      if (height_) {
        newStyle.height = `${height_}px`;
      }

      Object.assign(parentStyle, newStyle);
    }
  }

  /**
   * Process `Carousel.onRefresh` event,
   * trigger iframe autosizing and set content aspect ratio for each slide
   * @param {Object} fancybox
   * @param {Object} carousel
   */
  onRefresh(fancybox, carousel) {
    carousel.slides.forEach((slide) => {
      if (!slide.$el) {
        return;
      }

      if (slide.$iframe) {
        this.resizeIframe(slide);
      }

      if (slide.ratio) {
        this.setAspectRatio(slide);
      }
    });
  }

  /**
   * Process `Carousel.onCreateSlide` event to set content
   * @param {Object} fancybox
   * @param {Object} carousel
   * @param {Object} slide
   */
  setContent(slide) {
    if (!slide || slide.isDom) {
      return;
    }

    switch (slide.type) {
      case "html":
        this.fancybox.setContent(slide, slide.src);
        break;

      case "html5video":
        this.fancybox.setContent(
          slide,
          this.fancybox
            .option("Html.html5video.tpl")
            .replace(/\{\{src\}\}/gi, slide.src)
            .replace("{{format}}", slide.format || (slide.html5video && slide.html5video.format) || "")
            .replace("{{poster}}", slide.poster || slide.thumb || "")
        );

        break;

      case "inline":
      case "clone":
        this.loadInlineContent(slide);
        break;

      case "ajax":
        this.loadAjaxContent(slide);
        break;

      case "pdf":
      case "video":
      case "map":
        slide.preload = false;

      case "iframe":
        this.loadIframeContent(slide);

        break;
    }

    if (slide.ratio) {
      this.setAspectRatio(slide);
    }
  }

  /**
   * Process `Carousel.onSelectSlide` event to start video
   * @param {Object} fancybox
   * @param {Object} carousel
   * @param {Object} slide
   */
  onSelectSlide(fancybox, carousel, slide) {
    if (fancybox.state === "ready") {
      this.playVideo(slide);
    }
  }

  /**
   * Attempts to begin playback of the media
   * @param {Object} slide
   */
  playVideo(slide) {
    if (slide.type === "html5video" && slide.video.autoplay) {
      try {
        const $video = slide.$el.querySelector("video");

        if ($video) {
          const promise = $video.play();

          if (promise !== undefined) {
            promise
              .then(() => {
                // Autoplay started
              })
              .catch((error) => {
                // Autoplay was prevented.
                $video.muted = true;
                $video.play();
              });
          }
        }
      } catch (err) {}
    }

    if (slide.type !== "video" || !(slide.$iframe && slide.$iframe.contentWindow)) {
      return;
    }

    // This function will be repeatedly called to check
    // if video iframe has been loaded to send message to start the video
    const poller = () => {
      if (slide.state === "done" && slide.$iframe && slide.$iframe.contentWindow) {
        let command;

        if (slide.$iframe.isReady) {
          if (slide.video && slide.video.autoplay) {
            if (slide.vendor == "youtube") {
              command = {
                event: "command",
                func: "playVideo",
              };
            } else {
              command = {
                method: "play",
                value: "true",
              };
            }
          }

          if (command) {
            slide.$iframe.contentWindow.postMessage(JSON.stringify(command), "*");
          }

          return;
        }

        if (slide.vendor === "youtube") {
          command = {
            event: "listening",
            id: slide.$iframe.getAttribute("id"),
          };

          slide.$iframe.contentWindow.postMessage(JSON.stringify(command), "*");
        }
      }

      slide.poller = setTimeout(poller, 250);
    };

    poller();
  }

  /**
   * Process `Carousel.onUnselectSlide` event to pause video
   * @param {Object} fancybox
   * @param {Object} carousel
   * @param {Object} slide
   */
  onUnselectSlide(fancybox, carousel, slide) {
    if (slide.type === "html5video") {
      try {
        slide.$el.querySelector("video").pause();
      } catch (error) {}

      return;
    }

    let command = false;

    if (slide.vendor == "vimeo") {
      command = {
        method: "pause",
        value: "true",
      };
    } else if (slide.vendor === "youtube") {
      command = {
        event: "command",
        func: "pauseVideo",
      };
    }

    if (command && slide.$iframe && slide.$iframe.contentWindow) {
      slide.$iframe.contentWindow.postMessage(JSON.stringify(command), "*");
    }

    clearTimeout(slide.poller);
  }

  /**
   * Process `Carousel.onRemoveSlide` event to do clean up
   * @param {Object} fancybox
   * @param {Object} carousel
   * @param {Object} slide
   */
  onRemoveSlide(fancybox, carousel, slide) {
    // Abort ajax request if exists
    if (slide.xhr) {
      slide.xhr.abort();
      slide.xhr = null;
    }

    // Unload iframe content if exists
    if (slide.$iframe) {
      slide.$iframe.onload = slide.$iframe.onerror = null;

      slide.$iframe.src = "//about:blank";
      slide.$iframe = null;
    }

    // Clear inline content
    const $content = slide.$content;

    if (slide.type === "inline" && $content) {
      $content.classList.remove("fancybox__content");

      if ($content.style.display !== "none") {
        $content.style.display = "none";
      }
    }

    if (slide.$closeButton) {
      slide.$closeButton.remove();
      slide.$closeButton = null;
    }

    const $placeHolder = $content && $content.$placeHolder;

    if ($placeHolder) {
      $placeHolder.parentNode.insertBefore($content, $placeHolder);
      $placeHolder.remove();
      $content.$placeHolder = null;
    }
  }

  /**
   * Process `window.message` event to mark video iframe element as `ready`
   * @param {Object} e - Event
   */
  onMessage(e) {
    try {
      let data = JSON.parse(e.data);

      if (e.origin === "https://player.vimeo.com") {
        if (data.event === "ready") {
          for (let $iframe of document.getElementsByClassName("fancybox__iframe")) {
            if ($iframe.contentWindow === e.source) {
              $iframe.isReady = 1;
            }
          }
        }
      } else if (e.origin === "https://www.youtube-nocookie.com") {
        if (data.event === "onReady") {
          document.getElementById(data.id).isReady = 1;
        }
      }
    } catch (ex) {}
  }

  attach() {
    this.fancybox.on(this.events);

    window.addEventListener("message", this.onMessage, false);
  }

  detach() {
    this.fancybox.off(this.events);

    window.removeEventListener("message", this.onMessage, false);
  }
}

// Expose defaults
Html.defaults = defaults;


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Image/Image.js":
/*!************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Image/Image.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Image: () => (/* binding */ Image)
/* harmony export */ });
/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/extend.js */ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js");
/* harmony import */ var _Panzoom_Panzoom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Panzoom/Panzoom.js */ "./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js");




const defaults = {
  // Class name for slide element indicating that content can be zoomed in
  canZoomInClass: "can-zoom_in",

  // Class name for slide element indicating that content can be zoomed out
  canZoomOutClass: "can-zoom_out",

  // Do zoom animation from thumbnail image when starting or closing fancybox
  zoom: true,

  // Animate opacity while zooming
  zoomOpacity: "auto", // "auto" | true | false,

  // Zoom animation friction
  zoomFriction: 0.82,

  // Disable zoom animation if thumbnail is visible only partly
  ignoreCoveredThumbnail: false,

  // Enable guestures
  touch: true,

  // Action to be performed when user clicks on the image
  click: "toggleZoom", // "toggleZoom" | "next" | "close" | null

  // Action to be performed when double-click event is detected on the image
  doubleClick: null, // "toggleZoom" | null

  // Action to be performed when user rotates a wheel button on a pointing device
  wheel: "zoom", // "zoom" | "slide" | "close" | null

  // How image should be resized to fit its container
  fit: "contain", // "contain" | "contain-w" | "cover"

  // Should create wrapping element around the image
  wrap: false,

  // Custom Panzoom options
  Panzoom: {
    ratio: 1,
  },
};

class Image {
  constructor(fancybox) {
    this.fancybox = fancybox;

    for (const methodName of [
      // Fancybox
      "onReady",
      "onClosing",
      "onDone",

      // Fancybox.Carousel
      "onPageChange",
      "onCreateSlide",
      "onRemoveSlide",

      // Image load/error
      "onImageStatusChange",
    ]) {
      this[methodName] = this[methodName].bind(this);
    }

    this.events = {
      ready: this.onReady,
      closing: this.onClosing,
      done: this.onDone,

      "Carousel.change": this.onPageChange,
      "Carousel.createSlide": this.onCreateSlide,
      "Carousel.removeSlide": this.onRemoveSlide,
    };
  }

  /**
   * Handle `ready` event to start loading content
   */
  onReady() {
    this.fancybox.Carousel.slides.forEach((slide) => {
      if (slide.$el) {
        this.setContent(slide);
      }
    });
  }

  /**
   * Handle `done` event to update cursor
   * @param {Object} fancybox
   * @param {Object} slide
   */
  onDone(fancybox, slide) {
    this.handleCursor(slide);
  }

  /**
   * Handle `closing` event to clean up all slides and to start zoom-out animation
   * @param {Object} fancybox
   */
  onClosing(fancybox) {
    clearTimeout(this.clickTimer);
    this.clickTimer = null;

    // Remove events
    fancybox.Carousel.slides.forEach((slide) => {
      if (slide.$image) {
        slide.state = "destroy";
      }

      if (slide.Panzoom) {
        slide.Panzoom.detachEvents();
      }
    });

    // If possible, start the zoom animation, it will interrupt the default closing process
    if (this.fancybox.state === "closing" && this.canZoom(fancybox.getSlide())) {
      this.zoomOut();
    }
  }

  /**
   * Process `Carousel.createSlide` event to create image content
   * @param {Object} fancybox
   * @param {Object} carousel
   * @param {Object} slide
   */
  onCreateSlide(fancybox, carousel, slide) {
    if (this.fancybox.state !== "ready") {
      return;
    }

    this.setContent(slide);
  }

  /**
   * Handle `Carousel.removeSlide` event to do clean up the slide
   * @param {Object} fancybox
   * @param {Object} carousel
   * @param {Object} slide
   */
  onRemoveSlide(fancybox, carousel, slide) {
    if (slide.$image) {
      slide.$el.classList.remove(fancybox.option("Image.canZoomInClass"));

      slide.$image.remove();
      slide.$image = null;
    }

    if (slide.Panzoom) {
      slide.Panzoom.destroy();
      slide.Panzoom = null;
    }

    if (slide.$el && slide.$el.dataset) {
      delete slide.$el.dataset.imageFit;
    }
  }

  /**
   * Build DOM elements and add event listeners
   * @param {Object} slide
   */
  setContent(slide) {
    // Check if this slide should contain an image
    if (slide.isDom || slide.html || (slide.type && slide.type !== "image")) {
      return;
    }

    if (slide.$image) {
      return;
    }

    slide.type = "image";
    slide.state = "loading";

    // * Build layout
    // Container
    const $content = document.createElement("div");
    $content.style.visibility = "hidden";

    // Image element
    const $image = document.createElement("img");

    $image.addEventListener("load", (event) => {
      event.stopImmediatePropagation();

      this.onImageStatusChange(slide);
    });

    $image.addEventListener("error", () => {
      this.onImageStatusChange(slide);
    });

    $image.src = slide.src;
    $image.alt = "";
    $image.draggable = false;

    $image.classList.add("fancybox__image");

    if (slide.srcset) {
      $image.setAttribute("srcset", slide.srcset);
    }

    if (slide.sizes) {
      $image.setAttribute("sizes", slide.sizes);
    }

    slide.$image = $image;

    const shouldWrap = this.fancybox.option("Image.wrap");

    if (shouldWrap) {
      const $wrap = document.createElement("div");
      $wrap.classList.add(typeof shouldWrap === "string" ? shouldWrap : "fancybox__image-wrap");

      $wrap.appendChild($image);

      $content.appendChild($wrap);

      slide.$wrap = $wrap;
    } else {
      $content.appendChild($image);
    }

    // Set data attribute if other that default
    // for example, set `[data-image-fit="contain-w"]`
    slide.$el.dataset.imageFit = this.fancybox.option("Image.fit");

    // Append content
    this.fancybox.setContent(slide, $content);

    // Display loading icon
    if ($image.complete || $image.error) {
      this.onImageStatusChange(slide);
    } else {
      this.fancybox.showLoading(slide);
    }
  }

  /**
   * Handle image state change, display error or start revealing image
   * @param {Object} slide
   */
  onImageStatusChange(slide) {
    const $image = slide.$image;

    if (!$image || slide.state !== "loading") {
      return;
    }

    if (!($image.complete && $image.naturalWidth && $image.naturalHeight)) {
      this.fancybox.setError(slide, "{{IMAGE_ERROR}}");

      return;
    }

    this.fancybox.hideLoading(slide);

    if (this.fancybox.option("Image.fit") === "contain") {
      this.initSlidePanzoom(slide);
    }

    // Add `wheel` and `click` event handler
    slide.$el.addEventListener("wheel", (event) => this.onWheel(slide, event), { passive: false });
    slide.$content.addEventListener("click", (event) => this.onClick(slide, event), { passive: false });

    this.revealContent(slide);
  }

  /**
   * Make image zoomable and draggable using Panzoom
   * @param {Object} slide
   */
  initSlidePanzoom(slide) {
    if (slide.Panzoom) {
      return;
    }

    //* Initialize Panzoom
    slide.Panzoom = new _Panzoom_Panzoom_js__WEBPACK_IMPORTED_MODULE_1__.Panzoom(
      slide.$el,
      (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)(true, this.fancybox.option("Image.Panzoom", {}), {
        viewport: slide.$wrap,
        content: slide.$image,

        width: slide._width,
        height: slide._height,

        wrapInner: false,

        // Allow to select caption text
        textSelection: true,

        // Toggle gestures
        touch: this.fancybox.option("Image.touch"),

        // This will prevent click conflict with fancybox main carousel
        panOnlyZoomed: true,

        // Disable default click / wheel events as custom event listeners will replace them,
        // because click and wheel events should work without Panzoom
        click: false,
        wheel: false,
      })
    );

    slide.Panzoom.on("startAnimation", () => {
      this.fancybox.trigger("Image.startAnimation", slide);
    });

    slide.Panzoom.on("endAnimation", () => {
      if (slide.state === "zoomIn") {
        this.fancybox.done(slide);
      }

      this.handleCursor(slide);

      this.fancybox.trigger("Image.endAnimation", slide);
    });

    slide.Panzoom.on("afterUpdate", () => {
      this.handleCursor(slide);

      this.fancybox.trigger("Image.afterUpdate", slide);
    });
  }

  /**
   * Start zoom-in animation if possible, or simply reveal content
   * @param {Object} slide
   */
  revealContent(slide) {
    // Animate only on first run
    if (
      this.fancybox.Carousel.prevPage === null &&
      slide.index === this.fancybox.options.startIndex &&
      this.canZoom(slide)
    ) {
      this.zoomIn();
    } else {
      this.fancybox.revealContent(slide);
    }
  }

  /**
   * Get zoom info for selected slide
   * @param {Object} slide
   */
  getZoomInfo(slide) {
    const $thumb = slide.$thumb,
      thumbRect = $thumb.getBoundingClientRect(),
      thumbWidth = thumbRect.width,
      thumbHeight = thumbRect.height,
      //
      contentRect = slide.$content.getBoundingClientRect(),
      contentWidth = contentRect.width,
      contentHeight = contentRect.height,
      //
      shiftedTop = contentRect.top - thumbRect.top,
      shiftedLeft = contentRect.left - thumbRect.left;

    // Check if need to update opacity
    let opacity = this.fancybox.option("Image.zoomOpacity");

    if (opacity === "auto") {
      opacity = Math.abs(thumbWidth / thumbHeight - contentWidth / contentHeight) > 0.1;
    }

    return {
      top: shiftedTop,
      left: shiftedLeft,
      scale: contentWidth && thumbWidth ? thumbWidth / contentWidth : 1,
      opacity: opacity,
    };
  }

  /**
   * Determine if it is possible to do zoom-in animation
   */
  canZoom(slide) {
    const fancybox = this.fancybox,
      $container = fancybox.$container;

    if (window.visualViewport && window.visualViewport.scale !== 1) {
      return false;
    }

    if (slide.Panzoom && !slide.Panzoom.content.width) {
      return false;
    }

    if (!fancybox.option("Image.zoom") || fancybox.option("Image.fit") !== "contain") {
      return false;
    }

    const $thumb = slide.$thumb;

    if (!$thumb || slide.state === "loading") {
      return false;
    }

    // * Check if thumbnail image is really visible
    $container.classList.add("fancybox__no-click");

    const rect = $thumb.getBoundingClientRect();

    let rez;

    // Check if thumbnail image is actually visible on the screen
    if (this.fancybox.option("Image.ignoreCoveredThumbnail")) {
      const visibleTopLeft = document.elementFromPoint(rect.left + 1, rect.top + 1) === $thumb;
      const visibleBottomRight = document.elementFromPoint(rect.right - 1, rect.bottom - 1) === $thumb;

      rez = visibleTopLeft && visibleBottomRight;
    } else {
      rez = document.elementFromPoint(rect.left + rect.width * 0.5, rect.top + rect.height * 0.5) === $thumb;
    }

    $container.classList.remove("fancybox__no-click");

    return rez;
  }

  /**
   * Perform zoom-in animation
   */
  zoomIn() {
    const fancybox = this.fancybox,
      slide = fancybox.getSlide(),
      Panzoom = slide.Panzoom;

    const { top, left, scale, opacity } = this.getZoomInfo(slide);

    fancybox.trigger("reveal", slide);

    // Scale and move to start position
    Panzoom.panTo({
      x: left * -1,
      y: top * -1,
      scale: scale,
      friction: 0,
      ignoreBounds: true,
    });

    slide.$content.style.visibility = "";

    slide.state = "zoomIn";

    if (opacity === true) {
      Panzoom.on("afterTransform", (panzoom) => {
        if (slide.state === "zoomIn" || slide.state === "zoomOut") {
          panzoom.$content.style.opacity = Math.min(1, 1 - (1 - panzoom.content.scale) / (1 - scale));
        }
      });
    }

    // Animate back to original position
    Panzoom.panTo({
      x: 0,
      y: 0,
      scale: 1,
      friction: this.fancybox.option("Image.zoomFriction"),
    });
  }

  /**
   * Perform zoom-out animation
   */
  zoomOut() {
    const fancybox = this.fancybox,
      slide = fancybox.getSlide(),
      Panzoom = slide.Panzoom;

    if (!Panzoom) {
      return;
    }

    slide.state = "zoomOut";
    fancybox.state = "customClosing";

    if (slide.$caption) {
      slide.$caption.style.visibility = "hidden";
    }

    let friction = this.fancybox.option("Image.zoomFriction");

    const animatePosition = (event) => {
      const { top, left, scale, opacity } = this.getZoomInfo(slide);

      // Increase speed on the first run if opacity is not animated
      if (!event && !opacity) {
        friction *= 0.82;
      }

      Panzoom.panTo({
        x: left * -1,
        y: top * -1,
        scale,
        friction,
        ignoreBounds: true,
      });

      // Gradually increase speed
      friction *= 0.98;
    };

    // Page scrolling will cause thumbnail to change position on the display,
    // therefore animation end position has to be recalculated after each page scroll
    window.addEventListener("scroll", animatePosition);

    Panzoom.once("endAnimation", () => {
      window.removeEventListener("scroll", animatePosition);
      fancybox.destroy();
    });

    animatePosition();
  }

  /**
   * Set the type of mouse cursor to indicate if content is zoomable
   * @param {Object} slide
   */
  handleCursor(slide) {
    if (slide.type !== "image" || !slide.$el) {
      return;
    }

    const panzoom = slide.Panzoom;
    const clickAction = this.fancybox.option("Image.click", false, slide);
    const touchIsEnabled = this.fancybox.option("Image.touch");

    const classList = slide.$el.classList;

    const zoomInClass = this.fancybox.option("Image.canZoomInClass");
    const zoomOutClass = this.fancybox.option("Image.canZoomOutClass");

    classList.remove(zoomOutClass);
    classList.remove(zoomInClass);

    if (panzoom && clickAction === "toggleZoom") {
      const canZoomIn =
        panzoom && panzoom.content.scale === 1 && panzoom.option("maxScale") - panzoom.content.scale > 0.01;

      if (canZoomIn) {
        classList.add(zoomInClass);
      } else if (panzoom.content.scale > 1 && !touchIsEnabled) {
        classList.add(zoomOutClass);
      }
    } else if (clickAction === "close") {
      classList.add(zoomOutClass);
    }
  }

  /**
   * Handle `wheel` event
   * @param {Object} slide
   * @param {Object} event
   */
  onWheel(slide, event) {
    if (this.fancybox.state !== "ready") {
      return;
    }

    if (this.fancybox.trigger("Image.wheel", event) === false) {
      return;
    }

    switch (this.fancybox.option("Image.wheel")) {
      case "zoom":
        if (slide.state === "done") {
          slide.Panzoom && slide.Panzoom.zoomWithWheel(event);
        }

        break;

      case "close":
        this.fancybox.close();

        break;

      case "slide":
        this.fancybox[event.deltaY < 0 ? "prev" : "next"]();

        break;
    }
  }

  /**
   * Handle `click` and `dblclick` events
   * @param {Object} slide
   * @param {Object} event
   */
  onClick(slide, event) {
    // Check that clicks should be allowed
    if (this.fancybox.state !== "ready") {
      return;
    }

    const panzoom = slide.Panzoom;

    if (
      panzoom &&
      (panzoom.dragPosition.midPoint ||
        panzoom.dragOffset.x !== 0 ||
        panzoom.dragOffset.y !== 0 ||
        panzoom.dragOffset.scale !== 1)
    ) {
      return;
    }

    if (this.fancybox.Carousel.Panzoom.lockAxis) {
      return false;
    }

    const process = (action) => {
      switch (action) {
        case "toggleZoom":
          event.stopPropagation();

          slide.Panzoom && slide.Panzoom.zoomWithClick(event);

          break;

        case "close":
          this.fancybox.close();

          break;

        case "next":
          event.stopPropagation();

          this.fancybox.next();

          break;
      }
    };

    const clickAction = this.fancybox.option("Image.click");
    const dblclickAction = this.fancybox.option("Image.doubleClick");

    if (dblclickAction) {
      if (this.clickTimer) {
        clearTimeout(this.clickTimer);
        this.clickTimer = null;

        process(dblclickAction);
      } else {
        this.clickTimer = setTimeout(() => {
          this.clickTimer = null;
          process(clickAction);
        }, 300);
      }
    } else {
      process(clickAction);
    }
  }

  /**
   * Handle `Carousel.change` event to reset zoom level for any zoomed in/out content
   * and to revel content of the current page
   * @param {Object} fancybox
   * @param {Object} carousel
   */
  onPageChange(fancybox, carousel) {
    const currSlide = fancybox.getSlide();

    carousel.slides.forEach((slide) => {
      if (!slide.Panzoom || slide.state !== "done") {
        return;
      }

      if (slide.index !== currSlide.index) {
        slide.Panzoom.panTo({
          x: 0,
          y: 0,
          scale: 1,
          friction: 0.8,
        });
      }
    });
  }

  attach() {
    this.fancybox.on(this.events);
  }

  detach() {
    this.fancybox.off(this.events);
  }
}

// Expose defaults
Image.defaults = defaults;


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/ScrollLock/ScrollLock.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/ScrollLock/ScrollLock.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ScrollLock: () => (/* binding */ ScrollLock)
/* harmony export */ });
/* harmony import */ var _src_shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../src/shared/utils/isScrollable.js */ "./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js");


class ScrollLock {
  constructor(fancybox) {
    this.fancybox = fancybox;
    this.viewport = null;

    this.pendingUpdate = null;

    for (const methodName of ["onReady", "onResize", "onTouchstart", "onTouchmove"]) {
      this[methodName] = this[methodName].bind(this);
    }
  }

  /**
   * Process `initLayout` event to attach event listeners and resize viewport if needed
   */
  onReady() {
    //* Support Visual Viewport API
    // https://developer.mozilla.org/en-US/docs/Web/API/Visual_Viewport_API
    const viewport = window.visualViewport;

    if (viewport) {
      this.viewport = viewport;
      this.startY = 0;

      viewport.addEventListener("resize", this.onResize);

      this.updateViewport();
    }

    //* Prevent bouncing while scrolling on mobile devices
    window.addEventListener("touchstart", this.onTouchstart, { passive: false });
    window.addEventListener("touchmove", this.onTouchmove, { passive: false });

    //* Prevent window scrolling with mouse wheel
    window.addEventListener("wheel", this.onWheel, { passive: false });
  }

  /**
   * Handle `resize` event to call `updateViewport`
   */
  onResize() {
    this.updateViewport();
  }

  /**
   * Scale $container proportionally to actually fit inside browser,
   * e.g., disable viewport zooming
   */
  updateViewport() {
    const fancybox = this.fancybox,
      viewport = this.viewport,
      scale = viewport.scale || 1,
      $container = fancybox.$container;

    if (!$container) {
      return;
    }

    let width = "",
      height = "",
      transform = "";

    if (scale - 1 > 0.1) {
      width = `${viewport.width * scale}px`;
      height = `${viewport.height * scale}px`;
      transform = `translate3d(${viewport.offsetLeft}px, ${viewport.offsetTop}px, 0) scale(${1 / scale})`;
    }

    $container.style.width = width;
    $container.style.height = height;
    $container.style.transform = transform;
  }

  /**
   * Handle `touchstart` event to mark drag start position
   * @param {Object} event
   */
  onTouchstart(event) {
    this.startY = event.touches ? event.touches[0].screenY : event.screenY;
  }

  /**
   * Handle `touchmove` event to fix scrolling on mobile devices (iOS)
   * @param {Object} event
   */
  onTouchmove(event) {
    const startY = this.startY;
    const zoom = window.innerWidth / window.document.documentElement.clientWidth;

    if (!event.cancelable) {
      return;
    }

    if (event.touches.length > 1 || zoom !== 1) {
      return;
    }

    const el = (0,_src_shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_0__.isScrollable)(event.composedPath()[0]);

    if (!el) {
      event.preventDefault();
      return;
    }

    const style = window.getComputedStyle(el);
    const height = parseInt(style.getPropertyValue("height"), 10);

    const curY = event.touches ? event.touches[0].screenY : event.screenY;

    const isAtTop = startY <= curY && el.scrollTop === 0;
    const isAtBottom = startY >= curY && el.scrollHeight - el.scrollTop === height;

    if (isAtTop || isAtBottom) {
      event.preventDefault();
    }
  }

  /**
   * Handle `wheel` event
   */
  onWheel(event) {
    if (!(0,_src_shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_0__.isScrollable)(event.composedPath()[0])) {
      event.preventDefault();
    }
  }

  /**
   * Clean everything up
   */
  cleanup() {
    if (this.pendingUpdate) {
      cancelAnimationFrame(this.pendingUpdate);
      this.pendingUpdate = null;
    }

    const viewport = this.viewport;

    if (viewport) {
      viewport.removeEventListener("resize", this.onResize);
      this.viewport = null;
    }

    window.removeEventListener("touchstart", this.onTouchstart, false);
    window.removeEventListener("touchmove", this.onTouchmove, false);

    window.removeEventListener("wheel", this.onWheel, { passive: false });
  }

  attach() {
    this.fancybox.on("initLayout", this.onReady);
  }

  detach() {
    this.fancybox.off("initLayout", this.onReady);

    this.cleanup();
  }
}


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Thumbs/Thumbs.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Thumbs/Thumbs.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Thumbs: () => (/* binding */ Thumbs)
/* harmony export */ });
/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/extend.js */ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js");
/* harmony import */ var _Carousel_Carousel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Carousel/Carousel.js */ "./node_modules/@fancyapps/ui/src/Carousel/Carousel.js");



const defaults = {
  // The minimum number of images in the gallery to display thumbnails
  minSlideCount: 2,

  // Minimum screen height to display thumbnails
  minScreenHeight: 500,

  // Automatically show thumbnails when opened
  autoStart: true,

  // Keyboard shortcut to toggle thumbnail container
  key: "t",

  // Customize Carousel instance
  Carousel: {},

  tpl: `<div class="fancybox__thumb" style="background-image:url('{{src}}')"></div>`,
};

class Thumbs {
  constructor(fancybox) {
    this.fancybox = fancybox;

    this.$container = null;
    this.state = "init";

    for (const methodName of ["onPrepare", "onClosing", "onKeydown"]) {
      this[methodName] = this[methodName].bind(this);
    }

    this.events = {
      prepare: this.onPrepare,
      closing: this.onClosing,
      keydown: this.onKeydown,
    };
  }

  /**
   * Process `prepare` event to build the layout
   */
  onPrepare() {
    // Get slides, skip if the total number is less than the minimum
    const slides = this.getSlides();

    if (slides.length < this.fancybox.option("Thumbs.minSlideCount")) {
      this.state = "disabled";
      return;
    }

    if (
      this.fancybox.option("Thumbs.autoStart") === true &&
      this.fancybox.Carousel.Panzoom.content.height >= this.fancybox.option("Thumbs.minScreenHeight")
    ) {
      this.build();
    }
  }

  /**
   * Process `closing` event to disable all events
   */
  onClosing() {
    if (this.Carousel) {
      this.Carousel.Panzoom.detachEvents();
    }
  }

  /**
   * Process `keydown` event to enable thumbnail list toggling using keyboard key
   * @param {Object} fancybox
   * @param {String} key
   */
  onKeydown(fancybox, key) {
    if (key === fancybox.option("Thumbs.key")) {
      this.toggle();
    }
  }

  /**
   * Build layout and init thumbnail Carousel
   */
  build() {
    if (this.$container) {
      return;
    }

    // Create wrapping element and append to layout
    const $container = document.createElement("div");

    $container.classList.add("fancybox__thumbs");

    this.fancybox.$carousel.parentNode.insertBefore($container, this.fancybox.$carousel.nextSibling);

    // Initialise thumbnail carousel with all slides
    this.Carousel = new _Carousel_Carousel_js__WEBPACK_IMPORTED_MODULE_1__.Carousel(
      $container,
      (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)(
        true,
        {
          Dots: false,
          Navigation: false,
          Sync: {
            friction: 0,
          },
          infinite: false,
          center: true,
          fill: true,
          dragFree: true,
          slidesPerPage: 1,
          preload: 1,
        },
        this.fancybox.option("Thumbs.Carousel"),
        {
          Sync: {
            target: this.fancybox.Carousel,
          },
          slides: this.getSlides(),
        }
      )
    );

    // Slide carousel on wheel event
    this.Carousel.Panzoom.on("wheel", (panzoom, event) => {
      event.preventDefault();

      this.fancybox[event.deltaY < 0 ? "prev" : "next"]();
    });

    this.$container = $container;

    this.state = "visible";
  }

  /**
   * Process all fancybox slides to get all thumbnail images
   */
  getSlides() {
    const slides = [];

    for (const slide of this.fancybox.items) {
      const thumb = slide.thumb;

      if (thumb) {
        slides.push({
          html: this.fancybox.option("Thumbs.tpl").replace(/\{\{src\}\}/gi, thumb),
          customClass: `has-thumb has-${slide.type || "image"}`,
        });
      }
    }

    return slides;
  }

  /**
   * Toggle visibility of thumbnail list
   * Tip: you can use `Fancybox.getInstance().plugins.Thumbs.toggle()` from anywhere in your code
   */
  toggle() {
    if (this.state === "visible") {
      this.hide();
    } else if (this.state === "hidden") {
      this.show();
    } else {
      this.build();
    }
  }

  /**
   * Show thumbnail list
   */
  show() {
    if (this.state === "hidden") {
      this.$container.style.display = "";

      this.Carousel.Panzoom.attachEvents();

      this.state = "visible";
    }
  }

  /**
   * Hide thumbnail list
   */
  hide() {
    if (this.state === "visible") {
      this.Carousel.Panzoom.detachEvents();

      this.$container.style.display = "none";

      this.state = "hidden";
    }
  }

  /**
   * Reset the state
   */
  cleanup() {
    if (this.Carousel) {
      this.Carousel.destroy();
      this.Carousel = null;
    }

    if (this.$container) {
      this.$container.remove();
      this.$container = null;
    }

    this.state = "init";
  }

  attach() {
    this.fancybox.on(this.events);
  }

  detach() {
    this.fancybox.off(this.events);

    this.cleanup();
  }
}

// Expose defaults
Thumbs.defaults = defaults;


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Toolbar/Toolbar.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/Toolbar/Toolbar.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Toolbar: () => (/* binding */ Toolbar)
/* harmony export */ });
/* harmony import */ var _shared_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/utils/isPlainObject.js */ "./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js");
/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../shared/utils/extend.js */ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js");
/* harmony import */ var _shared_utils_Fullscreen_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../shared/utils/Fullscreen.js */ "./node_modules/@fancyapps/ui/src/shared/utils/Fullscreen.js");
/* harmony import */ var _shared_utils_Slideshow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../shared/utils/Slideshow.js */ "./node_modules/@fancyapps/ui/src/shared/utils/Slideshow.js");






const defaults = {
  // What toolbar items to display
  display: [
    "counter",
    //"prev",
    //"next",
    //"download",
    "zoom",
    "slideshow",
    "fullscreen",
    "thumbs",
    "close",
  ],

  // Only create a toolbar item if there is at least one image in the group
  autoEnable: true,

  // Toolbar items; can be links, buttons or `div` elements
  items: {
    counter: {
      position: "left",
      type: "div",
      class: "fancybox__counter",
      html: '<span data-fancybox-index=""></span>&nbsp;/&nbsp;<span data-fancybox-count=""></span>',
      attr: { tabindex: -1 },
    },
    prev: {
      type: "button",
      class: "fancybox__button--prev",
      label: "PREV",
      html: '<svg viewBox="0 0 24 24"><path d="M15 4l-8 8 8 8"/></svg>',
      attr: { "data-fancybox-prev": "" },
    },
    next: {
      type: "button",
      class: "fancybox__button--next",
      label: "NEXT",
      html: '<svg viewBox="0 0 24 24"><path d="M8 4l8 8-8 8"/></svg>',
      attr: { "data-fancybox-next": "" },
    },
    fullscreen: {
      type: "button",
      class: "fancybox__button--fullscreen",
      label: "TOGGLE_FULLSCREEN",
      html: `<svg viewBox="0 0 24 24">
                <g><path d="M3 8 V3h5"></path><path d="M21 8V3h-5"></path><path d="M8 21H3v-5"></path><path d="M16 21h5v-5"></path></g>
                <g><path d="M7 2v5H2M17 2v5h5M2 17h5v5M22 17h-5v5"/></g>
            </svg>`,
      click: function (event) {
        event.preventDefault();

        if (_shared_utils_Fullscreen_js__WEBPACK_IMPORTED_MODULE_2__.Fullscreen.element()) {
          _shared_utils_Fullscreen_js__WEBPACK_IMPORTED_MODULE_2__.Fullscreen.deactivate();
        } else {
          _shared_utils_Fullscreen_js__WEBPACK_IMPORTED_MODULE_2__.Fullscreen.activate(this.fancybox.$container);
        }
      },
    },
    slideshow: {
      type: "button",
      class: "fancybox__button--slideshow",
      label: "TOGGLE_SLIDESHOW",
      html: `<svg viewBox="0 0 24 24">
                <g><path d="M6 4v16"/><path d="M20 12L6 20"/><path d="M20 12L6 4"/></g>
                <g><path d="M7 4v15M17 4v15"/></g>
            </svg>`,
      click: function (event) {
        event.preventDefault();

        this.Slideshow.toggle();
      },
    },
    zoom: {
      type: "button",
      class: "fancybox__button--zoom",
      label: "TOGGLE_ZOOM",
      html: '<svg viewBox="0 0 24 24"><circle cx="10" cy="10" r="7"></circle><path d="M16 16 L21 21"></svg>',
      click: function (event) {
        event.preventDefault();

        const panzoom = this.fancybox.getSlide().Panzoom;

        if (panzoom) {
          panzoom.toggleZoom();
        }
      },
    },
    download: {
      type: "link",
      label: "DOWNLOAD",
      class: "fancybox__button--download",
      html: '<svg viewBox="0 0 24 24"><path d="M12 15V3m0 12l-4-4m4 4l4-4M2 17l.62 2.48A2 2 0 004.56 21h14.88a2 2 0 001.94-1.51L22 17"/></svg>',
      click: function (event) {
        event.stopPropagation();
      },
    },
    thumbs: {
      type: "button",
      label: "TOGGLE_THUMBS",
      class: "fancybox__button--thumbs",
      html: '<svg viewBox="0 0 24 24"><circle cx="4" cy="4" r="1" /><circle cx="12" cy="4" r="1" transform="rotate(90 12 4)"/><circle cx="20" cy="4" r="1" transform="rotate(90 20 4)"/><circle cx="4" cy="12" r="1" transform="rotate(90 4 12)"/><circle cx="12" cy="12" r="1" transform="rotate(90 12 12)"/><circle cx="20" cy="12" r="1" transform="rotate(90 20 12)"/><circle cx="4" cy="20" r="1" transform="rotate(90 4 20)"/><circle cx="12" cy="20" r="1" transform="rotate(90 12 20)"/><circle cx="20" cy="20" r="1" transform="rotate(90 20 20)"/></svg>',
      click: function (event) {
        event.stopPropagation();

        const thumbs = this.fancybox.plugins.Thumbs;

        if (thumbs) {
          thumbs.toggle();
        }
      },
    },
    close: {
      type: "button",
      label: "CLOSE",
      class: "fancybox__button--close",
      html: '<svg viewBox="0 0 24 24"><path d="M20 20L4 4m16 0L4 20"></path></svg>',
      attr: { "data-fancybox-close": "", tabindex: 0 },
    },
  },
};

class Toolbar {
  constructor(fancybox) {
    this.fancybox = fancybox;

    this.$container = null;
    this.state = "init";

    for (const methodName of [
      "onInit",
      "onPrepare",
      "onDone",
      "onKeydown",
      "onClosing",
      "onChange",
      "onSettle",
      "onRefresh",
    ]) {
      this[methodName] = this[methodName].bind(this);
    }

    this.events = {
      init: this.onInit,
      prepare: this.onPrepare,
      done: this.onDone,
      keydown: this.onKeydown,
      closing: this.onClosing,

      // Clear Slideshow when user strts to change current slide
      "Carousel.change": this.onChange,

      // Set timer after carousel changes current slide; deactive if last slide is reached
      "Carousel.settle": this.onSettle,

      // Deactivate Slideshow on user interaction
      "Carousel.Panzoom.touchStart": () => this.onRefresh(),

      "Image.startAnimation": (fancybox, slide) => this.onRefresh(slide),
      "Image.afterUpdate": (fancybox, slide) => this.onRefresh(slide),
    };
  }

  onInit() {
    // Disable self if current group does not contain at least one image
    if (this.fancybox.option("Toolbar.autoEnable")) {
      let hasImage = false;

      for (const item of this.fancybox.items) {
        if (item.type === "image") {
          hasImage = true;
          break;
        }
      }

      if (!hasImage) {
        this.state = "disabled";
        return;
      }
    }

    // Disable the creation of a close button, if one exists in the toolbar
    for (const key of this.fancybox.option("Toolbar.display")) {
      const id = (0,_shared_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(key) ? key.id : key;

      if (id === "close") {
        this.fancybox.options.closeButton = false;

        break;
      }
    }
  }

  onPrepare() {
    const fancybox = this.fancybox;
    // Skip if disabled
    if (this.state !== "init") {
      return;
    }

    this.build();

    this.update();

    this.Slideshow = new _shared_utils_Slideshow_js__WEBPACK_IMPORTED_MODULE_3__.Slideshow(fancybox);

    if (!fancybox.Carousel.prevPage) {
      if (fancybox.option("slideshow.autoStart")) {
        this.Slideshow.activate();
      }

      if (fancybox.option("fullscreen.autoStart") && !_shared_utils_Fullscreen_js__WEBPACK_IMPORTED_MODULE_2__.Fullscreen.element()) {
        try {
          _shared_utils_Fullscreen_js__WEBPACK_IMPORTED_MODULE_2__.Fullscreen.activate(fancybox.$container);
        } catch (error) {}
      }
    }
  }

  onFsChange() {
    window.scrollTo(_shared_utils_Fullscreen_js__WEBPACK_IMPORTED_MODULE_2__.Fullscreen.pageXOffset, _shared_utils_Fullscreen_js__WEBPACK_IMPORTED_MODULE_2__.Fullscreen.pageYOffset);
  }

  onSettle() {
    const fancybox = this.fancybox;
    const slideshow = this.Slideshow;

    if (slideshow && slideshow.isActive()) {
      if (fancybox.getSlide().index === fancybox.Carousel.slides.length - 1 && !fancybox.option("infinite")) {
        slideshow.deactivate();
      } else if (fancybox.getSlide().state === "done") {
        slideshow.setTimer();
      }
    }
  }

  onChange() {
    this.update();

    if (this.Slideshow && this.Slideshow.isActive()) {
      this.Slideshow.clearTimer();
    }
  }

  onDone(fancybox, slide) {
    const slideshow = this.Slideshow;

    if (slide.index === fancybox.getSlide().index) {
      this.update();

      if (slideshow && slideshow.isActive()) {
        if (!fancybox.option("infinite") && slide.index === fancybox.Carousel.slides.length - 1) {
          slideshow.deactivate();
        } else {
          slideshow.setTimer();
        }
      }
    }
  }

  onRefresh(slide) {
    if (!slide || slide.index === this.fancybox.getSlide().index) {
      this.update();

      if (this.Slideshow && this.Slideshow.isActive() && (!slide || slide.state === "done")) {
        this.Slideshow.deactivate();
      }
    }
  }

  onKeydown(fancybox, key, event) {
    if (key === " " && this.Slideshow) {
      this.Slideshow.toggle();

      event.preventDefault();
    }
  }

  onClosing() {
    if (this.Slideshow) {
      this.Slideshow.deactivate();
    }

    document.removeEventListener("fullscreenchange", this.onFsChange);
  }

  /**
   * Create link, button or `div` element for the toolbar
   * @param {Object} obj
   * @returns HTMLElement
   */
  createElement(obj) {
    let $el;

    if (obj.type === "div") {
      $el = document.createElement("div");
    } else {
      $el = document.createElement(obj.type === "link" ? "a" : "button");
      $el.classList.add("carousel__button");
    }

    $el.innerHTML = obj.html;

    $el.setAttribute("tabindex", obj.tabindex || 0);

    if (obj.class) {
      $el.classList.add(...obj.class.split(" "));
    }

    for (const prop in obj.attr) {
      $el.setAttribute(prop, obj.attr[prop]);
    }

    if (obj.label) {
      $el.setAttribute("title", this.fancybox.localize(`{{${obj.label}}}`));
    }

    if (obj.click) {
      $el.addEventListener("click", obj.click.bind(this));
    }

    if (obj.id === "prev") {
      $el.setAttribute("data-fancybox-prev", "");
    }

    if (obj.id === "next") {
      $el.setAttribute("data-fancybox-next", "");
    }

    const $svg = $el.querySelector("svg");

    if ($svg) {
      $svg.setAttribute("role", "img");
      $svg.setAttribute("tabindex", "-1");
      $svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    }

    return $el;
  }

  /**
   * Create all DOM elements
   */
  build() {
    this.cleanup();

    const all_items = this.fancybox.option("Toolbar.items");
    const all_groups = [
      {
        position: "left",
        items: [],
      },
      {
        position: "center",
        items: [],
      },
      {
        position: "right",
        items: [],
      },
    ];

    const thumbs = this.fancybox.plugins.Thumbs;

    // 1st step - group toolbar elements by position
    for (const key of this.fancybox.option("Toolbar.display")) {
      let id, item;

      if ((0,_shared_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(key)) {
        id = key.id;
        item = (0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, all_items[id], key);
      } else {
        id = key;
        item = all_items[id];
      }

      if (["counter", "next", "prev", "slideshow"].includes(id) && this.fancybox.items.length < 2) {
        continue;
      }

      if (id === "fullscreen") {
        if (!document.fullscreenEnabled || window.fullScreen) {
          continue;
        }

        document.addEventListener("fullscreenchange", this.onFsChange);
      }

      if (id === "thumbs" && (!thumbs || thumbs.state === "disabled")) {
        continue;
      }

      if (!item) {
        continue;
      }

      let position = item.position || "right";

      let group = all_groups.find((obj) => obj.position === position);

      if (group) {
        group.items.push(item);
      }
    }

    // 2st step - create DOM elements
    const $container = document.createElement("div");
    $container.classList.add("fancybox__toolbar");

    for (const group of all_groups) {
      if (group.items.length) {
        const $wrap = document.createElement("div");
        $wrap.classList.add("fancybox__toolbar__items");
        $wrap.classList.add(`fancybox__toolbar__items--${group.position}`);

        for (const obj of group.items) {
          $wrap.appendChild(this.createElement(obj));
        }

        $container.appendChild($wrap);
      }
    }

    // Add toolbar container to DOM
    this.fancybox.$carousel.parentNode.insertBefore($container, this.fancybox.$carousel);

    this.$container = $container;
  }

  /**
   * Update element state depending on index of current slide
   */
  update() {
    const slide = this.fancybox.getSlide();
    const idx = slide.index;
    const cnt = this.fancybox.items.length;

    // Download links
    // ====
    const src = slide.downloadSrc || (slide.type === "image" && !slide.error ? slide.src : null);

    for (const $el of this.fancybox.$container.querySelectorAll("a.fancybox__button--download")) {
      if (src) {
        $el.removeAttribute("disabled");
        $el.removeAttribute("tabindex");

        $el.setAttribute("href", src);
        $el.setAttribute("download", src);
        $el.setAttribute("target", "_blank");
      } else {
        $el.setAttribute("disabled", "");
        $el.setAttribute("tabindex", -1);

        $el.removeAttribute("href");
        $el.removeAttribute("download");
      }
    }

    // Zoom button
    // ===
    const panzoom = slide.Panzoom;
    const canZoom = panzoom && panzoom.option("maxScale") > panzoom.option("baseScale");

    for (const $el of this.fancybox.$container.querySelectorAll(".fancybox__button--zoom")) {
      if (canZoom) {
        $el.removeAttribute("disabled");
      } else {
        $el.setAttribute("disabled", "");
      }
    }

    // Counter
    // ====
    for (const $el of this.fancybox.$container.querySelectorAll("[data-fancybox-index]")) {
      $el.innerHTML = slide.index + 1;
    }

    for (const $el of this.fancybox.$container.querySelectorAll("[data-fancybox-count]")) {
      $el.innerHTML = cnt;
    }

    // Disable previous/next links if gallery is not infinite and has reached start/end
    // ===
    if (!this.fancybox.option("infinite")) {
      for (const $el of this.fancybox.$container.querySelectorAll("[data-fancybox-prev]")) {
        if (idx === 0) {
          $el.setAttribute("disabled", "");
        } else {
          $el.removeAttribute("disabled");
        }
      }

      for (const $el of this.fancybox.$container.querySelectorAll("[data-fancybox-next]")) {
        if (idx === cnt - 1) {
          $el.setAttribute("disabled", "");
        } else {
          $el.removeAttribute("disabled");
        }
      }
    }
  }

  cleanup() {
    if (this.Slideshow && this.Slideshow.isActive()) {
      this.Slideshow.clearTimer();
    }

    if (this.$container) {
      this.$container.remove();
    }

    this.$container = null;
  }

  attach() {
    this.fancybox.on(this.events);
  }

  detach() {
    this.fancybox.off(this.events);

    this.cleanup();
  }
}

// Expose defaults
Toolbar.defaults = defaults;


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Fancybox/plugins/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Plugins: () => (/* binding */ Plugins)
/* harmony export */ });
/* harmony import */ var _ScrollLock_ScrollLock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ScrollLock/ScrollLock.js */ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/ScrollLock/ScrollLock.js");
/* harmony import */ var _Thumbs_Thumbs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Thumbs/Thumbs.js */ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Thumbs/Thumbs.js");
/* harmony import */ var _Html_Html_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Html/Html.js */ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Html/Html.js");
/* harmony import */ var _Image_Image_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Image/Image.js */ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Image/Image.js");
/* harmony import */ var _Hash_Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash/Hash.js */ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Hash/Hash.js");
/* harmony import */ var _Toolbar_Toolbar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Toolbar/Toolbar.js */ "./node_modules/@fancyapps/ui/src/Fancybox/plugins/Toolbar/Toolbar.js");







const Plugins = {
  ScrollLock: _ScrollLock_ScrollLock_js__WEBPACK_IMPORTED_MODULE_0__.ScrollLock,
  Thumbs: _Thumbs_Thumbs_js__WEBPACK_IMPORTED_MODULE_1__.Thumbs,
  Html: _Html_Html_js__WEBPACK_IMPORTED_MODULE_2__.Html,
  Toolbar: _Toolbar_Toolbar_js__WEBPACK_IMPORTED_MODULE_5__.Toolbar,
  Image: _Image_Image_js__WEBPACK_IMPORTED_MODULE_3__.Image,
  Hash: _Hash_Hash_js__WEBPACK_IMPORTED_MODULE_4__.Hash,
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Panzoom/Panzoom.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Panzoom: () => (/* binding */ Panzoom)
/* harmony export */ });
/* harmony import */ var _shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/utils/extend.js */ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js");
/* harmony import */ var _shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/utils/round.js */ "./node_modules/@fancyapps/ui/src/shared/utils/round.js");
/* harmony import */ var _shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shared/utils/isScrollable.js */ "./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js");
/* harmony import */ var _shared_utils_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shared/utils/ResizeObserver.js */ "./node_modules/@fancyapps/ui/src/shared/utils/ResizeObserver.js");
/* harmony import */ var _shared_utils_PointerTracker_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shared/utils/PointerTracker.js */ "./node_modules/@fancyapps/ui/src/shared/utils/PointerTracker.js");
/* harmony import */ var _shared_utils_getTextNodeFromPoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shared/utils/getTextNodeFromPoint.js */ "./node_modules/@fancyapps/ui/src/shared/utils/getTextNodeFromPoint.js");
/* harmony import */ var _shared_utils_getDimensions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shared/utils/getDimensions.js */ "./node_modules/@fancyapps/ui/src/shared/utils/getDimensions.js");
/* harmony import */ var _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shared/Base/Base.js */ "./node_modules/@fancyapps/ui/src/shared/Base/Base.js");
/* harmony import */ var _plugins_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./plugins/index.js */ "./node_modules/@fancyapps/ui/src/Panzoom/plugins/index.js");















const defaults = {
  // Enable touch guestures
  touch: true,

  // Enable zooming
  zoom: true,

  // Enable pinch gesture to zoom in/out using two fingers
  pinchToZoom: true,

  // Disable dragging if scale level is equal to value of `baseScale` option
  panOnlyZoomed: false,

  // Lock axis while dragging,
  // possible values: false | "x" | "y" | "xy"
  lockAxis: false,

  // * All friction values are inside [0, 1) interval,
  // * where 0 would change instantly, but 0.99 would update extremely slowly

  // Friction while panning/dragging
  friction: 0.64,

  // Friction while decelerating after drag end
  decelFriction: 0.88,

  // Friction while scaling
  zoomFriction: 0.74,

  // Bounciness after hitting the edge
  bounceForce: 0.2,

  // Initial scale level
  baseScale: 1,

  // Minimum scale level
  minScale: 1,

  // Maximum scale level
  maxScale: 2,

  // Default scale step while zooming
  step: 0.5,

  // Allow to select text,
  // if enabled, dragging will be disabled when text selection is detected
  textSelection: false,

  // Add `click` event listener,
  // possible values: true | false | function | "toggleZoom"
  click: "toggleZoom",

  // Add `wheel` event listener,
  // possible values: true | false | function |  "zoom"
  wheel: "zoom",

  // Value for zoom on mouse wheel
  wheelFactor: 42,

  // Number of wheel events after which it should stop preventing default behaviour of mouse wheel
  wheelLimit: 5,

  // Class name added to `$viewport` element to indicate if content is draggable
  draggableClass: "is-draggable",

  // Class name added to `$viewport` element to indicate that user is currently dragging
  draggingClass: "is-dragging",

  // Content will be scaled by this number,
  // this can also be a function which should return a number, for example:
  // ratio: function() { return 1 / (window.devicePixelRatio || 1) }
  ratio: 1,
};

class Panzoom extends _shared_Base_Base_js__WEBPACK_IMPORTED_MODULE_7__.Base {
  /**
   * Panzoom constructor
   * @constructs Panzoom
   * @param {HTMLElement} $viewport Panzoom container
   * @param {Object} [options] Options for Panzoom
   */
  constructor($container, options = {}) {
    super((0,_shared_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)(true, {}, defaults, options));

    this.state = "init";

    this.$container = $container;

    // Bind event handlers for referencability
    for (const methodName of ["onLoad", "onWheel", "onClick"]) {
      this[methodName] = this[methodName].bind(this);
    }

    this.initLayout();

    this.resetValues();

    this.attachPlugins(Panzoom.Plugins);

    this.trigger("init");

    this.updateMetrics();

    this.attachEvents();

    this.trigger("ready");

    if (this.option("centerOnStart") === false) {
      this.state = "ready";
    } else {
      this.panTo({
        friction: 0,
      });
    }

    $container.__Panzoom = this;
  }

  /**
   * Create references to container, viewport and content elements
   */
  initLayout() {
    const $container = this.$container;

    // Make sure content element exists
    if (!($container instanceof HTMLElement)) {
      throw new Error("Panzoom: Container not found");
    }

    const $content = this.option("content") || $container.querySelector(".panzoom__content");

    // Make sure content element exists
    if (!$content) {
      throw new Error("Panzoom: Content not found");
    }

    this.$content = $content;

    let $viewport = this.option("viewport") || $container.querySelector(".panzoom__viewport");

    if (!$viewport && this.option("wrapInner") !== false) {
      $viewport = document.createElement("div");
      $viewport.classList.add("panzoom__viewport");

      $viewport.append(...$container.childNodes);

      $container.appendChild($viewport);
    }

    this.$viewport = $viewport || $content.parentNode;
  }

  /**
   * Restore instance variables to default values
   */
  resetValues() {
    this.updateRate = this.option("updateRate", /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ? 250 : 24);

    this.container = {
      width: 0,
      height: 0,
    };

    this.viewport = {
      width: 0,
      height: 0,
    };

    this.content = {
      // Full content dimensions (naturalWidth/naturalHeight for images)
      origWidth: 0,
      origHeight: 0,

      // Current dimensions of the content
      width: 0,
      height: 0,

      // Current position; these values reflect CSS `transform` value
      x: this.option("x", 0),
      y: this.option("y", 0),

      // Current scale; does not reflect CSS `transform` value
      scale: this.option("baseScale"),
    };

    // End values of current pan / zoom animation
    this.transform = {
      x: 0,
      y: 0,
      scale: 1,
    };

    this.resetDragPosition();
  }

  /**
   * Handle `load` event
   * @param {Event} event
   */
  onLoad(event) {
    this.updateMetrics();

    this.panTo({ scale: this.option("baseScale"), friction: 0 });

    this.trigger("load", event);
  }

  /**
   * Handle `click` event
   * @param {Event} event
   */
  onClick(event) {
    if (event.defaultPrevented) {
      return;
    }

    if (document.activeElement && document.activeElement.closest("[contenteditable]")) {
      return;
    }

    // Skip if text is selected
    if (
      this.option("textSelection") &&
      window.getSelection().toString().length &&
      !(event.target && event.target.hasAttribute("data-fancybox-close"))
    ) {
      event.stopPropagation();
      return;
    }

    const rect = this.$content.getClientRects()[0];

    // Check if container has changed position (for example, when current instance is inside another one)
    if (this.state !== "ready") {
      if (
        this.dragPosition.midPoint ||
        Math.abs(rect.top - this.dragStart.rect.top) > 1 ||
        Math.abs(rect.left - this.dragStart.rect.left) > 1
      ) {
        event.preventDefault();
        event.stopPropagation();

        return;
      }
    }

    if (this.trigger("click", event) === false) {
      return;
    }

    if (this.option("zoom") && this.option("click") === "toggleZoom") {
      event.preventDefault();
      event.stopPropagation();

      this.zoomWithClick(event);
    }
  }

  /**
   * Handle `wheel` event
   * @param {Event} event
   */
  onWheel(event) {
    if (this.trigger("wheel", event) === false) {
      return;
    }

    if (this.option("zoom") && this.option("wheel")) {
      this.zoomWithWheel(event);
    }
  }

  /**
   * Change zoom level depending on scroll direction
   * @param {Event} event `wheel` event
   */
  zoomWithWheel(event) {
    if (this.changedDelta === undefined) {
      this.changedDelta = 0;
    }

    const delta = Math.max(-1, Math.min(1, -event.deltaY || -event.deltaX || event.wheelDelta || -event.detail));
    const scale = this.content.scale;

    let newScale = (scale * (100 + delta * this.option("wheelFactor"))) / 100;

    if (
      (delta < 0 && Math.abs(scale - this.option("minScale")) < 0.01) ||
      (delta > 0 && Math.abs(scale - this.option("maxScale")) < 0.01)
    ) {
      this.changedDelta += Math.abs(delta);
      newScale = scale;
    } else {
      this.changedDelta = 0;
      newScale = Math.max(Math.min(newScale, this.option("maxScale")), this.option("minScale"));
    }

    if (this.changedDelta > this.option("wheelLimit")) {
      return;
    }

    event.preventDefault();

    if (newScale === scale) {
      return;
    }

    const rect = this.$content.getBoundingClientRect();

    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    this.zoomTo(newScale, { x, y });
  }

  /**
   * Change zoom level depending on click coordinates
   * @param {Event} event `click` event
   */
  zoomWithClick(event) {
    const rect = this.$content.getClientRects()[0];

    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    this.toggleZoom({ x, y });
  }

  /**
   * Attach load, wheel and click event listeners, initialize `resizeObserver` and `PointerTracker`
   */
  attachEvents() {
    this.$content.addEventListener("load", this.onLoad);

    this.$container.addEventListener("wheel", this.onWheel, { passive: false });
    this.$container.addEventListener("click", this.onClick, { passive: false });

    this.initObserver();

    const pointerTracker = new _shared_utils_PointerTracker_js__WEBPACK_IMPORTED_MODULE_4__.PointerTracker(this.$container, {
      start: (pointer, event) => {
        if (!this.option("touch")) {
          return false;
        }

        if (this.velocity.scale < 0) {
          return false;
        }

        const target = event.composedPath()[0];

        if (!pointerTracker.currentPointers.length) {
          const ignoreClickedElement =
            ["BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO"].indexOf(target.nodeName) !== -1;

          if (ignoreClickedElement) {
            return false;
          }

          // Allow text selection
          if (this.option("textSelection") && (0,_shared_utils_getTextNodeFromPoint_js__WEBPACK_IMPORTED_MODULE_5__.getTextNodeFromPoint)(target, pointer.clientX, pointer.clientY)) {
            return false;
          }
        }

        if ((0,_shared_utils_isScrollable_js__WEBPACK_IMPORTED_MODULE_2__.isScrollable)(target)) {
          return false;
        }

        if (this.trigger("touchStart", event) === false) {
          return false;
        }

        if (event.type === "mousedown") {
          event.preventDefault();
        }

        this.state = "pointerdown";

        this.resetDragPosition();

        this.dragPosition.midPoint = null;
        this.dragPosition.time = Date.now();

        return true;
      },
      move: (previousPointers, currentPointers, event) => {
        if (this.state !== "pointerdown") {
          return;
        }

        if (this.trigger("touchMove", event) === false) {
          event.preventDefault();
          return;
        }

        // Disable touch action if current zoom level is below base level
        if (
          currentPointers.length < 2 &&
          this.option("panOnlyZoomed") === true &&
          this.content.width <= this.viewport.width &&
          this.content.height <= this.viewport.height &&
          this.transform.scale <= this.option("baseScale")
        ) {
          return;
        }

        if (currentPointers.length > 1 && (!this.option("zoom") || this.option("pinchToZoom") === false)) {
          return;
        }

        const prevMidpoint = (0,_shared_utils_PointerTracker_js__WEBPACK_IMPORTED_MODULE_4__.getMidpoint)(previousPointers[0], previousPointers[1]);
        const newMidpoint = (0,_shared_utils_PointerTracker_js__WEBPACK_IMPORTED_MODULE_4__.getMidpoint)(currentPointers[0], currentPointers[1]);

        const panX = newMidpoint.clientX - prevMidpoint.clientX;
        const panY = newMidpoint.clientY - prevMidpoint.clientY;

        const prevDistance = (0,_shared_utils_PointerTracker_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(previousPointers[0], previousPointers[1]);
        const newDistance = (0,_shared_utils_PointerTracker_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(currentPointers[0], currentPointers[1]);

        const scaleDiff = prevDistance && newDistance ? newDistance / prevDistance : 1;

        this.dragOffset.x += panX;
        this.dragOffset.y += panY;

        this.dragOffset.scale *= scaleDiff;

        this.dragOffset.time = Date.now() - this.dragPosition.time;

        const axisToLock = this.dragStart.scale === 1 && this.option("lockAxis");

        if (axisToLock && !this.lockAxis) {
          if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) {
            event.preventDefault();
            return;
          }

          const angle = Math.abs((Math.atan2(this.dragOffset.y, this.dragOffset.x) * 180) / Math.PI);

          this.lockAxis = angle > 45 && angle < 135 ? "y" : "x";
        }

        if (axisToLock !== "xy" && this.lockAxis === "y") {
          return;
        }

        event.preventDefault();
        event.stopPropagation();

        event.stopImmediatePropagation();

        if (this.lockAxis) {
          this.dragOffset[this.lockAxis === "x" ? "y" : "x"] = 0;
        }

        this.$container.classList.add(this.option("draggingClass"));

        if (!(this.transform.scale === this.option("baseScale") && this.lockAxis === "y")) {
          this.dragPosition.x = this.dragStart.x + this.dragOffset.x;
        }

        if (!(this.transform.scale === this.option("baseScale") && this.lockAxis === "x")) {
          this.dragPosition.y = this.dragStart.y + this.dragOffset.y;
        }

        this.dragPosition.scale = this.dragStart.scale * this.dragOffset.scale;

        if (currentPointers.length > 1) {
          const startPoint = (0,_shared_utils_PointerTracker_js__WEBPACK_IMPORTED_MODULE_4__.getMidpoint)(pointerTracker.startPointers[0], pointerTracker.startPointers[1]);

          const xPos = startPoint.clientX - this.dragStart.rect.x;
          const yPos = startPoint.clientY - this.dragStart.rect.y;

          const { deltaX, deltaY } = this.getZoomDelta(this.content.scale * this.dragOffset.scale, xPos, yPos);

          this.dragPosition.x -= deltaX;
          this.dragPosition.y -= deltaY;

          this.dragPosition.midPoint = newMidpoint;
        } else {
          this.setDragResistance();
        }

        // Update final position
        this.transform = {
          x: this.dragPosition.x,
          y: this.dragPosition.y,
          scale: this.dragPosition.scale,
        };

        this.startAnimation();
      },
      end: (pointer, event) => {
        if (this.state !== "pointerdown") {
          return;
        }

        this._dragOffset = { ...this.dragOffset };

        if (pointerTracker.currentPointers.length) {
          this.resetDragPosition();

          return;
        }

        this.state = "decel";
        this.friction = this.option("decelFriction");

        this.recalculateTransform();

        this.$container.classList.remove(this.option("draggingClass"));

        if (this.trigger("touchEnd", event) === false) {
          return;
        }

        if (this.state !== "decel") {
          return;
        }

        // * Check if scaled content past limits

        // Below minimum
        const minScale = this.option("minScale");

        if (this.transform.scale < minScale) {
          this.zoomTo(minScale, { friction: 0.64 });

          return;
        }

        // Exceed maximum
        const maxScale = this.option("maxScale");

        if (this.transform.scale - maxScale > 0.01) {
          const last = this.dragPosition.midPoint || pointer;
          const rect = this.$content.getClientRects()[0];

          this.zoomTo(maxScale, {
            friction: 0.64,
            x: last.clientX - rect.left,
            y: last.clientY - rect.top,
          });

          return;
        }
      },
    });

    this.pointerTracker = pointerTracker;
  }

  initObserver() {
    if (this.resizeObserver) {
      return;
    }

    this.resizeObserver = new _shared_utils_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_3__.ResizeObserver(() => {
      if (this.updateTimer) {
        return;
      }

      this.updateTimer = setTimeout(() => {
        const rect = this.$container.getBoundingClientRect();

        if (!(rect.width && rect.height)) {
          this.updateTimer = null;
          return;
        }

        // Check to see if there are any changes
        if (Math.abs(rect.width - this.container.width) > 1 || Math.abs(rect.height - this.container.height) > 1) {
          if (this.isAnimating()) {
            this.endAnimation(true);
          }

          this.updateMetrics();

          this.panTo({
            x: this.content.x,
            y: this.content.y,
            scale: this.option("baseScale"),
            friction: 0,
          });
        }

        this.updateTimer = null;
      }, this.updateRate);
    });

    this.resizeObserver.observe(this.$container);
  }

  /**
   * Restore drag related variables to default values
   */
  resetDragPosition() {
    this.lockAxis = null;
    this.friction = this.option("friction");

    this.velocity = {
      x: 0,
      y: 0,
      scale: 0,
    };

    const { x, y, scale } = this.content;

    this.dragStart = {
      rect: this.$content.getBoundingClientRect(),
      x,
      y,
      scale,
    };

    this.dragPosition = {
      ...this.dragPosition,
      x,
      y,
      scale,
    };

    this.dragOffset = {
      x: 0,
      y: 0,
      scale: 1,
      time: 0,
    };
  }

  /**
   * Trigger update events before/after resizing content and viewport
   * @param {Boolean} silently Should trigger `afterUpdate` event at the end
   */
  updateMetrics(silently) {
    if (silently !== true) {
      this.trigger("beforeUpdate");
    }

    const $container = this.$container;
    const $content = this.$content;
    const $viewport = this.$viewport;

    const contentIsImage = $content instanceof HTMLImageElement;
    const contentIsZoomable = this.option("zoom");
    const shouldResizeParent = this.option("resizeParent", contentIsZoomable);

    let width = this.option("width");
    let height = this.option("height");

    let origWidth = width || (0,_shared_utils_getDimensions_js__WEBPACK_IMPORTED_MODULE_6__.getFullWidth)($content);
    let origHeight = height || (0,_shared_utils_getDimensions_js__WEBPACK_IMPORTED_MODULE_6__.getFullHeight)($content);

    Object.assign($content.style, {
      width: width ? `${width}px` : "",
      height: height ? `${height}px` : "",
      maxWidth: "",
      maxHeight: "",
    });

    if (shouldResizeParent) {
      Object.assign($viewport.style, { width: "", height: "" });
    }

    const ratio = this.option("ratio");

    origWidth = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(origWidth * ratio);
    origHeight = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(origHeight * ratio);

    width = origWidth;
    height = origHeight;

    const contentRect = $content.getBoundingClientRect();
    const viewportRect = $viewport.getBoundingClientRect();

    const containerRect = $viewport == $container ? viewportRect : $container.getBoundingClientRect();

    let viewportWidth = Math.max($viewport.offsetWidth, (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(viewportRect.width));
    let viewportHeight = Math.max($viewport.offsetHeight, (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(viewportRect.height));

    let viewportStyles = window.getComputedStyle($viewport);
    viewportWidth -= parseFloat(viewportStyles.paddingLeft) + parseFloat(viewportStyles.paddingRight);
    viewportHeight -= parseFloat(viewportStyles.paddingTop) + parseFloat(viewportStyles.paddingBottom);

    this.viewport.width = viewportWidth;
    this.viewport.height = viewportHeight;

    if (contentIsZoomable) {
      if (Math.abs(origWidth - contentRect.width) > 0.1 || Math.abs(origHeight - contentRect.height) > 0.1) {
        const rez = (0,_shared_utils_getDimensions_js__WEBPACK_IMPORTED_MODULE_6__.calculateAspectRatioFit)(
          origWidth,
          origHeight,
          Math.min(origWidth, contentRect.width),
          Math.min(origHeight, contentRect.height)
        );

        width = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(rez.width);
        height = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(rez.height);
      }

      Object.assign($content.style, {
        width: `${width}px`,
        height: `${height}px`,
        transform: "",
      });
    }

    if (shouldResizeParent) {
      Object.assign($viewport.style, { width: `${width}px`, height: `${height}px` });

      this.viewport = { ...this.viewport, width, height };
    }

    if (contentIsImage && contentIsZoomable && typeof this.options.maxScale !== "function") {
      const maxScale = this.option("maxScale");

      this.options.maxScale = function () {
        return this.content.origWidth > 0 && this.content.fitWidth > 0
          ? this.content.origWidth / this.content.fitWidth
          : maxScale;
      };
    }

    this.content = {
      ...this.content,
      origWidth,
      origHeight,
      fitWidth: width,
      fitHeight: height,
      width,
      height,
      scale: 1,
      isZoomable: contentIsZoomable,
    };

    this.container = { width: containerRect.width, height: containerRect.height };

    if (silently !== true) {
      this.trigger("afterUpdate");
    }
  }

  /**
   * Increase zoom level
   * @param {Number} [step] Zoom ratio; `0.5` would increase scale from 1 to 1.5
   */
  zoomIn(step) {
    this.zoomTo(this.content.scale + (step || this.option("step")));
  }

  /**
   * Decrease zoom level
   * @param {Number} [step] Zoom ratio; `0.5` would decrease scale from 1.5 to 1
   */
  zoomOut(step) {
    this.zoomTo(this.content.scale - (step || this.option("step")));
  }

  /**
   * Toggles zoom level between max and base levels
   * @param {Object} [options] Additional options
   */
  toggleZoom(props = {}) {
    const maxScale = this.option("maxScale");
    const baseScale = this.option("baseScale");

    const scale = this.content.scale > baseScale + (maxScale - baseScale) * 0.5 ? baseScale : maxScale;

    this.zoomTo(scale, props);
  }

  /**
   * Animate to given zoom level
   * @param {Number} scale New zoom level
   * @param {Object} [options] Additional options
   */
  zoomTo(scale = this.option("baseScale"), { x = null, y = null } = {}) {
    scale = Math.max(Math.min(scale, this.option("maxScale")), this.option("minScale"));

    // Adjust zoom position
    const currentScale = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.content.scale / (this.content.width / this.content.fitWidth), 10000000);

    if (x === null) {
      x = this.content.width * currentScale * 0.5;
    }

    if (y === null) {
      y = this.content.height * currentScale * 0.5;
    }

    const { deltaX, deltaY } = this.getZoomDelta(scale, x, y);

    x = this.content.x - deltaX;
    y = this.content.y - deltaY;

    this.panTo({ x, y, scale, friction: this.option("zoomFriction") });
  }

  /**
   * Calculate difference for top/left values if content would scale at given coordinates
   * @param {Number} scale
   * @param {Number} x
   * @param {Number} y
   * @returns {Object}
   */
  getZoomDelta(scale, x = 0, y = 0) {
    const currentWidth = this.content.fitWidth * this.content.scale;
    const currentHeight = this.content.fitHeight * this.content.scale;

    const percentXInCurrentBox = x > 0 && currentWidth ? x / currentWidth : 0;
    const percentYInCurrentBox = y > 0 && currentHeight ? y / currentHeight : 0;

    const nextWidth = this.content.fitWidth * scale;
    const nextHeight = this.content.fitHeight * scale;

    const deltaX = (nextWidth - currentWidth) * percentXInCurrentBox;
    const deltaY = (nextHeight - currentHeight) * percentYInCurrentBox;

    return { deltaX, deltaY };
  }

  /**
   * Animate to given positon and/or zoom level
   * @param {Object} [options] Additional options
   */
  panTo({
    x = this.content.x,
    y = this.content.y,
    scale,
    friction = this.option("friction"),
    ignoreBounds = false,
  } = {}) {
    scale = scale || this.content.scale || 1;

    if (!ignoreBounds) {
      const { boundX, boundY } = this.getBounds(scale);

      if (boundX) {
        x = Math.max(Math.min(x, boundX.to), boundX.from);
      }

      if (boundY) {
        y = Math.max(Math.min(y, boundY.to), boundY.from);
      }
    }

    this.friction = friction;

    this.transform = {
      ...this.transform,
      x,
      y,
      scale,
    };

    if (friction) {
      this.state = "panning";

      this.velocity = {
        x: (1 / this.friction - 1) * (x - this.content.x),
        y: (1 / this.friction - 1) * (y - this.content.y),
        scale: (1 / this.friction - 1) * (scale - this.content.scale),
      };

      this.startAnimation();
    } else {
      this.endAnimation();
    }
  }

  /**
   * Start animation loop
   */
  startAnimation() {
    if (!this.rAF) {
      this.trigger("startAnimation");
    } else {
      cancelAnimationFrame(this.rAF);
    }

    this.rAF = requestAnimationFrame(() => this.animate());
  }

  /**
   * Process animation frame
   */
  animate() {
    this.setEdgeForce();
    this.setDragForce();

    this.velocity.x *= this.friction;
    this.velocity.y *= this.friction;

    this.velocity.scale *= this.friction;

    this.content.x += this.velocity.x;
    this.content.y += this.velocity.y;

    this.content.scale += this.velocity.scale;

    if (this.isAnimating()) {
      this.setTransform();
    } else if (this.state !== "pointerdown") {
      this.endAnimation();

      return;
    }

    this.rAF = requestAnimationFrame(() => this.animate());
  }

  /**
   * Calculate boundaries
   */
  getBounds(scale) {
    let boundX = this.boundX;
    let boundY = this.boundY;

    if (boundX !== undefined && boundY !== undefined) {
      return { boundX, boundY };
    }

    boundX = { from: 0, to: 0 };
    boundY = { from: 0, to: 0 };

    scale = scale || this.transform.scale;

    const width = this.content.fitWidth * scale;
    const height = this.content.fitHeight * scale;

    const viewportWidth = this.viewport.width;
    const viewportHeight = this.viewport.height;

    if (width < viewportWidth) {
      const deltaX = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)((viewportWidth - width) * 0.5);

      boundX.from = deltaX;
      boundX.to = deltaX;
    } else {
      boundX.from = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(viewportWidth - width);
    }

    if (height < viewportHeight) {
      const deltaY = (viewportHeight - height) * 0.5;

      boundY.from = deltaY;
      boundY.to = deltaY;
    } else {
      boundY.from = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(viewportHeight - height);
    }

    return { boundX, boundY };
  }

  /**
   * Change animation velocity if boundary is reached
   */
  setEdgeForce() {
    if (this.state !== "decel") {
      return;
    }

    const bounceForce = this.option("bounceForce");

    const { boundX, boundY } = this.getBounds(Math.max(this.transform.scale, this.content.scale));

    let pastLeft, pastRight, pastTop, pastBottom;

    if (boundX) {
      pastLeft = this.content.x < boundX.from;
      pastRight = this.content.x > boundX.to;
    }

    if (boundY) {
      pastTop = this.content.y < boundY.from;
      pastBottom = this.content.y > boundY.to;
    }

    if (pastLeft || pastRight) {
      const bound = pastLeft ? boundX.from : boundX.to;
      const distance = bound - this.content.x;

      let force = distance * bounceForce;

      const restX = this.content.x + (this.velocity.x + force) / this.friction;

      if (restX >= boundX.from && restX <= boundX.to) {
        force += this.velocity.x;
      }

      this.velocity.x = force;

      this.recalculateTransform();
    }

    if (pastTop || pastBottom) {
      const bound = pastTop ? boundY.from : boundY.to;
      const distance = bound - this.content.y;

      let force = distance * bounceForce;

      const restY = this.content.y + (force + this.velocity.y) / this.friction;

      if (restY >= boundY.from && restY <= boundY.to) {
        force += this.velocity.y;
      }

      this.velocity.y = force;

      this.recalculateTransform();
    }
  }

  /**
   * Change dragging position if boundary is reached
   */
  setDragResistance() {
    if (this.state !== "pointerdown") {
      return;
    }

    const { boundX, boundY } = this.getBounds(this.dragPosition.scale);

    let pastLeft, pastRight, pastTop, pastBottom;

    if (boundX) {
      pastLeft = this.dragPosition.x < boundX.from;
      pastRight = this.dragPosition.x > boundX.to;
    }

    if (boundY) {
      pastTop = this.dragPosition.y < boundY.from;
      pastBottom = this.dragPosition.y > boundY.to;
    }

    if ((pastLeft || pastRight) && !(pastLeft && pastRight)) {
      const bound = pastLeft ? boundX.from : boundX.to;
      const distance = bound - this.dragPosition.x;

      this.dragPosition.x = bound - distance * 0.3;
    }

    if ((pastTop || pastBottom) && !(pastTop && pastBottom)) {
      const bound = pastTop ? boundY.from : boundY.to;
      const distance = bound - this.dragPosition.y;

      this.dragPosition.y = bound - distance * 0.3;
    }
  }

  /**
   * Set velocity to move content to drag position
   */
  setDragForce() {
    if (this.state === "pointerdown") {
      this.velocity.x = this.dragPosition.x - this.content.x;
      this.velocity.y = this.dragPosition.y - this.content.y;
      this.velocity.scale = this.dragPosition.scale - this.content.scale;
    }
  }

  /**
   * Update end values based on current velocity and friction;
   */
  recalculateTransform() {
    this.transform.x = this.content.x + this.velocity.x / (1 / this.friction - 1);
    this.transform.y = this.content.y + this.velocity.y / (1 / this.friction - 1);
    this.transform.scale = this.content.scale + this.velocity.scale / (1 / this.friction - 1);
  }

  /**
   * Check if content is currently animating
   * @returns {Boolean}
   */
  isAnimating() {
    return !!(
      this.friction &&
      (Math.abs(this.velocity.x) > 0.05 || Math.abs(this.velocity.y) > 0.05 || Math.abs(this.velocity.scale) > 0.05)
    );
  }

  /**
   * Set content `style.transform` value based on current animation frame
   */
  setTransform(final) {
    let x, y, scale;

    if (final) {
      x = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.transform.x);
      y = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.transform.y);

      scale = this.transform.scale;

      this.content = { ...this.content, x, y, scale };
    } else {
      x = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.content.x);
      y = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.content.y);

      scale = this.content.scale / (this.content.width / this.content.fitWidth);

      this.content = { ...this.content, x, y };
    }

    this.trigger("beforeTransform");

    x = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.content.x);
    y = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.content.y);

    if (final && this.option("zoom")) {
      let width;
      let height;

      width = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.content.fitWidth * scale);
      height = (0,_shared_utils_round_js__WEBPACK_IMPORTED_MODULE_1__.round)(this.content.fitHeight * scale);

      this.content.width = width;
      this.content.height = height;

      this.transform = { ...this.transform, width, height, scale };

      Object.assign(this.$content.style, {
        width: `${width}px`,
        height: `${height}px`,
        maxWidth: "none",
        maxHeight: "none",
        transform: `translate3d(${x}px, ${y}px, 0) scale(1)`,
      });
    } else {
      this.$content.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${scale})`;
    }

    this.trigger("afterTransform");
  }

  /**
   * Stop animation loop
   */
  endAnimation(silently) {
    cancelAnimationFrame(this.rAF);
    this.rAF = null;

    this.velocity = {
      x: 0,
      y: 0,
      scale: 0,
    };

    this.setTransform(true);

    this.state = "ready";

    this.handleCursor();

    if (silently !== true) {
      this.trigger("endAnimation");
    }
  }

  /**
   * Update the class name depending on whether the content is scaled
   */
  handleCursor() {
    const draggableClass = this.option("draggableClass");

    if (!draggableClass || !this.option("touch")) {
      return;
    }

    if (
      this.option("panOnlyZoomed") == true &&
      this.content.width <= this.viewport.width &&
      this.content.height <= this.viewport.height &&
      this.transform.scale <= this.option("baseScale")
    ) {
      this.$container.classList.remove(draggableClass);
    } else {
      this.$container.classList.add(draggableClass);
    }
  }

  /**
   * Remove observation and detach event listeners
   */
  detachEvents() {
    this.$content.removeEventListener("load", this.onLoad);

    this.$container.removeEventListener("wheel", this.onWheel, { passive: false });
    this.$container.removeEventListener("click", this.onClick, { passive: false });

    if (this.pointerTracker) {
      this.pointerTracker.stop();
      this.pointerTracker = null;
    }

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }

  /**
   * Clean up
   */
  destroy() {
    if (this.state === "destroy") {
      return;
    }

    this.state = "destroy";

    clearTimeout(this.updateTimer);
    this.updateTimer = null;

    cancelAnimationFrame(this.rAF);
    this.rAF = null;

    this.detachEvents();

    this.detachPlugins();

    this.resetDragPosition();
  }
}

// Expose version
Panzoom.version = "__VERSION__";

// Static properties are a recent addition that dont work in all browsers yet
Panzoom.Plugins = _plugins_index_js__WEBPACK_IMPORTED_MODULE_8__.Plugins;


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/Panzoom/plugins/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/Panzoom/plugins/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Plugins: () => (/* binding */ Plugins)
/* harmony export */ });
const Plugins = {};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/Base/Base.js":
/*!************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/Base/Base.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Base: () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _utils_extend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/extend.js */ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js");
/* harmony import */ var _utils_resolve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/resolve.js */ "./node_modules/@fancyapps/ui/src/shared/utils/resolve.js");
/* harmony import */ var _utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/isPlainObject.js */ "./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js");




/**
 * Base class, all components inherit from this class
 */
class Base {
  /**
   * Base constructor
   * @param {Object} [options] - Options as `key: value` pairs
   */
  constructor(options = {}) {
    this.options = (0,_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)(true, {}, options);

    this.plugins = [];
    this.events = {};

    // * Prefill with initial events
    for (const type of ["on", "once"]) {
      for (const args of Object.entries(this.options[type] || {})) {
        this[type](...args);
      }
    }
  }

  /**
   * Retrieve option value by key, supports subkeys
   * @param {String} key Option name
   * @param {*} [fallback] Fallback value for non-existing key
   * @returns {*}
   */
  option(key, fallback, ...rest) {
    // Make sure it is string
    key = String(key);

    let value = (0,_utils_resolve_js__WEBPACK_IMPORTED_MODULE_1__.resolve)(key, this.options);

    // Allow to have functions as options
    if (typeof value === "function") {
      value = value.call(this, this, ...rest);
    }

    return value === undefined ? fallback : value;
  }

  /**
   * Simple l10n support - replaces object keys
   * found in template with corresponding values
   * @param {String} str String containing values to localize
   * @param {Array} params Substitute parameters
   * @returns {String}
   */
  localize(str, params = []) {
    str = String(str).replace(/\{\{(\w+).?(\w+)?\}\}/g, (match, key, subkey) => {
      let rez = "";

      // Plugins have `Plugin.l10n.KEY`
      if (subkey) {
        rez = this.option(`${key[0] + key.toLowerCase().substring(1)}.l10n.${subkey}`);
      } else if (key) {
        rez = this.option(`l10n.${key}`);
      }

      if (!rez) {
        rez = match;
      }

      for (let index = 0; index < params.length; index++) {
        rez = rez.split(params[index][0]).join(params[index][1]);
      }

      return rez;
    });

    str = str.replace(/\{\{(.*)\}\}/, (match, key) => {
      return key;
    });

    return str;
  }

  /**
   * Subscribe to an event
   * @param {String} name
   * @param {Function} callback
   * @returns {Object}
   */
  on(name, callback) {
    if ((0,_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(name)) {
      for (const args of Object.entries(name)) {
        this.on(...args);
      }

      return this;
    }

    String(name)
      .split(" ")
      .forEach((item) => {
        const listeners = (this.events[item] = this.events[item] || []);

        if (listeners.indexOf(callback) == -1) {
          listeners.push(callback);
        }
      });

    return this;
  }

  /**
   * Subscribe to an event only once
   * @param {String} name
   * @param {Function} callback
   * @returns {Object}
   */
  once(name, callback) {
    if ((0,_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(name)) {
      for (const args of Object.entries(name)) {
        this.once(...args);
      }

      return this;
    }

    String(name)
      .split(" ")
      .forEach((item) => {
        const listener = (...details) => {
          this.off(item, listener);
          callback.call(this, this, ...details);
        };

        listener._ = callback;

        this.on(item, listener);
      });

    return this;
  }

  /**
   * Unsubscribe event with name and callback
   * @param {String} name
   * @param {Function} callback
   * @returns {Object}
   */
  off(name, callback) {
    if ((0,_utils_isPlainObject_js__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(name)) {
      for (const args of Object.entries(name)) {
        this.off(...args);
      }

      return;
    }

    name.split(" ").forEach((item) => {
      const listeners = this.events[item];

      if (!listeners || !listeners.length) {
        return this;
      }

      let index = -1;

      for (let i = 0, len = listeners.length; i < len; i++) {
        const listener = listeners[i];

        if (listener && (listener === callback || listener._ === callback)) {
          index = i;
          break;
        }
      }

      if (index != -1) {
        listeners.splice(index, 1);
      }
    });

    return this;
  }

  /**
   * Emit an event.
   * If present, `"*"` handlers are invoked after name-matched handlers.
   * @param {String} name
   * @param  {...any} details
   * @returns {Boolean}
   */
  trigger(name, ...details) {
    for (const listener of [...(this.events[name] || [])].slice()) {
      if (listener && listener.call(this, this, ...details) === false) {
        return false;
      }
    }

    // A wildcard "*" event type
    for (const listener of [...(this.events["*"] || [])].slice()) {
      if (listener && listener.call(this, name, this, ...details) === false) {
        return false;
      }
    }

    return true;
  }

  /**
   * Add given plugins to this instance,
   * this will end up calling `attach` method of each plugin
   * @param {Object} Plugins
   * @returns {Object}
   */
  attachPlugins(plugins) {
    const newPlugins = {};

    for (const [key, Plugin] of Object.entries(plugins || {})) {
      // Check if this plugin is not disabled by option
      if (this.options[key] !== false && !this.plugins[key]) {
        // Populate options with defaults from the plugin
        this.options[key] = (0,_utils_extend_js__WEBPACK_IMPORTED_MODULE_0__.extend)({}, Plugin.defaults || {}, this.options[key]);

        // Initialise plugin
        newPlugins[key] = new Plugin(this);
      }
    }

    for (const [key, plugin] of Object.entries(newPlugins)) {
      plugin.attach(this);
    }

    this.plugins = Object.assign({}, this.plugins, newPlugins);

    return this;
  }

  /**
   * Remove all plugin instances from this instance,
   * this will end up calling `detach` method of each plugin
   * @returns {Object}
   */
  detachPlugins() {
    for (const key in this.plugins) {
      let plugin;

      if ((plugin = this.plugins[key]) && typeof plugin.detach === "function") {
        plugin.detach(this);
      }
    }

    this.plugins = {};

    return this;
  }
}


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/Fullscreen.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/Fullscreen.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fullscreen: () => (/* binding */ Fullscreen)
/* harmony export */ });
const Fullscreen = {
  pageXOffset: 0,
  pageYOffset: 0,

  element() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
  },

  activate(element) {
    Fullscreen.pageXOffset = window.pageXOffset;
    Fullscreen.pageYOffset = window.pageYOffset;

    if (element.requestFullscreen) {
      element.requestFullscreen(); // W3C spec
    } else if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen(); // Firefox
    } else if (element.webkitRequestFullscreen) {
      element.webkitRequestFullscreen(); // Safari
    } else if (element.msRequestFullscreen) {
      element.msRequestFullscreen(); // IE/Edge
    }
  },

  deactivate() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  },
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/PointerTracker.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/PointerTracker.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PointerTracker: () => (/* binding */ PointerTracker),
/* harmony export */   getDistance: () => (/* binding */ getDistance),
/* harmony export */   getMidpoint: () => (/* binding */ getMidpoint)
/* harmony export */ });
class Pointer {
  constructor(nativePointer) {
    this.id = self.Touch && nativePointer instanceof Touch ? nativePointer.identifier : -1;

    this.pageX = nativePointer.pageX;
    this.pageY = nativePointer.pageY;

    this.clientX = nativePointer.clientX;
    this.clientY = nativePointer.clientY;
  }
}

const getDistance = (a, b) => {
  if (!b) {
    return 0;
  }

  return Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);
};

const getMidpoint = (a, b) => {
  if (!b) {
    return a;
  }

  return {
    clientX: (a.clientX + b.clientX) / 2,
    clientY: (a.clientY + b.clientY) / 2,
  };
};

const isTouchEvent = (event) => "changedTouches" in event;

class PointerTracker {
  constructor(_element, { start = () => true, move = () => {}, end = () => {} } = {}) {
    this._element = _element;

    this.startPointers = [];
    this.currentPointers = [];

    this._pointerStart = (event) => {
      if (event.buttons > 0 && event.button !== 0) {
        return;
      }

      const pointer = new Pointer(event);

      if (this.currentPointers.some((p) => p.id === pointer.id)) {
        return;
      }

      if (!this._triggerPointerStart(pointer, event)) {
        return;
      }

      window.addEventListener("mousemove", this._move);
      window.addEventListener("mouseup", this._pointerEnd);
    };

    this._touchStart = (event) => {
      for (const touch of Array.from(event.changedTouches || [])) {
        this._triggerPointerStart(new Pointer(touch), event);
      }
    };

    this._move = (event) => {
      const previousPointers = this.currentPointers.slice();
      const changedPointers = isTouchEvent(event)
        ? Array.from(event.changedTouches).map((t) => new Pointer(t))
        : [new Pointer(event)];

      const trackedChangedPointers = [];

      for (const pointer of changedPointers) {
        const index = this.currentPointers.findIndex((p) => p.id === pointer.id);

        if (index < 0) {
          continue;
        }

        trackedChangedPointers.push(pointer);

        this.currentPointers[index] = pointer;
      }

      this._moveCallback(previousPointers, this.currentPointers.slice(), event);
    };

    this._triggerPointerEnd = (pointer, event) => {
      const index = this.currentPointers.findIndex((p) => p.id === pointer.id);

      if (index < 0) {
        return false;
      }

      this.currentPointers.splice(index, 1);
      this.startPointers.splice(index, 1);

      this._endCallback(pointer, event);

      return true;
    };

    this._pointerEnd = (event) => {
      if (event.buttons > 0 && event.button !== 0) {
        return;
      }

      if (!this._triggerPointerEnd(new Pointer(event), event)) {
        return;
      }

      window.removeEventListener("mousemove", this._move, { passive: false });
      window.removeEventListener("mouseup", this._pointerEnd, { passive: false });
    };

    this._touchEnd = (event) => {
      for (const touch of Array.from(event.changedTouches || [])) {
        this._triggerPointerEnd(new Pointer(touch), event);
      }
    };

    this._startCallback = start;
    this._moveCallback = move;
    this._endCallback = end;

    this._element.addEventListener("mousedown", this._pointerStart, { passive: false });
    this._element.addEventListener("touchstart", this._touchStart, { passive: false });
    this._element.addEventListener("touchmove", this._move, { passive: false });
    this._element.addEventListener("touchend", this._touchEnd);
    this._element.addEventListener("touchcancel", this._touchEnd);
  }

  stop() {
    this._element.removeEventListener("mousedown", this._pointerStart, { passive: false });
    this._element.removeEventListener("touchstart", this._touchStart, { passive: false });
    this._element.removeEventListener("touchmove", this._move, { passive: false });
    this._element.removeEventListener("touchend", this._touchEnd);
    this._element.removeEventListener("touchcancel", this._touchEnd);

    window.removeEventListener("mousemove", this._move);
    window.removeEventListener("mouseup", this._pointerEnd);
  }

  _triggerPointerStart(pointer, event) {
    if (!this._startCallback(pointer, event)) {
      return false;
    }

    this.currentPointers.push(pointer);
    this.startPointers.push(pointer);

    return true;
  }
}




/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/ResizeObserver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/ResizeObserver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResizeObserver: () => (/* binding */ ResizeObserver)
/* harmony export */ });
/**
 * ResizeObserver Polyfill
 */
const ResizeObserver =
  (typeof window !== "undefined" && window.ResizeObserver) ||
  class {
    constructor(callback) {
      this.observables = [];
      // Array of observed elements that looks like this:
      // [{
      //   el: domNode,
      //   size: {height: x, width: y}
      // }]
      this.boundCheck = this.check.bind(this);
      this.boundCheck();
      this.callback = callback;
    }

    observe(el) {
      if (this.observables.some((observable) => observable.el === el)) {
        return;
      }

      const newObservable = {
        el: el,
        size: {
          height: el.clientHeight,
          width: el.clientWidth,
        },
      };

      this.observables.push(newObservable);
    }

    unobserve(el) {
      this.observables = this.observables.filter((obj) => obj.el !== el);
    }

    disconnect() {
      this.observables = [];
    }

    check() {
      const changedEntries = this.observables
        .filter((obj) => {
          const currentHeight = obj.el.clientHeight;
          const currentWidth = obj.el.clientWidth;
          if (obj.size.height !== currentHeight || obj.size.width !== currentWidth) {
            obj.size.height = currentHeight;
            obj.size.width = currentWidth;
            return true;
          }
        })
        .map((obj) => obj.el);

      if (changedEntries.length > 0) {
        this.callback(changedEntries);
      }

      window.requestAnimationFrame(this.boundCheck);
    }
  };


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/Slideshow.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/Slideshow.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Slideshow: () => (/* binding */ Slideshow)
/* harmony export */ });
class Slideshow {
  constructor(fancybox) {
    this.fancybox = fancybox;
    this.active = false;

    this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
  }

  isActive() {
    return this.active;
  }

  setTimer() {
    if (!this.active || this.timer) {
      return;
    }

    const delay = this.fancybox.option("slideshow.delay", 3000);

    this.timer = setTimeout(() => {
      this.timer = null;

      if (
        !this.fancybox.option("infinite") &&
        this.fancybox.getSlide().index === this.fancybox.Carousel.slides.length - 1
      ) {
        this.fancybox.jumpTo(0, { friction: 0 });
      } else {
        this.fancybox.next();
      }
    }, delay);

    let $progress = this.$progress;

    if (!$progress) {
      $progress = document.createElement("div");
      $progress.classList.add("fancybox__progress");

      this.fancybox.$carousel.parentNode.insertBefore($progress, this.fancybox.$carousel);

      this.$progress = $progress;

      $progress.offsetHeight; /* trigger reflow */
    }

    $progress.style.transitionDuration = `${delay}ms`;
    $progress.style.transform = "scaleX(1)";
  }

  clearTimer() {
    clearTimeout(this.timer);
    this.timer = null;

    if (this.$progress) {
      this.$progress.style.transitionDuration = "";
      this.$progress.style.transform = "";

      this.$progress.offsetHeight; /* trigger reflow */
    }
  }

  activate() {
    if (this.active) {
      return;
    }

    this.active = true;
    this.fancybox.$container.classList.add("has-slideshow");

    if (this.fancybox.getSlide().state === "done") {
      this.setTimer();
    }

    document.addEventListener("visibilitychange", this.handleVisibilityChange, false);
  }

  handleVisibilityChange() {
    this.deactivate();
  }

  deactivate() {
    this.active = false;

    this.clearTimer();

    this.fancybox.$container.classList.remove("has-slideshow");

    document.removeEventListener("visibilitychange", this.handleVisibilityChange, false);
  }

  toggle() {
    if (this.active) {
      this.deactivate();
    } else if (this.fancybox.Carousel.slides.length > 1) {
      this.activate();
    }
  }
}


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js":
/*!******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canUseDOM: () => (/* binding */ canUseDOM)
/* harmony export */ });
/**
 * Detect if rendering from the client or the server
 */
const canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/extend.js":
/*!***************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/extend.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   extend: () => (/* binding */ extend)
/* harmony export */ });
/* harmony import */ var _isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isPlainObject.js */ "./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js");


/**
 * Merge the contents of two or more objects together into the first object.
 * If passing "true" for first argument, the merge becomes recursive (aka. deep copy).
 * @param  {...any} args
 * @returns {Object}
 */
const extend = (...args) => {
  let deep = false;

  if (typeof args[0] == "boolean") {
    deep = args.shift();
  }

  let result = args[0];

  if (!result || typeof result !== "object") {
    throw new Error("extendee must be an object");
  }

  const extenders = args.slice(1);
  const len = extenders.length;

  for (let i = 0; i < len; i++) {
    const extender = extenders[i];

    for (let key in extender) {
      if (extender.hasOwnProperty(key)) {
        const value = extender[key];

        if (deep && (Array.isArray(value) || (0,_isPlainObject_js__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value))) {
          const base = Array.isArray(value) ? [] : {};

          result[key] = extend(true, result.hasOwnProperty(key) ? result[key] : base, value);
        } else {
          result[key] = value;
        }
      }
    }
  }

  return result;
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/getDimensions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/getDimensions.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculateAspectRatioFit: () => (/* binding */ calculateAspectRatioFit),
/* harmony export */   getFullHeight: () => (/* binding */ getFullHeight),
/* harmony export */   getFullWidth: () => (/* binding */ getFullWidth)
/* harmony export */ });
/**
 * Get actual width of the element, regardless of how much of content is currently visible
 * @param {Element} elem
 * @returns {Integer}
 */
const getFullWidth = (elem) => {
  return Math.max(
    parseFloat(elem.naturalWidth || 0),
    parseFloat((elem.width && elem.width.baseVal && elem.width.baseVal.value) || 0),
    parseFloat(elem.offsetWidth || 0),
    parseFloat(elem.scrollWidth || 0)
  );
};

/**
 * Get actual height of the element, regardless of how much of content is currently visible
 * @param {Element} elem
 * @returns {Integer}
 */
const getFullHeight = (elem) => {
  return Math.max(
    parseFloat(elem.naturalHeight || 0),
    parseFloat((elem.height && elem.height.baseVal && elem.height.baseVal.value) || 0),
    parseFloat(elem.offsetHeight || 0),
    parseFloat(elem.scrollHeight || 0)
  );
};

/**
 * Calculate bounding size to fit dimensions while preserving aspect ratio
 * @param {Number} srcWidth
 * @param {Number} srcHeight
 * @param {Number} maxWidth
 * @param {Number} maxHeight
 * @returns {Object}
 */
const calculateAspectRatioFit = (srcWidth, srcHeight, maxWidth, maxHeight) => {
  const ratio = Math.min(maxWidth / srcWidth || 0, maxHeight / srcHeight);

  return { width: srcWidth * ratio || 0, height: srcHeight * ratio || 0 };
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/getTextNodeFromPoint.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/getTextNodeFromPoint.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getTextNodeFromPoint: () => (/* binding */ getTextNodeFromPoint)
/* harmony export */ });
/**
 * Get element child node at the given coordinates
 * @param {Element} HTML element
 * @param {Float|Integer} x
 * @param {Float|Integer} y
 * @returns {Node|Boolean}}
 */
const getTextNodeFromPoint = (element, x, y) => {
  const nodes = element.childNodes;
  const range = document.createRange();

  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];

    if (node.nodeType !== Node.TEXT_NODE) {
      continue;
    }

    range.selectNodeContents(node);

    const rect = range.getBoundingClientRect();

    if (x >= rect.left && y >= rect.top && x <= rect.right && y <= rect.bottom) {
      return node;
    }
  }

  return false;
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/isPlainObject.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject)
/* harmony export */ });
/**
 * Check to see if an object is a plain object (created using "{}" or "new Object").
 * @param {*} obj Variable of any type
 * @returns {Boolean}
 */
const isPlainObject = (obj) => {
  return (
    // separate from primitives
    typeof obj === "object" &&
    // is obvious
    obj !== null &&
    // separate instances (Array, DOM, ...)
    obj.constructor === Object &&
    // separate build-in like Math
    Object.prototype.toString.call(obj) === "[object Object]"
  );
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/isScrollable.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasScrollbars: () => (/* binding */ hasScrollbars),
/* harmony export */   isScrollable: () => (/* binding */ isScrollable)
/* harmony export */ });
/**
 * Check if  element has scrollable content
 * @param {Node} node
 * @returns {Boolean}
 */
const hasScrollbars = function (node) {
  const overflowY = getComputedStyle(node)["overflow-y"],
    overflowX = getComputedStyle(node)["overflow-x"],
    vertical = (overflowY === "scroll" || overflowY === "auto") && Math.abs(node.scrollHeight - node.clientHeight) > 1,
    horizontal = (overflowX === "scroll" || overflowX === "auto") && Math.abs(node.scrollWidth - node.clientWidth) > 1;

  return vertical || horizontal;
};

/**
 * Check if element or one of the parents is scrollable
 * @param {Node} node  DOM Node element
 * @returns {Boolean}
 */
const isScrollable = function (node) {
  if (!node || !(typeof node === "object" && node instanceof Element) || node === document.body) {
    return false;
  }

  if (node.__Panzoom) {
    return false;
  }

  if (hasScrollbars(node)) {
    return node;
  }

  return isScrollable(node.parentNode);
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/resolve.js":
/*!****************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/resolve.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolve: () => (/* binding */ resolve)
/* harmony export */ });
/**
 * Access nested JavaScript objects by string path.
 * Example: `resolve("a.b.c", {a:{b:{c:"d"}})` would return `d`
 * @param {String} path
 * @param {Object} obj
 * @returns {*}
 */
const resolve = function (path, obj) {
  return path.split(".").reduce(function (prev, curr) {
    return prev && prev[curr];
  }, obj);
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/round.js":
/*!**************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/round.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   round: () => (/* binding */ round)
/* harmony export */ });
/**
 * Round half up; to be more specific and to ensure things like 1.005 round correctly
 * @param {Float} value
 * @param {Integer} precision
 * @returns {Float}
 */
const round = (value, precision = 10000) => {
  value = parseFloat(value) || 0;

  return Math.round((value + Number.EPSILON) * precision) / precision;
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/setFocusOn.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/setFocusOn.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FOCUSABLE_ELEMENTS: () => (/* binding */ FOCUSABLE_ELEMENTS),
/* harmony export */   setFocusOn: () => (/* binding */ setFocusOn)
/* harmony export */ });
/* harmony import */ var _canUseDOM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canUseDOM.js */ "./node_modules/@fancyapps/ui/src/shared/utils/canUseDOM.js");


let preventScrollSupported = null;

const FOCUSABLE_ELEMENTS = [
  "a[href]",
  "area[href]",
  'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
  "select:not([disabled]):not([aria-hidden])",
  "textarea:not([disabled]):not([aria-hidden])",
  "button:not([disabled]):not([aria-hidden])",
  "iframe",
  "object",
  "embed",
  "video",
  "audio",
  "[contenteditable]",
  '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])',
];

const setFocusOn = (node) => {
  if (!node || !_canUseDOM_js__WEBPACK_IMPORTED_MODULE_0__.canUseDOM) {
    return;
  }

  if (preventScrollSupported === null) {
    document.createElement("div").focus({
      get preventScroll() {
        preventScrollSupported = true;

        return false;
      },
    });
  }

  try {
    if (node.setActive) {
      // IE/Edge
      node.setActive();
    } else if (preventScrollSupported) {
      // Modern browsers
      node.focus({ preventScroll: true });
    } else {
      // Safari does not support `preventScroll` option
      // https://bugs.webkit.org/show_bug.cgi?id=178583

      // Save position
      const scrollTop = window.pageXOffset || document.body.scrollTop;
      const scrollLeft = window.pageYOffset || document.body.scrollLeft;

      node.focus();

      document.body.scrollTo({
        top: scrollTop,
        left: scrollLeft,
        behavior: "auto",
      });
    }
  } catch (e) {}
};


/***/ }),

/***/ "./node_modules/@fancyapps/ui/src/shared/utils/throttle.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@fancyapps/ui/src/shared/utils/throttle.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   throttle: () => (/* binding */ throttle)
/* harmony export */ });
/**
 * Throttling enforces a maximum number of times a function can be called over time
 * @param {Function} func Callback function
 * @param {Integer} limit Milliseconds
 * @returns {Function}
 */
const throttle = (func, limit) => {
  let lastCall = 0;

  return function (...args) {
    const now = new Date().getTime();

    if (now - lastCall < limit) {
      return;
    }

    lastCall = now;

    return func(...args);
  };
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhlbWUtYnVuZGxlLmNodW5rLnZlbmRvcnMtbm9kZV9tb2R1bGVzX2ZhbmN5YXBwc191aV9zcmNfRmFuY3lib3hfRmFuY3lib3hfanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDRTtBQUNoRDtBQUNtRDtBQUNGO0FBQ007QUFDdkQ7QUFDNkM7QUFDN0M7QUFDQTtBQUM4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CLEdBQUcscUJBQXFCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFFBQVEsbURBQUU7QUFDVjtBQUNBO0FBQ08sdUJBQXVCLHNEQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQSxzQ0FBc0M7QUFDdEMsY0FBYywrREFBTSxTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVE7QUFDN0IscUJBQXFCLG1FQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdUNBQXVDO0FBQ3BHO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osaURBQWlELFFBQVE7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQU87Ozs7Ozs7Ozs7Ozs7OztBQ2g3QjFCLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNKRjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU07O0FBRWpFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDbkxBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEseURBQXlELEVBQUUscUJBQXFCOztBQUVoRiwwRkFBMEYsS0FBSzs7QUFFL0Y7QUFDQTtBQUNBLDJEQUEyRCxLQUFLOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLGtDQUFrQztBQUM5RCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFKd0Q7QUFDbEI7QUFDQTs7QUFFL0Isa0JBQWtCLFVBQVUseUVBQU0sdURBQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKSTtBQUNNO0FBQ3NCOztBQUVqQzs7QUFFSzs7QUFFTjs7QUFFN0M7QUFDOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0dBQW9HLE9BQU87QUFDM0c7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLG1EQUFFO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QixzREFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLFVBQVUsK0RBQU0sU0FBUzs7QUFFekI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFRO0FBQ2hDO0FBQ0EsTUFBTSwrREFBTTtBQUNaO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQSxnRUFBZ0UsS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxRQUFRLEdBQUcsWUFBWTs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQiwyRUFBa0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELHNDQUFzQztBQUM5Rjs7QUFFQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsTUFBTTtBQUM1QjtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFFQUFxRSwyRUFBa0I7O0FBRXZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsdUVBQVU7QUFDbEIsUUFBUTtBQUNSLFFBQVEsdUVBQVU7QUFDbEI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFVBQVUsdUVBQVU7QUFDcEIsVUFBVTtBQUNWLFVBQVUsdUVBQVU7QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUVBQVM7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCLGVBQWUsSUFBSTs7QUFFekY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsUUFBUTtBQUNyQjtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsbUJBQW1COztBQUVqRDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHVDQUF1Qzs7QUFFckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsaUNBQWlDO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87O0FBRTFELGtDQUFrQyxpQkFBaUI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsTUFBTSx1RUFBVTtBQUNoQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlDQUF5QztBQUNqRSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLCtEQUFNLEdBQUc7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRSxVQUFVOztBQUU5RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrREFBTSxHQUFHO0FBQ2Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGlFQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNEQUFPOztBQUUxQjtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVvQjs7Ozs7Ozs7Ozs7Ozs7O0FDNWxEcEIsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQjZEOztBQUV4RDtBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxvQkFBb0I7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELEtBQUs7O0FBRWxFO0FBQ0EsNERBQTRELGlDQUFpQztBQUM3Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRSxLQUFLOztBQUV6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsNERBQTRELGlDQUFpQztBQUM3RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsaUVBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzNQeUQ7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsV0FBVztBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1R0FBdUcsUUFBUTtBQUMvRyxpQkFBaUIsS0FBSyxVQUFVLFFBQVE7QUFDeEM7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsd0J5RDtBQUN6RDtBQUNzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGdCQUFnQjtBQUNqRyxzRkFBc0YsZ0JBQWdCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBTztBQUMvQjtBQUNBLE1BQU0sK0RBQU0sK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDRCQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZFQUFhO0FBQ3ZCO0FBQ0EsZUFBZSwrREFBTSxHQUFHO0FBQ3hCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGVBQWU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjs7Ozs7Ozs7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9DYXJvdXNlbC9DYXJvdXNlbC5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL0Nhcm91c2VsL2wxMG4vZW4uanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9DYXJvdXNlbC9wbHVnaW5zL0RvdHMvRG90cy5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL0Nhcm91c2VsL3BsdWdpbnMvTmF2aWdhdGlvbi9OYXZpZ2F0aW9uLmpzIiwid2VicGFjazovL2JpZ2NvbW1lcmNlLWhlcmEvLi9ub2RlX21vZHVsZXMvQGZhbmN5YXBwcy91aS9zcmMvQ2Fyb3VzZWwvcGx1Z2lucy9TeW5jL1N5bmMuanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9DYXJvdXNlbC9wbHVnaW5zL2luZGV4LmpzIiwid2VicGFjazovL2JpZ2NvbW1lcmNlLWhlcmEvLi9ub2RlX21vZHVsZXMvQGZhbmN5YXBwcy91aS9zcmMvRmFuY3lib3gvRmFuY3lib3guanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9GYW5jeWJveC9sMTBuL2VuLmpzIiwid2VicGFjazovL2JpZ2NvbW1lcmNlLWhlcmEvLi9ub2RlX21vZHVsZXMvQGZhbmN5YXBwcy91aS9zcmMvRmFuY3lib3gvcGx1Z2lucy9IYXNoL0hhc2guanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9GYW5jeWJveC9wbHVnaW5zL0h0bWwvSHRtbC5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL0ZhbmN5Ym94L3BsdWdpbnMvSW1hZ2UvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9GYW5jeWJveC9wbHVnaW5zL1Njcm9sbExvY2svU2Nyb2xsTG9jay5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL0ZhbmN5Ym94L3BsdWdpbnMvVGh1bWJzL1RodW1icy5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL0ZhbmN5Ym94L3BsdWdpbnMvVG9vbGJhci9Ub29sYmFyLmpzIiwid2VicGFjazovL2JpZ2NvbW1lcmNlLWhlcmEvLi9ub2RlX21vZHVsZXMvQGZhbmN5YXBwcy91aS9zcmMvRmFuY3lib3gvcGx1Z2lucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL1Bhbnpvb20vUGFuem9vbS5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL1Bhbnpvb20vcGx1Z2lucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL3NoYXJlZC9CYXNlL0Jhc2UuanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9zaGFyZWQvdXRpbHMvRnVsbHNjcmVlbi5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL3NoYXJlZC91dGlscy9Qb2ludGVyVHJhY2tlci5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL3NoYXJlZC91dGlscy9SZXNpemVPYnNlcnZlci5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL3NoYXJlZC91dGlscy9TbGlkZXNob3cuanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9zaGFyZWQvdXRpbHMvY2FuVXNlRE9NLmpzIiwid2VicGFjazovL2JpZ2NvbW1lcmNlLWhlcmEvLi9ub2RlX21vZHVsZXMvQGZhbmN5YXBwcy91aS9zcmMvc2hhcmVkL3V0aWxzL2V4dGVuZC5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL3NoYXJlZC91dGlscy9nZXREaW1lbnNpb25zLmpzIiwid2VicGFjazovL2JpZ2NvbW1lcmNlLWhlcmEvLi9ub2RlX21vZHVsZXMvQGZhbmN5YXBwcy91aS9zcmMvc2hhcmVkL3V0aWxzL2dldFRleHROb2RlRnJvbVBvaW50LmpzIiwid2VicGFjazovL2JpZ2NvbW1lcmNlLWhlcmEvLi9ub2RlX21vZHVsZXMvQGZhbmN5YXBwcy91aS9zcmMvc2hhcmVkL3V0aWxzL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9zaGFyZWQvdXRpbHMvaXNTY3JvbGxhYmxlLmpzIiwid2VicGFjazovL2JpZ2NvbW1lcmNlLWhlcmEvLi9ub2RlX21vZHVsZXMvQGZhbmN5YXBwcy91aS9zcmMvc2hhcmVkL3V0aWxzL3Jlc29sdmUuanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9zaGFyZWQvdXRpbHMvcm91bmQuanMiLCJ3ZWJwYWNrOi8vYmlnY29tbWVyY2UtaGVyYS8uL25vZGVfbW9kdWxlcy9AZmFuY3lhcHBzL3VpL3NyYy9zaGFyZWQvdXRpbHMvc2V0Rm9jdXNPbi5qcyIsIndlYnBhY2s6Ly9iaWdjb21tZXJjZS1oZXJhLy4vbm9kZV9tb2R1bGVzL0BmYW5jeWFwcHMvdWkvc3JjL3NoYXJlZC91dGlscy90aHJvdHRsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlIH0gZnJvbSBcIi4uL3NoYXJlZC9CYXNlL0Jhc2UuanNcIjtcclxuaW1wb3J0IHsgUGFuem9vbSB9IGZyb20gXCIuLi9QYW56b29tL1Bhbnpvb20uanNcIjtcclxuXHJcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gXCIuLi9zaGFyZWQvdXRpbHMvZXh0ZW5kLmpzXCI7XHJcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3NoYXJlZC91dGlscy9yb3VuZC5qc1wiO1xyXG5pbXBvcnQgeyB0aHJvdHRsZSB9IGZyb20gXCIuLi9zaGFyZWQvdXRpbHMvdGhyb3R0bGUuanNcIjtcclxuXHJcbmltcG9ydCB7IFBsdWdpbnMgfSBmcm9tIFwiLi9wbHVnaW5zL2luZGV4LmpzXCI7XHJcblxyXG4vLyBEZWZhdWx0IGxhbmd1YWdlXHJcbmltcG9ydCBlbiBmcm9tIFwiLi9sMTBuL2VuLmpzXCI7XHJcblxyXG5jb25zdCBkZWZhdWx0cyA9IHtcclxuICAvLyBWaXJ0dWFsIHNsaWRlcy4gRWFjaCBvYmplY3Qgc2hvdWxkIGhhdmUgYXQgbGVhc3QgYGh0bWxgIHByb3BlcnR5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHNldCBjb250ZW50LFxyXG4gIC8vIGV4YW1wbGU6IGBzbGlkZXM6IFt7aHRtbDogJ0ZpcnN0IHNsaWRlJ30sIHtodG1sOiAnU2Vjb25kIHNsaWRlJ31dYFxyXG4gIHNsaWRlczogW10sXHJcblxyXG4gIC8vIE51bWJlciBvZiBzbGlkZXMgdG8gcHJlbG9hZCBiZWZvcmUvYWZ0ZXIgdmlzaWJsZSBzbGlkZXNcclxuICBwcmVsb2FkOiAwLFxyXG5cclxuICAvLyBOdW1iZXIgb2Ygc2xpZGVzIHRvIGdyb3VwIGludG8gdGhlIHBhZ2UsXHJcbiAgLy8gaWYgYGF1dG9gIC0gZ3JvdXAgYWxsIHNsaWRlcyB0aGF0IGZpdCBpbnRvIHRoZSB2aWV3cG9ydFxyXG4gIHNsaWRlc1BlclBhZ2U6IFwiYXV0b1wiLFxyXG5cclxuICAvLyBJbmRleCBvZiBpbml0aWFsIHBhZ2VcclxuICBpbml0aWFsUGFnZTogbnVsbCxcclxuXHJcbiAgLy8gSW5kZXggb2YgaW5pdGlhbCBzbGlkZVxyXG4gIGluaXRpYWxTbGlkZTogbnVsbCxcclxuXHJcbiAgLy8gUGFuem9vbSBmcmljdGlvbiB3aGlsZSBjaGFuZ2luZyBwYWdlXHJcbiAgZnJpY3Rpb246IDAuOTIsXHJcblxyXG4gIC8vIFNob3VsZCBjZW50ZXIgYWN0aXZlIHBhZ2VcclxuICBjZW50ZXI6IHRydWUsXHJcblxyXG4gIC8vIFNob3VsZCBjYXJvdXNlbCBzY3JvbGwgaW5maW5pdGVseVxyXG4gIGluZmluaXRlOiB0cnVlLFxyXG5cclxuICAvLyBTaG91bGQgdGhlIGdhcCBiZSBmaWxsZWQgYmVmb3JlIGZpcnN0IGFuZCBhZnRlciBsYXN0IHNsaWRlIGlmIGBpbmZpbml0ZTogZmFsc2VgXHJcbiAgZmlsbDogdHJ1ZSxcclxuXHJcbiAgLy8gU2hvdWxkIENhcm91c2VsIHNldHRsZSBhdCBhbnkgcG9zaXRpb24gYWZ0ZXIgYSBzd2lwZS5cclxuICBkcmFnRnJlZTogZmFsc2UsXHJcblxyXG4gIC8vIFByZWZpeCBmb3IgQ1NTIGNsYXNzZXMsIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlICBTQ1NTIGAkY2Fyb3VzZWwtcHJlZml4YCB2YXJpYWJsZVxyXG4gIHByZWZpeDogXCJcIixcclxuXHJcbiAgLy8gQ2xhc3MgbmFtZXMgZm9yIERPTSBlbGVtZW50cyAod2l0aG91dCBwcmVmaXgpXHJcbiAgY2xhc3NOYW1lczoge1xyXG4gICAgdmlld3BvcnQ6IFwiY2Fyb3VzZWxfX3ZpZXdwb3J0XCIsXHJcbiAgICB0cmFjazogXCJjYXJvdXNlbF9fdHJhY2tcIixcclxuICAgIHNsaWRlOiBcImNhcm91c2VsX19zbGlkZVwiLFxyXG5cclxuICAgIC8vIENsYXNzbmFtZSB0b2dnbGVkIGZvciBzbGlkZXMgaW5zaWRlIGN1cnJlbnQgcGFnZVxyXG4gICAgc2xpZGVTZWxlY3RlZDogXCJpcy1zZWxlY3RlZFwiLFxyXG4gIH0sXHJcblxyXG4gIC8vIExvY2FsaXphdGlvbiBvZiBzdHJpbmdzXHJcbiAgbDEwbjogZW4sXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBCYXNlIHtcclxuICAvKipcclxuICAgKiBDYXJvdXNlbCBjb25zdHJ1Y3RvclxyXG4gICAqIEBjb25zdHJ1Y3RzIENhcm91c2VsXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGNvbnRhaW5lciAtIENhcm91c2VsIGNvbnRhaW5lclxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciBDYXJvdXNlbFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKCRjb250YWluZXIsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgb3B0aW9ucyA9IGV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cclxuICAgIHN1cGVyKG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBcImluaXRcIjtcclxuXHJcbiAgICB0aGlzLiRjb250YWluZXIgPSAkY29udGFpbmVyO1xyXG5cclxuICAgIGlmICghKHRoaXMuJGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByb290IGVsZW1lbnQgcHJvdmlkZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zbGlkZU5leHQgPSB0aHJvdHRsZSh0aGlzLnNsaWRlTmV4dC5iaW5kKHRoaXMpLCAyNTAsIHRydWUpO1xyXG4gICAgdGhpcy5zbGlkZVByZXYgPSB0aHJvdHRsZSh0aGlzLnNsaWRlUHJldi5iaW5kKHRoaXMpLCAyNTAsIHRydWUpO1xyXG5cclxuICAgIHRoaXMuaW5pdCgpO1xyXG5cclxuICAgICRjb250YWluZXIuX19DYXJvdXNlbCA9IHRoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtIGluaXRpYWxpemF0aW9uXHJcbiAgICovXHJcbiAgaW5pdCgpIHtcclxuICAgIHRoaXMucGFnZXMgPSBbXTtcclxuICAgIHRoaXMucGFnZSA9IHRoaXMucGFnZUluZGV4ID0gbnVsbDtcclxuICAgIHRoaXMucHJldlBhZ2UgPSB0aGlzLnByZXZQYWdlSW5kZXggPSBudWxsO1xyXG5cclxuICAgIHRoaXMuYXR0YWNoUGx1Z2lucyhDYXJvdXNlbC5QbHVnaW5zKTtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIoXCJpbml0XCIpO1xyXG5cclxuICAgIHRoaXMuaW5pdExheW91dCgpO1xyXG5cclxuICAgIHRoaXMuaW5pdFNsaWRlcygpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlTWV0cmljcygpO1xyXG5cclxuICAgIGlmICh0aGlzLiR0cmFjayAmJiB0aGlzLnBhZ2VzLmxlbmd0aCkge1xyXG4gICAgICB0aGlzLiR0cmFjay5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0aGlzLnBhZ2VzW3RoaXMucGFnZV0ubGVmdCAqIC0xfXB4LCAwcHgsIDApIHNjYWxlKDEpYDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1hbmFnZVNsaWRlVmlzaWJsaXR5KCk7XHJcblxyXG4gICAgdGhpcy5pbml0UGFuem9vbSgpO1xyXG5cclxuICAgIHRoaXMuc3RhdGUgPSBcInJlYWR5XCI7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKFwicmVhZHlcIik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGxheW91dDsgY3JlYXRlIG5lY2Vzc2FyeSBlbGVtZW50c1xyXG4gICAqL1xyXG4gIGluaXRMYXlvdXQoKSB7XHJcbiAgICBjb25zdCBwcmVmaXggPSB0aGlzLm9wdGlvbihcInByZWZpeFwiKTtcclxuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB0aGlzLm9wdGlvbihcImNsYXNzTmFtZXNcIik7XHJcblxyXG4gICAgdGhpcy4kdmlld3BvcnQgPSB0aGlzLm9wdGlvbihcInZpZXdwb3J0XCIpIHx8IHRoaXMuJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAuJHtwcmVmaXh9JHtjbGFzc05hbWVzLnZpZXdwb3J0fWApO1xyXG5cclxuICAgIGlmICghdGhpcy4kdmlld3BvcnQpIHtcclxuICAgICAgdGhpcy4kdmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICB0aGlzLiR2aWV3cG9ydC5jbGFzc0xpc3QuYWRkKC4uLihwcmVmaXggKyBjbGFzc05hbWVzLnZpZXdwb3J0KS5zcGxpdChcIiBcIikpO1xyXG5cclxuICAgICAgdGhpcy4kdmlld3BvcnQuYXBwZW5kKC4uLnRoaXMuJGNvbnRhaW5lci5jaGlsZE5vZGVzKTtcclxuXHJcbiAgICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiR2aWV3cG9ydCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy4kdHJhY2sgPSB0aGlzLm9wdGlvbihcInRyYWNrXCIpIHx8IHRoaXMuJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGAuJHtwcmVmaXh9JHtjbGFzc05hbWVzLnRyYWNrfWApO1xyXG5cclxuICAgIGlmICghdGhpcy4kdHJhY2spIHtcclxuICAgICAgdGhpcy4kdHJhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICB0aGlzLiR0cmFjay5jbGFzc0xpc3QuYWRkKC4uLihwcmVmaXggKyBjbGFzc05hbWVzLnRyYWNrKS5zcGxpdChcIiBcIikpO1xyXG5cclxuICAgICAgdGhpcy4kdHJhY2suYXBwZW5kKC4uLnRoaXMuJHZpZXdwb3J0LmNoaWxkTm9kZXMpO1xyXG5cclxuICAgICAgdGhpcy4kdmlld3BvcnQuYXBwZW5kQ2hpbGQodGhpcy4kdHJhY2spO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmlsbCBgc2xpZGVzYCBhcnJheSB3aXRoIG9iamVjdHMgZnJvbSBleGlzdGluZyBub2RlcyBhbmQvb3IgYHNsaWRlc2Agb3B0aW9uXHJcbiAgICovXHJcbiAgaW5pdFNsaWRlcygpIHtcclxuICAgIHRoaXMuc2xpZGVzID0gW107XHJcblxyXG4gICAgLy8gR2V0IGV4aXN0aW5nIHNsaWRlcyBmcm9tIHRoZSBET01cclxuICAgIGNvbnN0IGVsZW1zID0gdGhpcy4kdmlld3BvcnQucXVlcnlTZWxlY3RvckFsbChgLiR7dGhpcy5vcHRpb24oXCJwcmVmaXhcIil9JHt0aGlzLm9wdGlvbihcImNsYXNzTmFtZXMuc2xpZGVcIil9YCk7XHJcblxyXG4gICAgZWxlbXMuZm9yRWFjaCgoZWwpID0+IHtcclxuICAgICAgY29uc3Qgc2xpZGUgPSB7XHJcbiAgICAgICAgJGVsOiBlbCxcclxuICAgICAgICBpc0RvbTogdHJ1ZSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuc2xpZGVzLnB1c2goc2xpZGUpO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKFwiY3JlYXRlU2xpZGVcIiwgc2xpZGUsIHRoaXMuc2xpZGVzLmxlbmd0aCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBBZGQgdmlydHVhbCBzbGlkZXMsIGJ1dCBkbyBub3QgY3JlYXRlIERPTSBlbGVtZW50cyB5ZXQsXHJcbiAgICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBjcmVhdGVkIGR5bmFtaWNhbGx5IGJhc2VkIG9uIGN1cnJlbnQgY2Fyb3VzZWwgcG9zaXRpb25cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9ucy5zbGlkZXMpKSB7XHJcbiAgICAgIHRoaXMuc2xpZGVzID0gZXh0ZW5kKHRydWUsIFsuLi50aGlzLnNsaWRlc10sIHRoaXMub3B0aW9ucy5zbGlkZXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRG8gYWxsIGNhbGN1bGF0aW9ucyByZWxhdGVkIHRvIHNsaWRlIHNpemUgYW5kIHBhZ2luZ1xyXG4gICAqL1xyXG4gIHVwZGF0ZU1ldHJpY3MoKSB7XHJcbiAgICAvLyBDYWxjdWxhdGUgY29udGVudCB3aWR0aCwgdmlld3BvcnQgd2lkdGhcclxuICAgIC8vID09PVxyXG4gICAgbGV0IGNvbnRlbnRXaWR0aCA9IDA7XHJcbiAgICBsZXQgaW5kZXhlcyA9IFtdO1xyXG4gICAgbGV0IGxhc3RTbGlkZVdpZHRoO1xyXG5cclxuICAgIHRoaXMuc2xpZGVzLmZvckVhY2goKHNsaWRlLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCAkZWwgPSBzbGlkZS4kZWw7XHJcbiAgICAgIGNvbnN0IHNsaWRlV2lkdGggPSBzbGlkZS5pc0RvbSB8fCAhbGFzdFNsaWRlV2lkdGggPyB0aGlzLmdldFNsaWRlTWV0cmljcygkZWwpIDogbGFzdFNsaWRlV2lkdGg7XHJcblxyXG4gICAgICBzbGlkZS5pbmRleCA9IGluZGV4O1xyXG4gICAgICBzbGlkZS53aWR0aCA9IHNsaWRlV2lkdGg7XHJcbiAgICAgIHNsaWRlLmxlZnQgPSBjb250ZW50V2lkdGg7XHJcblxyXG4gICAgICBsYXN0U2xpZGVXaWR0aCA9IHNsaWRlV2lkdGg7XHJcbiAgICAgIGNvbnRlbnRXaWR0aCArPSBzbGlkZVdpZHRoO1xyXG5cclxuICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCB2aWV3cG9ydFdpZHRoID0gTWF0aC5tYXgodGhpcy4kdHJhY2sub2Zmc2V0V2lkdGgsIHJvdW5kKHRoaXMuJHRyYWNrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSk7XHJcblxyXG4gICAgbGV0IHZpZXdwb3J0U3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiR0cmFjayk7XHJcbiAgICB2aWV3cG9ydFdpZHRoID0gdmlld3BvcnRXaWR0aCAtIChwYXJzZUZsb2F0KHZpZXdwb3J0U3R5bGVzLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQodmlld3BvcnRTdHlsZXMucGFkZGluZ1JpZ2h0KSk7XHJcblxyXG4gICAgdGhpcy5jb250ZW50V2lkdGggPSBjb250ZW50V2lkdGg7XHJcbiAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoO1xyXG5cclxuICAgIC8vIFNwbGl0IHNsaWRlcyBpbnRvIHBhZ2VzXHJcbiAgICAvLyA9PT1cclxuICAgIGNvbnN0IHBhZ2VzID0gW107XHJcbiAgICBjb25zdCBzbGlkZXNQZXJQYWdlID0gdGhpcy5vcHRpb24oXCJzbGlkZXNQZXJQYWdlXCIpO1xyXG5cclxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHNsaWRlc1BlclBhZ2UpICYmIGNvbnRlbnRXaWR0aCA+IHZpZXdwb3J0V2lkdGgpIHtcclxuICAgICAgLy8gRml4ZWQgbnVtYmVyIG9mIHNsaWRlcyBpbiB0aGUgcGFnZVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2xpZGVzLmxlbmd0aDsgaSArPSBzbGlkZXNQZXJQYWdlKSB7XHJcbiAgICAgICAgcGFnZXMucHVzaCh7XHJcbiAgICAgICAgICBpbmRleGVzOiBpbmRleGVzLnNsaWNlKGksIGkgKyBzbGlkZXNQZXJQYWdlKSxcclxuICAgICAgICAgIHNsaWRlczogdGhpcy5zbGlkZXMuc2xpY2UoaSwgaSArIHNsaWRlc1BlclBhZ2UpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTbGlkZXMgdGhhdCBmaXQgaW5zaWRlIHZpZXdwb3J0XHJcbiAgICAgIGxldCBjdXJyZW50UGFnZSA9IDA7XHJcbiAgICAgIGxldCBjdXJyZW50V2lkdGggPSAwO1xyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNsaWRlcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIGxldCBzbGlkZSA9IHRoaXMuc2xpZGVzW2ldO1xyXG5cclxuICAgICAgICAvLyBBZGQgbmV4dCBwYWdlXHJcbiAgICAgICAgaWYgKCFwYWdlcy5sZW5ndGggfHwgY3VycmVudFdpZHRoICsgc2xpZGUud2lkdGggPiB2aWV3cG9ydFdpZHRoKSB7XHJcbiAgICAgICAgICBwYWdlcy5wdXNoKHtcclxuICAgICAgICAgICAgaW5kZXhlczogW10sXHJcbiAgICAgICAgICAgIHNsaWRlczogW10sXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBjdXJyZW50UGFnZSA9IHBhZ2VzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICBjdXJyZW50V2lkdGggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VycmVudFdpZHRoICs9IHNsaWRlLndpZHRoO1xyXG5cclxuICAgICAgICBwYWdlc1tjdXJyZW50UGFnZV0uaW5kZXhlcy5wdXNoKGkpO1xyXG4gICAgICAgIHBhZ2VzW2N1cnJlbnRQYWdlXS5zbGlkZXMucHVzaChzbGlkZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzaG91bGRDZW50ZXIgPSB0aGlzLm9wdGlvbihcImNlbnRlclwiKTtcclxuICAgIGNvbnN0IHNob3VsZEZpbGwgPSB0aGlzLm9wdGlvbihcImZpbGxcIik7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHdpZHRoIGFuZCBzdGFydCBwb3NpdGlvbiBmb3IgZWFjaCBwYWdlXHJcbiAgICAvLyA9PT1cclxuICAgIHBhZ2VzLmZvckVhY2goKHBhZ2UsIGluZGV4KSA9PiB7XHJcbiAgICAgIHBhZ2UuaW5kZXggPSBpbmRleDtcclxuICAgICAgcGFnZS53aWR0aCA9IHBhZ2Uuc2xpZGVzLnJlZHVjZSgoc3VtLCBzbGlkZSkgPT4gc3VtICsgc2xpZGUud2lkdGgsIDApO1xyXG5cclxuICAgICAgcGFnZS5sZWZ0ID0gcGFnZS5zbGlkZXNbMF0ubGVmdDtcclxuXHJcbiAgICAgIGlmIChzaG91bGRDZW50ZXIpIHtcclxuICAgICAgICBwYWdlLmxlZnQgKz0gKHZpZXdwb3J0V2lkdGggLSBwYWdlLndpZHRoKSAqIDAuNSAqIC0xO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2hvdWxkRmlsbCAmJiAhdGhpcy5vcHRpb24oXCJpbmZpbml0ZVhcIiwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSkgJiYgY29udGVudFdpZHRoID4gdmlld3BvcnRXaWR0aCkge1xyXG4gICAgICAgIHBhZ2UubGVmdCA9IE1hdGgubWF4KHBhZ2UubGVmdCwgMCk7XHJcbiAgICAgICAgcGFnZS5sZWZ0ID0gTWF0aC5taW4ocGFnZS5sZWZ0LCBjb250ZW50V2lkdGggLSB2aWV3cG9ydFdpZHRoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTWVyZ2UgcGFnZXNcclxuICAgIC8vID09PVxyXG4gICAgY29uc3QgcmV6ID0gW107XHJcbiAgICBsZXQgcHJldlBhZ2U7XHJcblxyXG4gICAgcGFnZXMuZm9yRWFjaCgocGFnZTIpID0+IHtcclxuICAgICAgY29uc3QgcGFnZSA9IHsgLi4ucGFnZTIgfTtcclxuXHJcbiAgICAgIGlmIChwcmV2UGFnZSAmJiBwYWdlLmxlZnQgPT09IHByZXZQYWdlLmxlZnQpIHtcclxuICAgICAgICBwcmV2UGFnZS53aWR0aCArPSBwYWdlLndpZHRoO1xyXG5cclxuICAgICAgICBwcmV2UGFnZS5zbGlkZXMgPSBbLi4ucHJldlBhZ2Uuc2xpZGVzLCAuLi5wYWdlLnNsaWRlc107XHJcbiAgICAgICAgcHJldlBhZ2UuaW5kZXhlcyA9IFsuLi5wcmV2UGFnZS5pbmRleGVzLCAuLi5wYWdlLmluZGV4ZXNdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhZ2UuaW5kZXggPSByZXoubGVuZ3RoO1xyXG5cclxuICAgICAgICBwcmV2UGFnZSA9IHBhZ2U7XHJcblxyXG4gICAgICAgIHJlei5wdXNoKHBhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnBhZ2VzID0gcmV6O1xyXG5cclxuICAgIGxldCBwYWdlID0gdGhpcy5wYWdlO1xyXG5cclxuICAgIGlmIChwYWdlID09PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IGluaXRpYWxTbGlkZSA9IHRoaXMub3B0aW9uKFwiaW5pdGlhbFNsaWRlXCIpO1xyXG5cclxuICAgICAgaWYgKGluaXRpYWxTbGlkZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHBhZ2UgPSB0aGlzLmZpbmRQYWdlRm9yU2xpZGUoaW5pdGlhbFNsaWRlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYWdlID0gcGFyc2VJbnQodGhpcy5vcHRpb24oXCJpbml0aWFsUGFnZVwiLCAwKSwgMTApIHx8IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcmV6W3BhZ2VdKSB7XHJcbiAgICAgICAgcGFnZSA9IHJlei5sZW5ndGggJiYgcGFnZSA+IHJlei5sZW5ndGggPyByZXpbcmV6Lmxlbmd0aCAtIDFdLmluZGV4IDogMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5wYWdlID0gcGFnZTtcclxuICAgICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudXBkYXRlUGFuem9vbSgpO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihcInJlZnJlc2hcIik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgc2xpZGUgZWxlbWVudCB3aWR0aCAoaW5jbHVkaW5nIGxlZnQsIHJpZ2h0IG1hcmdpbnMpXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBXaWR0aCBpbiBweFxyXG4gICAqL1xyXG4gIGdldFNsaWRlTWV0cmljcyhub2RlKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgY29uc3QgZmlyc3RTbGlkZSA9IHRoaXMuc2xpZGVzWzBdO1xyXG5cclxuICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblxyXG4gICAgICBub2RlLmRhdGFzZXQuaXNUZXN0RWwgPSAxO1xyXG4gICAgICBub2RlLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xyXG4gICAgICBub2RlLmNsYXNzTGlzdC5hZGQoLi4uKHRoaXMub3B0aW9uKFwicHJlZml4XCIpICsgdGhpcy5vcHRpb24oXCJjbGFzc05hbWVzLnNsaWRlXCIpKS5zcGxpdChcIiBcIikpO1xyXG5cclxuICAgICAgLy8gQXNzdW1lIGFsbCBzbGlkZXMgaGF2ZSB0aGUgc2FtZSBjdXN0b20gY2xhc3MsIGlmIGFueVxyXG4gICAgICBpZiAoZmlyc3RTbGlkZS5jdXN0b21DbGFzcykge1xyXG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCguLi5maXJzdFNsaWRlLmN1c3RvbUNsYXNzLnNwbGl0KFwiIFwiKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuJHRyYWNrLnByZXBlbmQobm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHdpZHRoID0gTWF0aC5tYXgobm9kZS5vZmZzZXRXaWR0aCwgcm91bmQobm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkpO1xyXG5cclxuICAgIC8vIEFkZCBsZWZ0L3JpZ2h0IG1hcmdpblxyXG4gICAgY29uc3Qgc3R5bGUgPSBub2RlLmN1cnJlbnRTdHlsZSB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcclxuICAgIHdpZHRoID0gd2lkdGggKyAocGFyc2VGbG9hdChzdHlsZS5tYXJnaW5MZWZ0KSB8fCAwKSArIChwYXJzZUZsb2F0KHN0eWxlLm1hcmdpblJpZ2h0KSB8fCAwKTtcclxuXHJcbiAgICBpZiAobm9kZS5kYXRhc2V0LmlzVGVzdEVsKSB7XHJcbiAgICAgIG5vZGUucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IGluZGV4IEluZGV4IG9mIHRoZSBzbGlkZVxyXG4gICAqIEByZXR1cm5zIHtJbnRlZ2VyfG51bGx9IEluZGV4IG9mIHRoZSBwYWdlIGlmIGZvdW5kLCBvciBudWxsXHJcbiAgICovXHJcbiAgZmluZFBhZ2VGb3JTbGlkZShpbmRleCkge1xyXG4gICAgaW5kZXggPSBwYXJzZUludChpbmRleCwgMTApIHx8IDA7XHJcblxyXG4gICAgY29uc3QgcGFnZSA9IHRoaXMucGFnZXMuZmluZCgocGFnZSkgPT4ge1xyXG4gICAgICByZXR1cm4gcGFnZS5pbmRleGVzLmluZGV4T2YoaW5kZXgpID4gLTE7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcGFnZSA/IHBhZ2UuaW5kZXggOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2xpZGUgdG8gbmV4dCBwYWdlLCBpZiBwb3NzaWJsZVxyXG4gICAqL1xyXG4gIHNsaWRlTmV4dCgpIHtcclxuICAgIHRoaXMuc2xpZGVUbyh0aGlzLnBhZ2VJbmRleCArIDEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2xpZGUgdG8gcHJldmlvdXMgcGFnZSwgaWYgcG9zc2libGVcclxuICAgKi9cclxuICBzbGlkZVByZXYoKSB7XHJcbiAgICB0aGlzLnNsaWRlVG8odGhpcy5wYWdlSW5kZXggLSAxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNsaWRlcyBjYXJvdXNlbCB0byBnaXZlbiBwYWdlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2UgLSBOZXcgaW5kZXggb2YgYWN0aXZlIHBhZ2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBBZGRpdGlvbmFsIG9wdGlvbnNcclxuICAgKi9cclxuICBzbGlkZVRvKHBhZ2UsIHBhcmFtcyA9IHt9KSB7XHJcbiAgICBjb25zdCB7IHggPSB0aGlzLnNldFBhZ2UocGFnZSwgdHJ1ZSkgKiAtMSwgeSA9IDAsIGZyaWN0aW9uID0gdGhpcy5vcHRpb24oXCJmcmljdGlvblwiKSB9ID0gcGFyYW1zO1xyXG5cclxuICAgIGlmICh0aGlzLlBhbnpvb20uY29udGVudC54ID09PSB4ICYmICF0aGlzLlBhbnpvb20udmVsb2NpdHkueCAmJiBmcmljdGlvbikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5QYW56b29tLnBhblRvKHtcclxuICAgICAgeCxcclxuICAgICAgeSxcclxuICAgICAgZnJpY3Rpb24sXHJcbiAgICAgIGlnbm9yZUJvdW5kczogdHJ1ZSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLnN0YXRlID09PSBcInJlYWR5XCIgJiYgdGhpcy5QYW56b29tLnN0YXRlID09PSBcInJlYWR5XCIpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKFwic2V0dGxlXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGlzZSBtYWluIFBhbnpvb20gaW5zdGFuY2VcclxuICAgKi9cclxuICBpbml0UGFuem9vbSgpIHtcclxuICAgIGlmICh0aGlzLlBhbnpvb20pIHtcclxuICAgICAgdGhpcy5QYW56b29tLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgZnJlc2ggb2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgUGF6b29tIGluc3RhbmNlXHJcbiAgICBjb25zdCBvcHRpb25zID0gZXh0ZW5kKFxyXG4gICAgICB0cnVlLFxyXG4gICAgICB7fSxcclxuICAgICAge1xyXG4gICAgICAgIC8vIFRyYWNrIGVsZW1lbnQgd2lsbCBiZSBzZXQgYXMgUGFuem9vbSAkY29udGVudFxyXG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuJHRyYWNrLFxyXG4gICAgICAgIHdyYXBJbm5lcjogZmFsc2UsXHJcbiAgICAgICAgcmVzaXplUGFyZW50OiBmYWxzZSxcclxuXHJcbiAgICAgICAgLy8gRGlzYWJsZSBhbnkgdXNlciBpbnRlcmFjdGlvblxyXG4gICAgICAgIHpvb206IGZhbHNlLFxyXG4gICAgICAgIGNsaWNrOiBmYWxzZSxcclxuXHJcbiAgICAgICAgLy8gUmlnaHQgbm93LCBvbmx5IGhvcml6b250YWwgbmF2aWdhdGlvbiBpcyBzdXBwb3J0ZWRcclxuICAgICAgICBsb2NrQXhpczogXCJ4XCIsXHJcblxyXG4gICAgICAgIHg6IHRoaXMucGFnZXMubGVuZ3RoID8gdGhpcy5wYWdlc1t0aGlzLnBhZ2VdLmxlZnQgKiAtMSA6IDAsXHJcbiAgICAgICAgY2VudGVyT25TdGFydDogZmFsc2UsXHJcblxyXG4gICAgICAgIC8vIE1ha2UgYHRleHRTZWxlY3Rpb25gIG9wdGlvbiBtb3JlIGVhc3kgdG8gY3VzdG9taXplXHJcbiAgICAgICAgdGV4dFNlbGVjdGlvbjogKCkgPT4gdGhpcy5vcHRpb24oXCJ0ZXh0U2VsZWN0aW9uXCIsIGZhbHNlKSxcclxuXHJcbiAgICAgICAgLy8gRGlzYWJsZSBkcmFnZ2luZyBpZiBjb250ZW50IChlLmcuIGFsbCBzbGlkZXMpIGZpdHMgaW5zaWRlIHZpZXdwb3J0XHJcbiAgICAgICAgcGFuT25seVpvb21lZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC53aWR0aCA8PSB0aGlzLnZpZXdwb3J0LndpZHRoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHRoaXMub3B0aW9uKFwiUGFuem9vbVwiKVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgbmV3IFBhbnpvb20gaW5zdGFuY2VcclxuICAgIHRoaXMuUGFuem9vbSA9IG5ldyBQYW56b29tKHRoaXMuJGNvbnRhaW5lciwgb3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5QYW56b29tLm9uKHtcclxuICAgICAgLy8gQnViYmxlIGV2ZW50c1xyXG4gICAgICBcIipcIjogKG5hbWUsIC4uLmRldGFpbHMpID0+IHRoaXMudHJpZ2dlcihgUGFuem9vbS4ke25hbWV9YCwgLi4uZGV0YWlscyksXHJcbiAgICAgIC8vIFRoZSByZXN0IG9mIGV2ZW50cyB0byBiZSBwcm9jZXNzZWRcclxuICAgICAgYWZ0ZXJVcGRhdGU6ICgpID0+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBhZ2UoKTtcclxuICAgICAgfSxcclxuICAgICAgYmVmb3JlVHJhbnNmb3JtOiB0aGlzLm9uQmVmb3JlVHJhbnNmb3JtLmJpbmQodGhpcyksXHJcbiAgICAgIHRvdWNoRW5kOiB0aGlzLm9uVG91Y2hFbmQuYmluZCh0aGlzKSxcclxuICAgICAgZW5kQW5pbWF0aW9uOiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFwic2V0dGxlXCIpO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVGhlIGNvbnRlbnRzIG9mIHRoZSBzbGlkZXMgbWF5IGNhdXNlIHRoZSBwYWdlIHNjcm9sbCBiYXIgdG8gYXBwZWFyLCBzbyB0aGUgY2Fyb3VzZWwgd2lkdGggbWF5IGNoYW5nZVxyXG4gICAgLy8gYW5kIHNsaWRlcyBoYXZlIHRvIGJlIHJlcG9zaXRpb25lZFxyXG4gICAgdGhpcy51cGRhdGVNZXRyaWNzKCk7XHJcbiAgICB0aGlzLm1hbmFnZVNsaWRlVmlzaWJsaXR5KCk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVQYW56b29tKCkge1xyXG4gICAgaWYgKCF0aGlzLlBhbnpvb20pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuUGFuem9vbS5jb250ZW50ID0ge1xyXG4gICAgICAuLi50aGlzLlBhbnpvb20uY29udGVudCxcclxuICAgICAgZml0V2lkdGg6IHRoaXMuY29udGVudFdpZHRoLFxyXG4gICAgICBvcmlnV2lkdGg6IHRoaXMuY29udGVudFdpZHRoLFxyXG4gICAgICB3aWR0aDogdGhpcy5jb250ZW50V2lkdGgsXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA+IDEgJiYgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVhcIiwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSkpIHtcclxuICAgICAgdGhpcy5QYW56b29tLmJvdW5kWCA9IG51bGw7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFnZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuUGFuem9vbS5ib3VuZFggPSB7XHJcbiAgICAgICAgZnJvbTogdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdLmxlZnQgKiAtMSxcclxuICAgICAgICB0bzogdGhpcy5wYWdlc1swXS5sZWZ0ICogLTEsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9uKFwiaW5maW5pdGVZXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpKSB7XHJcbiAgICAgIHRoaXMuUGFuem9vbS5ib3VuZFkgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5QYW56b29tLmJvdW5kWSA9IHtcclxuICAgICAgICBmcm9tOiAwLFxyXG4gICAgICAgIHRvOiAwLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuUGFuem9vbS5oYW5kbGVDdXJzb3IoKTtcclxuICB9XHJcblxyXG4gIG1hbmFnZVNsaWRlVmlzaWJsaXR5KCkge1xyXG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5jb250ZW50V2lkdGg7XHJcbiAgICBjb25zdCB2aWV3cG9ydFdpZHRoID0gdGhpcy52aWV3cG9ydFdpZHRoO1xyXG5cclxuICAgIGxldCBjdXJyZW50WCA9IHRoaXMuUGFuem9vbSA/IHRoaXMuUGFuem9vbS5jb250ZW50LnggKiAtMSA6IHRoaXMucGFnZXMubGVuZ3RoID8gdGhpcy5wYWdlc1t0aGlzLnBhZ2VdLmxlZnQgOiAwO1xyXG5cclxuICAgIGNvbnN0IHByZWxvYWQgPSB0aGlzLm9wdGlvbihcInByZWxvYWRcIik7XHJcbiAgICBjb25zdCBpbmZpbml0ZSA9IHRoaXMub3B0aW9uKFwiaW5maW5pdGVYXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpO1xyXG5cclxuICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKHRoaXMuJHZpZXdwb3J0LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1sZWZ0XCIpKTtcclxuICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiR2aWV3cG9ydCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcInBhZGRpbmctcmlnaHRcIikpO1xyXG5cclxuICAgIC8vIENoZWNrIHZpc2liaWxpdHkgb2YgZWFjaCBzbGlkZVxyXG4gICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoc2xpZGUpID0+IHtcclxuICAgICAgbGV0IGxlZnRCb3VuZGFyeSwgcmlnaHRCb3VuZGFyeTtcclxuXHJcbiAgICAgIGxldCBoYXNEaWZmID0gMDtcclxuXHJcbiAgICAgIC8vICMxIC0gc2xpZGVzIGluIGN1cnJlbnQgdmlld3BvcnQ7IHRoaXMgZG9lcyBub3QgaW5jbHVkZSBpbmZpbml0ZSBpdGVtc1xyXG4gICAgICBsZWZ0Qm91bmRhcnkgPSBjdXJyZW50WCAtIHBhZGRpbmdMZWZ0O1xyXG4gICAgICByaWdodEJvdW5kYXJ5ID0gY3VycmVudFggKyB2aWV3cG9ydFdpZHRoICsgcGFkZGluZ1JpZ2h0O1xyXG5cclxuICAgICAgbGVmdEJvdW5kYXJ5IC09IHByZWxvYWQgKiAodmlld3BvcnRXaWR0aCArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0KTtcclxuICAgICAgcmlnaHRCb3VuZGFyeSArPSBwcmVsb2FkICogKHZpZXdwb3J0V2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCk7XHJcblxyXG4gICAgICBjb25zdCBpbnNpZGVDdXJyZW50SW50ZXJ2YWwgPSBzbGlkZS5sZWZ0ICsgc2xpZGUud2lkdGggPiBsZWZ0Qm91bmRhcnkgJiYgc2xpZGUubGVmdCA8IHJpZ2h0Qm91bmRhcnk7XHJcblxyXG4gICAgICAvLyAjMiAtIGluZmluaXRlIGl0ZW1zIGluc2lkZSBjdXJyZW50IHZpZXdwb3J0OyBmcm9tIHByZXZpb3VzIGludGVydmFsXHJcbiAgICAgIGxlZnRCb3VuZGFyeSA9IGN1cnJlbnRYICsgY29udGVudFdpZHRoIC0gcGFkZGluZ0xlZnQ7XHJcbiAgICAgIHJpZ2h0Qm91bmRhcnkgPSBjdXJyZW50WCArIGNvbnRlbnRXaWR0aCArIHZpZXdwb3J0V2lkdGggKyBwYWRkaW5nUmlnaHQ7XHJcblxyXG4gICAgICAvLyBJbmNsdWRlIHNsaWRlcyB0aGF0IGhhdmUgdG8gYmUgcHJlbG9hZGVkXHJcbiAgICAgIGxlZnRCb3VuZGFyeSAtPSBwcmVsb2FkICogKHZpZXdwb3J0V2lkdGggKyBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCk7XHJcblxyXG4gICAgICBjb25zdCBpbnNpZGVQcmV2SW50ZXJ2YWwgPSBpbmZpbml0ZSAmJiBzbGlkZS5sZWZ0ICsgc2xpZGUud2lkdGggPiBsZWZ0Qm91bmRhcnkgJiYgc2xpZGUubGVmdCA8IHJpZ2h0Qm91bmRhcnk7XHJcblxyXG4gICAgICAvLyAjMiAtIGluZmluaXRlIGl0ZW1zIGluc2lkZSBjdXJyZW50IHZpZXdwb3J0OyBmcm9tIG5leHQgaW50ZXJ2YWxcclxuICAgICAgbGVmdEJvdW5kYXJ5ID0gY3VycmVudFggLSBjb250ZW50V2lkdGggLSBwYWRkaW5nTGVmdDtcclxuICAgICAgcmlnaHRCb3VuZGFyeSA9IGN1cnJlbnRYIC0gY29udGVudFdpZHRoICsgdmlld3BvcnRXaWR0aCArIHBhZGRpbmdSaWdodDtcclxuXHJcbiAgICAgIC8vIEluY2x1ZGUgc2xpZGVzIHRoYXQgaGF2ZSB0byBiZSBwcmVsb2FkZWRcclxuICAgICAgbGVmdEJvdW5kYXJ5IC09IHByZWxvYWQgKiAodmlld3BvcnRXaWR0aCArIHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0KTtcclxuXHJcbiAgICAgIGNvbnN0IGluc2lkZU5leHRJbnRlcnZhbCA9IGluZmluaXRlICYmIHNsaWRlLmxlZnQgKyBzbGlkZS53aWR0aCA+IGxlZnRCb3VuZGFyeSAmJiBzbGlkZS5sZWZ0IDwgcmlnaHRCb3VuZGFyeTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB2aXJ0dWFsIHNsaWRlcyB0aGF0IHNob3VsZCBiZSB2aXNpYmxlIG9yIHByZWxvYWRlZCwgcmVtb3ZlIG90aGVyc1xyXG4gICAgICBpZiAoaW5zaWRlUHJldkludGVydmFsIHx8IGluc2lkZUN1cnJlbnRJbnRlcnZhbCB8fCBpbnNpZGVOZXh0SW50ZXJ2YWwpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZVNsaWRlRWwoc2xpZGUpO1xyXG5cclxuICAgICAgICBpZiAoaW5zaWRlQ3VycmVudEludGVydmFsKSB7XHJcbiAgICAgICAgICBoYXNEaWZmID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbnNpZGVQcmV2SW50ZXJ2YWwpIHtcclxuICAgICAgICAgIGhhc0RpZmYgPSAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpbnNpZGVOZXh0SW50ZXJ2YWwpIHtcclxuICAgICAgICAgIGhhc0RpZmYgPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQnJpbmcgcHJlbG9hZGVkIHNsaWRlcyBiYWNrIHRvIHZpZXdwb3J0LCBpZiBuZWVkZWRcclxuICAgICAgICBpZiAoc2xpZGUubGVmdCArIHNsaWRlLndpZHRoID4gY3VycmVudFggJiYgc2xpZGUubGVmdCA8PSBjdXJyZW50WCArIHZpZXdwb3J0V2lkdGggKyBwYWRkaW5nUmlnaHQpIHtcclxuICAgICAgICAgIGhhc0RpZmYgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVNsaWRlRWwoc2xpZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzbGlkZS5oYXNEaWZmID0gaGFzRGlmZjtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlcG9zaXRpb24gc2xpZGVzIGZvciBjb250aW51aXR5XHJcbiAgICBsZXQgbmV4dEluZGV4ID0gMDtcclxuICAgIGxldCBuZXh0UG9zID0gMDtcclxuXHJcbiAgICB0aGlzLnNsaWRlcy5mb3JFYWNoKChzbGlkZSwgaW5kZXgpID0+IHtcclxuICAgICAgbGV0IHVwZGF0ZWRYID0gMDtcclxuXHJcbiAgICAgIGlmIChzbGlkZS4kZWwpIHtcclxuICAgICAgICBpZiAoaW5kZXggIT09IG5leHRJbmRleCB8fCBzbGlkZS5oYXNEaWZmKSB7XHJcbiAgICAgICAgICB1cGRhdGVkWCA9IG5leHRQb3MgKyBzbGlkZS5oYXNEaWZmICogY29udGVudFdpZHRoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXh0UG9zID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNsaWRlLiRlbC5zdHlsZS5sZWZ0ID0gTWF0aC5hYnModXBkYXRlZFgpID4gMC4xID8gYCR7bmV4dFBvcyArIHNsaWRlLmhhc0RpZmYgKiBjb250ZW50V2lkdGh9cHhgIDogXCJcIjtcclxuXHJcbiAgICAgICAgbmV4dEluZGV4Kys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmV4dFBvcyArPSBzbGlkZS53aWR0aDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5tYXJrU2VsZWN0ZWRTbGlkZXMoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgbWFpbiBET00gZWxlbWVudCBmb3IgdmlydHVhbCBzbGlkZXMsXHJcbiAgICogbGF6eSBsb2FkcyBpbWFnZXMgaW5zaWRlIHJlZ3VsYXIgc2xpZGVzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXHJcbiAgICovXHJcbiAgY3JlYXRlU2xpZGVFbChzbGlkZSkge1xyXG4gICAgaWYgKCFzbGlkZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNsaWRlLiRlbCkge1xyXG4gICAgICBsZXQgY3VyZW50SW5kZXggPSBzbGlkZS4kZWwuZGF0YXNldC5pbmRleDtcclxuXHJcbiAgICAgIGlmICghY3VyZW50SW5kZXggfHwgcGFyc2VJbnQoY3VyZW50SW5kZXgsIDEwKSAhPT0gc2xpZGUuaW5kZXgpIHtcclxuICAgICAgICBzbGlkZS4kZWwuZGF0YXNldC5pbmRleCA9IHNsaWRlLmluZGV4O1xyXG5cclxuICAgICAgICAvLyBMYXp5IGxvYWQgaW1hZ2VzXHJcbiAgICAgICAgLy8gPT09XHJcbiAgICAgICAgc2xpZGUuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1sYXp5LXNyY3NldF1cIikuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgbm9kZS5zcmNzZXQgPSBub2RlLmRhdGFzZXQubGF6eVNyY3NldDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2xpZGUuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1sYXp5LXNyY11cIikuZm9yRWFjaCgobm9kZSkgPT4ge1xyXG4gICAgICAgICAgbGV0IGxhenlTcmMgPSBub2RlLmRhdGFzZXQubGF6eVNyYztcclxuXHJcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgbm9kZS5zcmMgPSBsYXp5U3JjO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCcke2xhenlTcmN9JylgO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBMYXp5IGxvYWQgc2xpZGUgYmFja2dyb3VuZCBpbWFnZVxyXG4gICAgICAgIC8vID09PVxyXG4gICAgICAgIGxldCBsYXp5U3JjO1xyXG5cclxuICAgICAgICBpZiAoKGxhenlTcmMgPSBzbGlkZS4kZWwuZGF0YXNldC5sYXp5U3JjKSkge1xyXG4gICAgICAgICAgc2xpZGUuJGVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJyR7bGF6eVNyY30nKWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzbGlkZS5zdGF0ZSA9IFwicmVhZHlcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcblxyXG4gICAgZGl2LmRhdGFzZXQuaW5kZXggPSBzbGlkZS5pbmRleDtcclxuICAgIGRpdi5jbGFzc0xpc3QuYWRkKC4uLih0aGlzLm9wdGlvbihcInByZWZpeFwiKSArIHRoaXMub3B0aW9uKFwiY2xhc3NOYW1lcy5zbGlkZVwiKSkuc3BsaXQoXCIgXCIpKTtcclxuXHJcbiAgICBpZiAoc2xpZGUuY3VzdG9tQ2xhc3MpIHtcclxuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoLi4uc2xpZGUuY3VzdG9tQ2xhc3Muc3BsaXQoXCIgXCIpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2xpZGUuaHRtbCkge1xyXG4gICAgICBkaXYuaW5uZXJIVE1MID0gc2xpZGUuaHRtbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhbGxFbGVsZW1lbnRzID0gW107XHJcblxyXG4gICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoc2xpZGUsIGluZGV4KSA9PiB7XHJcbiAgICAgIGlmIChzbGlkZS4kZWwpIHtcclxuICAgICAgICBhbGxFbGVsZW1lbnRzLnB1c2goaW5kZXgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBGaW5kIGEgcGxhY2UgaW4gRE9NIHRvIGluc2VydCBhbiBlbGVtZW50XHJcbiAgICBjb25zdCBnb2FsID0gc2xpZGUuaW5kZXg7XHJcbiAgICBsZXQgcmVmU2xpZGUgPSBudWxsO1xyXG5cclxuICAgIGlmIChhbGxFbGVsZW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBsZXQgcmVmSW5kZXggPSBhbGxFbGVsZW1lbnRzLnJlZHVjZSgocHJldiwgY3VycikgPT5cclxuICAgICAgICBNYXRoLmFicyhjdXJyIC0gZ29hbCkgPCBNYXRoLmFicyhwcmV2IC0gZ29hbCkgPyBjdXJyIDogcHJldlxyXG4gICAgICApO1xyXG4gICAgICByZWZTbGlkZSA9IHRoaXMuc2xpZGVzW3JlZkluZGV4XTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLiR0cmFjay5pbnNlcnRCZWZvcmUoXHJcbiAgICAgIGRpdixcclxuICAgICAgcmVmU2xpZGUgJiYgcmVmU2xpZGUuJGVsID8gKHJlZlNsaWRlLmluZGV4IDwgc2xpZGUuaW5kZXggPyByZWZTbGlkZS4kZWwubmV4dFNpYmxpbmcgOiByZWZTbGlkZS4kZWwpIDogbnVsbFxyXG4gICAgKTtcclxuXHJcbiAgICBzbGlkZS4kZWwgPSBkaXY7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKFwiY3JlYXRlU2xpZGVcIiwgc2xpZGUsIGdvYWwpO1xyXG5cclxuICAgIHJldHVybiBzbGlkZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgbWFpbiBET00gZWxlbWVudCBvZiBnaXZlbiBzbGlkZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxyXG4gICAqL1xyXG4gIHJlbW92ZVNsaWRlRWwoc2xpZGUpIHtcclxuICAgIGlmIChzbGlkZS4kZWwgJiYgIXNsaWRlLmlzRG9tKSB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihcInJlbW92ZVNsaWRlXCIsIHNsaWRlKTtcclxuXHJcbiAgICAgIHNsaWRlLiRlbC5yZW1vdmUoKTtcclxuICAgICAgc2xpZGUuJGVsID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvZ2dsZXMgc2VsZWN0ZWQgY2xhc3MgbmFtZSBhbmQgYXJpYS1oaWRkZW4gYXR0cmlidXRlIGZvciBzbGlkZXMgYmFzZWQgb24gdmlzaWJpbGl0eVxyXG4gICAqL1xyXG4gIG1hcmtTZWxlY3RlZFNsaWRlcygpIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkQ2xhc3MgPSB0aGlzLm9wdGlvbihcImNsYXNzTmFtZXMuc2xpZGVTZWxlY3RlZFwiKTtcclxuICAgIGNvbnN0IGF0dHIgPSBcImFyaWEtaGlkZGVuXCI7XHJcblxyXG4gICAgdGhpcy5zbGlkZXMuZm9yRWFjaCgoc2xpZGUsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0ICRlbCA9IHNsaWRlLiRlbDtcclxuXHJcbiAgICAgIGlmICghJGVsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlc1t0aGlzLnBhZ2VdO1xyXG5cclxuICAgICAgaWYgKHBhZ2UgJiYgcGFnZS5pbmRleGVzICYmIHBhZ2UuaW5kZXhlcy5pbmRleE9mKGluZGV4KSA+IC0xKSB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkQ2xhc3MgJiYgISRlbC5jbGFzc0xpc3QuY29udGFpbnMoc2VsZWN0ZWRDbGFzcykpIHtcclxuICAgICAgICAgICRlbC5jbGFzc0xpc3QuYWRkKHNlbGVjdGVkQ2xhc3MpO1xyXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKFwic2VsZWN0U2xpZGVcIiwgc2xpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRDbGFzcyAmJiAkZWwuY2xhc3NMaXN0LmNvbnRhaW5zKHNlbGVjdGVkQ2xhc3MpKSB7XHJcbiAgICAgICAgICAkZWwuY2xhc3NMaXN0LnJlbW92ZShzZWxlY3RlZENsYXNzKTtcclxuICAgICAgICAgIHRoaXMudHJpZ2dlcihcInVuc2VsZWN0U2xpZGVcIiwgc2xpZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJGVsLnNldEF0dHJpYnV0ZShhdHRyLCB0cnVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtIGFsbCBjYWxjdWxhdGlvbnMgYW5kIGNlbnRlciBjdXJyZW50IHBhZ2VcclxuICAgKi9cclxuICB1cGRhdGVQYWdlKCkge1xyXG4gICAgdGhpcy51cGRhdGVNZXRyaWNzKCk7XHJcblxyXG4gICAgdGhpcy5zbGlkZVRvKHRoaXMucGFnZSwgeyBmcmljdGlvbjogMCB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByb2Nlc3MgYFBhbnpvb20uYmVmb3JlVHJhbnNmb3JtYCBldmVudCB0byByZW1vdmUgc2xpZGVzIG1vdmVkIG91dCBvZiB2aWV3cG9ydCBhbmRcclxuICAgKiB0byBjcmVhdGUgbmVjZXNzYXJ5IG9uZXNcclxuICAgKi9cclxuICBvbkJlZm9yZVRyYW5zZm9ybSgpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbihcImluZmluaXRlWFwiLCB0aGlzLm9wdGlvbihcImluZmluaXRlXCIpKSkge1xyXG4gICAgICB0aGlzLm1hbmFnZUluZmluaXRlVHJhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm1hbmFnZVNsaWRlVmlzaWJsaXR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWFtbGVzc2x5IGZsaXAgcG9zaXRpb24gb2YgaW5maW5pdGUgY2Fyb3VzZWwsIGlmIG5lZWRlZDsgdGhpcyB3YXkgeCBwb3NpdGlvbiBzdGF5cyBsb3dcclxuICAgKi9cclxuICBtYW5hZ2VJbmZpbml0ZVRyYWNrKCkge1xyXG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5jb250ZW50V2lkdGg7XHJcbiAgICBjb25zdCB2aWV3cG9ydFdpZHRoID0gdGhpcy52aWV3cG9ydFdpZHRoO1xyXG5cclxuICAgIGlmICghdGhpcy5vcHRpb24oXCJpbmZpbml0ZVhcIiwgdGhpcy5vcHRpb24oXCJpbmZpbml0ZVwiKSkgfHwgdGhpcy5wYWdlcy5sZW5ndGggPCAyIHx8IGNvbnRlbnRXaWR0aCA8IHZpZXdwb3J0V2lkdGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhbnpvb20gPSB0aGlzLlBhbnpvb207XHJcblxyXG4gICAgbGV0IGlzRmxpcHBlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChwYW56b29tLmNvbnRlbnQueCA8IChjb250ZW50V2lkdGggLSB2aWV3cG9ydFdpZHRoKSAqIC0xKSB7XHJcbiAgICAgIHBhbnpvb20uY29udGVudC54ICs9IGNvbnRlbnRXaWR0aDtcclxuXHJcbiAgICAgIHRoaXMucGFnZUluZGV4ID0gdGhpcy5wYWdlSW5kZXggLSB0aGlzLnBhZ2VzLmxlbmd0aDtcclxuXHJcbiAgICAgIGlzRmxpcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBhbnpvb20uY29udGVudC54ID4gdmlld3BvcnRXaWR0aCkge1xyXG4gICAgICBwYW56b29tLmNvbnRlbnQueCAtPSBjb250ZW50V2lkdGg7XHJcblxyXG4gICAgICB0aGlzLnBhZ2VJbmRleCA9IHRoaXMucGFnZUluZGV4ICsgdGhpcy5wYWdlcy5sZW5ndGg7XHJcblxyXG4gICAgICBpc0ZsaXBwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0ZsaXBwZWQgJiYgcGFuem9vbS5zdGF0ZSA9PT0gXCJwb2ludGVyZG93blwiKSB7XHJcbiAgICAgIHBhbnpvb20ucmVzZXREcmFnUG9zaXRpb24oKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXNGbGlwcGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJvY2VzcyBgUGFuem9vbS50b3VjaEVuZGAgZXZlbnQ7IHNsaWRlIHRvIG5leHQvcHJldiBwYWdlIGlmIG5lZWRlZFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYW56b29tXHJcbiAgICovXHJcbiAgb25Ub3VjaEVuZChwYW56b29tLCBldmVudCkge1xyXG4gICAgY29uc3QgZHJhZ0ZyZWUgPSB0aGlzLm9wdGlvbihcImRyYWdGcmVlXCIpO1xyXG5cclxuICAgIC8vIElmIHRoaXMgaXMgYSBxdWljayBob3Jpem9udGFsIGZsaWNrLCBzbGlkZSB0byBuZXh0L3ByZXYgc2xpZGVcclxuICAgIGlmIChcclxuICAgICAgIWRyYWdGcmVlICYmXHJcbiAgICAgIHRoaXMucGFnZXMubGVuZ3RoID4gMSAmJlxyXG4gICAgICBwYW56b29tLmRyYWdPZmZzZXQudGltZSA8IDM1MCAmJlxyXG4gICAgICBNYXRoLmFicyhwYW56b29tLmRyYWdPZmZzZXQueSkgPCAxICYmXHJcbiAgICAgIE1hdGguYWJzKHBhbnpvb20uZHJhZ09mZnNldC54KSA+IDVcclxuICAgICkge1xyXG4gICAgICB0aGlzW3Bhbnpvb20uZHJhZ09mZnNldC54IDwgMCA/IFwic2xpZGVOZXh0XCIgOiBcInNsaWRlUHJldlwiXSgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IHRoZSBzbGlkZSBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24gYXMgdGhlIGN1cnJlbnQgb25lLFxyXG4gICAgLy8gb3Igc2xpZGUgdG8gY2xvc2VzdCBwYWdlXHJcbiAgICBpZiAoZHJhZ0ZyZWUpIHtcclxuICAgICAgY29uc3QgWywgbmV4dFBhZ2VJbmRleF0gPSB0aGlzLmdldFBhZ2VGcm9tUG9zaXRpb24ocGFuem9vbS50cmFuc2Zvcm0ueCAqIC0xKTtcclxuICAgICAgdGhpcy5zZXRQYWdlKG5leHRQYWdlSW5kZXgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5zbGlkZVRvQ2xvc2VzdCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2xpZGVzIHRvIHRoZSBjbG9zZXN0IHBhZ2UgKHVzZWZ1bCwgaWYgY2Fyb3VzZWwgaXMgY2hhbmdlZCBtYW51YWxseSlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBPYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIG9wdGlvbnNcclxuICAgKi9cclxuICBzbGlkZVRvQ2xvc2VzdChwYXJhbXMgPSB7fSkge1xyXG4gICAgbGV0IFssIG5leHRQYWdlSW5kZXhdID0gdGhpcy5nZXRQYWdlRnJvbVBvc2l0aW9uKHRoaXMuUGFuem9vbS5jb250ZW50LnggKiAtMSk7XHJcblxyXG4gICAgdGhpcy5zbGlkZVRvKG5leHRQYWdlSW5kZXgsIHBhcmFtcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGluZGV4IG9mIGNsb3Nlc3QgcGFnZSB0byBnaXZlbiB4IHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhQb3NcclxuICAgKi9cclxuICBnZXRQYWdlRnJvbVBvc2l0aW9uKHhQb3MpIHtcclxuICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRoaXMucGFnZXMubGVuZ3RoO1xyXG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5vcHRpb24oXCJjZW50ZXJcIik7XHJcblxyXG4gICAgaWYgKGNlbnRlcikge1xyXG4gICAgICB4UG9zICs9IHRoaXMudmlld3BvcnRXaWR0aCAqIDAuNTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbnRlcnZhbCA9IE1hdGguZmxvb3IoeFBvcyAvIHRoaXMuY29udGVudFdpZHRoKTtcclxuXHJcbiAgICB4UG9zIC09IGludGVydmFsICogdGhpcy5jb250ZW50V2lkdGg7XHJcblxyXG4gICAgbGV0IHNsaWRlID0gdGhpcy5zbGlkZXMuZmluZCgoc2xpZGUpID0+IHNsaWRlLmxlZnQgPD0geFBvcyAmJiBzbGlkZS5sZWZ0ICsgc2xpZGUud2lkdGggPiB4UG9zKTtcclxuXHJcbiAgICBpZiAoc2xpZGUpIHtcclxuICAgICAgbGV0IHBhZ2VJbmRleCA9IHRoaXMuZmluZFBhZ2VGb3JTbGlkZShzbGlkZS5pbmRleCk7XHJcblxyXG4gICAgICByZXR1cm4gW3BhZ2VJbmRleCwgcGFnZUluZGV4ICsgaW50ZXJ2YWwgKiBwYWdlQ291bnRdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbMCwgMF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGFuZ2VzIGFjdGl2ZSBwYWdlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2UgLSBOZXcgaW5kZXggb2YgYWN0aXZlIHBhZ2VcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRvQ2xvc2VzdCAtIHRvIGNsb3Nlc3QgcGFnZSBiYXNlZCBvbiBzY3JvbGwgZGlzdGFuY2UgKGZvciBpbmZpbml0ZSBuYXZpZ2F0aW9uKVxyXG4gICAqL1xyXG4gIHNldFBhZ2UocGFnZSwgdG9DbG9zZXN0KSB7XHJcbiAgICBsZXQgbmV4dFBvc2l0aW9uID0gMDtcclxuICAgIGxldCBwYWdlSW5kZXggPSBwYXJzZUludChwYWdlLCAxMCkgfHwgMDtcclxuXHJcbiAgICBjb25zdCBwcmV2UGFnZSA9IHRoaXMucGFnZSxcclxuICAgICAgcHJldlBhZ2VJbmRleCA9IHRoaXMucGFnZUluZGV4LFxyXG4gICAgICBwYWdlQ291bnQgPSB0aGlzLnBhZ2VzLmxlbmd0aDtcclxuXHJcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmNvbnRlbnRXaWR0aDtcclxuICAgIGNvbnN0IHZpZXdwb3J0V2lkdGggPSB0aGlzLnZpZXdwb3J0V2lkdGg7XHJcblxyXG4gICAgcGFnZSA9ICgocGFnZUluZGV4ICUgcGFnZUNvdW50KSArIHBhZ2VDb3VudCkgJSBwYWdlQ291bnQ7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9uKFwiaW5maW5pdGVYXCIsIHRoaXMub3B0aW9uKFwiaW5maW5pdGVcIikpICYmIGNvbnRlbnRXaWR0aCA+IHZpZXdwb3J0V2lkdGgpIHtcclxuICAgICAgY29uc3QgbmV4dEludGVydmFsID0gTWF0aC5mbG9vcihwYWdlSW5kZXggLyBwYWdlQ291bnQpIHx8IDAsXHJcbiAgICAgICAgZWxlbURpbVdpZHRoID0gY29udGVudFdpZHRoO1xyXG5cclxuICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wYWdlc1twYWdlXS5sZWZ0ICsgbmV4dEludGVydmFsICogZWxlbURpbVdpZHRoO1xyXG5cclxuICAgICAgaWYgKHRvQ2xvc2VzdCA9PT0gdHJ1ZSAmJiBwYWdlQ291bnQgPiAyKSB7XHJcbiAgICAgICAgbGV0IGN1cnJQb3NpdGlvbiA9IHRoaXMuUGFuem9vbS5jb250ZW50LnggKiAtMTtcclxuXHJcbiAgICAgICAgLy8gKiBGaW5kIGNsb3Nlc3QgaW50ZXJ2YWxcclxuICAgICAgICBjb25zdCBkZWNyZWFzZWRQb3NpdGlvbiA9IG5leHRQb3NpdGlvbiAtIGVsZW1EaW1XaWR0aCxcclxuICAgICAgICAgIGluY3JlYXNlZFBvc2l0aW9uID0gbmV4dFBvc2l0aW9uICsgZWxlbURpbVdpZHRoLFxyXG4gICAgICAgICAgZGlmZjEgPSBNYXRoLmFicyhjdXJyUG9zaXRpb24gLSBuZXh0UG9zaXRpb24pLFxyXG4gICAgICAgICAgZGlmZjIgPSBNYXRoLmFicyhjdXJyUG9zaXRpb24gLSBkZWNyZWFzZWRQb3NpdGlvbiksXHJcbiAgICAgICAgICBkaWZmMyA9IE1hdGguYWJzKGN1cnJQb3NpdGlvbiAtIGluY3JlYXNlZFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgaWYgKGRpZmYzIDwgZGlmZjEgJiYgZGlmZjMgPD0gZGlmZjIpIHtcclxuICAgICAgICAgIG5leHRQb3NpdGlvbiA9IGluY3JlYXNlZFBvc2l0aW9uO1xyXG4gICAgICAgICAgcGFnZUluZGV4ICs9IHBhZ2VDb3VudDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpZmYyIDwgZGlmZjEgJiYgZGlmZjIgPCBkaWZmMykge1xyXG4gICAgICAgICAgbmV4dFBvc2l0aW9uID0gZGVjcmVhc2VkUG9zaXRpb247XHJcbiAgICAgICAgICBwYWdlSW5kZXggLT0gcGFnZUNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcGFnZSA9IHBhZ2VJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VJbmRleCwgcGFnZUNvdW50IC0gMSkpO1xyXG5cclxuICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wYWdlcy5sZW5ndGggPyB0aGlzLnBhZ2VzW3BhZ2VdLmxlZnQgOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucGFnZSA9IHBhZ2U7XHJcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcclxuXHJcbiAgICBpZiAocHJldlBhZ2UgIT09IG51bGwgJiYgcGFnZSAhPT0gcHJldlBhZ2UpIHtcclxuICAgICAgdGhpcy5wcmV2UGFnZSA9IHByZXZQYWdlO1xyXG4gICAgICB0aGlzLnByZXZQYWdlSW5kZXggPSBwcmV2UGFnZUluZGV4O1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIsIHBhZ2UsIHByZXZQYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV4dFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYW4gdXBcclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwiZGVzdHJveVwiO1xyXG5cclxuICAgIHRoaXMuc2xpZGVzLmZvckVhY2goKHNsaWRlKSA9PiB7XHJcbiAgICAgIHRoaXMucmVtb3ZlU2xpZGVFbChzbGlkZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnNsaWRlcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuUGFuem9vbS5kZXN0cm95KCk7XHJcblxyXG4gICAgdGhpcy5kZXRhY2hQbHVnaW5zKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvc2UgdmVyc2lvblxyXG5DYXJvdXNlbC52ZXJzaW9uID0gXCJfX1ZFUlNJT05fX1wiO1xyXG5cclxuLy8gU3RhdGljIHByb3BlcnRpZXMgYXJlIGEgcmVjZW50IGFkZGl0aW9uIHRoYXQgZG9udCB3b3JrIGluIGFsbCBicm93c2VycyB5ZXRcclxuQ2Fyb3VzZWwuUGx1Z2lucyA9IFBsdWdpbnM7XHJcbiIsImV4cG9ydCBkZWZhdWx0IHtcclxuICBORVhUOiBcIk5leHQgc2xpZGVcIixcclxuICBQUkVWOiBcIlByZXZpb3VzIHNsaWRlXCIsXHJcbiAgR09UTzogXCJHbyB0byBzbGlkZSAjJWRcIixcclxufTtcclxuIiwiY29uc3QgZGVmYXVsdHMgPSB7XG4gIC8vIFRoZSBtaW5pbXVtIG51bWJlciBvZiBzbGlkZXMgdG8gZGlzcGxheSBkb3RzXG4gIG1pblNsaWRlQ291bnQ6IDIsXG59O1xuXG5leHBvcnQgY2xhc3MgRG90cyB7XG4gIGNvbnN0cnVjdG9yKGNhcm91c2VsKSB7XG4gICAgdGhpcy5jYXJvdXNlbCA9IGNhcm91c2VsO1xuXG4gICAgdGhpcy4kbGlzdCA9IG51bGw7XG5cbiAgICB0aGlzLmV2ZW50cyA9IHtcbiAgICAgIGNoYW5nZTogdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgcmVmcmVzaDogdGhpcy5vblJlZnJlc2guYmluZCh0aGlzKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHdyYXBwaW5nIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYWxsIGRvdHNcbiAgICovXG4gIGJ1aWxkTGlzdCgpIHtcbiAgICBpZiAodGhpcy5jYXJvdXNlbC5wYWdlcy5sZW5ndGggPCB0aGlzLmNhcm91c2VsLm9wdGlvbihcIkRvdHMubWluU2xpZGVDb3VudFwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0ICRsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9sXCIpO1xuXG4gICAgJGxpc3QuY2xhc3NMaXN0LmFkZChcImNhcm91c2VsX19kb3RzXCIpO1xuXG4gICAgJGxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICBpZiAoIShcInBhZ2VcIiBpbiBlLnRhcmdldC5kYXRhc2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChlLnRhcmdldC5kYXRhc2V0LnBhZ2UsIDEwKTtcbiAgICAgIGNvbnN0IGNhcm91c2VsID0gdGhpcy5jYXJvdXNlbDtcblxuICAgICAgaWYgKHBhZ2UgPT09IGNhcm91c2VsLnBhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2Fyb3VzZWwucGFnZXMubGVuZ3RoIDwgMyAmJiBjYXJvdXNlbC5vcHRpb24oXCJpbmZpbml0ZVwiKSkge1xuICAgICAgICBjYXJvdXNlbFtwYWdlID09IDAgPyBcInNsaWRlUHJldlwiIDogXCJzbGlkZU5leHRcIl0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcm91c2VsLnNsaWRlVG8ocGFnZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLiRsaXN0ID0gJGxpc3Q7XG5cbiAgICB0aGlzLmNhcm91c2VsLiRjb250YWluZXIuYXBwZW5kQ2hpbGQoJGxpc3QpO1xuICAgIHRoaXMuY2Fyb3VzZWwuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzLWRvdHNcIik7XG5cbiAgICByZXR1cm4gJGxpc3Q7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHdyYXBwaW5nIERPTSBlbGVtZW50XG4gICAqL1xuICByZW1vdmVMaXN0KCkge1xuICAgIGlmICh0aGlzLiRsaXN0KSB7XG4gICAgICB0aGlzLiRsaXN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kbGlzdCk7XG4gICAgICB0aGlzLiRsaXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmNhcm91c2VsLiRjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcImhhcy1kb3RzXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBleGlzdGluZyBkb3RzIGFuZCBjcmVhdGUgZnJlc2ggb25lc1xuICAgKi9cbiAgcmVidWlsZERvdHMoKSB7XG4gICAgbGV0ICRsaXN0ID0gdGhpcy4kbGlzdDtcblxuICAgIGNvbnN0IGxpc3RFeGlzdHMgPSAhISRsaXN0O1xuICAgIGNvbnN0IHBhZ2VzQ291bnQgPSB0aGlzLmNhcm91c2VsLnBhZ2VzLmxlbmd0aDtcblxuICAgIGlmIChwYWdlc0NvdW50IDwgMikge1xuICAgICAgaWYgKGxpc3RFeGlzdHMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWxpc3RFeGlzdHMpIHtcbiAgICAgICRsaXN0ID0gdGhpcy5idWlsZExpc3QoKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZXhpc3RpbmcgZG90c1xuICAgIGNvbnN0IGRvdENvdW50ID0gdGhpcy4kbGlzdC5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBpZiAoZG90Q291bnQgPiBwYWdlc0NvdW50KSB7XG4gICAgICBmb3IgKGxldCBpID0gcGFnZXNDb3VudDsgaSA8IGRvdENvdW50OyBpKyspIHtcbiAgICAgICAgdGhpcy4kbGlzdC5yZW1vdmVDaGlsZCh0aGlzLiRsaXN0Lmxhc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgZnJlc2ggRE9NIGVsZW1lbnRzIChkb3RzKSBmb3IgZWFjaCBwYWdlXG4gICAgZm9yIChsZXQgaW5kZXggPSBkb3RDb3VudDsgaW5kZXggPCBwYWdlc0NvdW50OyBpbmRleCsrKSB7XG4gICAgICBjb25zdCAkZG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuXG4gICAgICAkZG90LmNsYXNzTGlzdC5hZGQoXCJjYXJvdXNlbF9fZG90XCIpO1xuICAgICAgJGRvdC5kYXRhc2V0LnBhZ2UgPSBpbmRleDtcblxuICAgICAgJGRvdC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgJGRvdC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gICAgICAkZG90LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRoaXMuY2Fyb3VzZWwubG9jYWxpemUoXCJ7e0dPVE99fVwiLCBbW1wiJWRcIiwgaW5kZXggKyAxXV0pKTtcblxuICAgICAgJGRvdC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgY29kZSA9IGV2ZW50LmNvZGU7XG5cbiAgICAgICAgbGV0ICRlbDtcblxuICAgICAgICBpZiAoY29kZSA9PT0gXCJFbnRlclwiIHx8IGNvZGUgPT09IFwiTnVtcGFkRW50ZXJcIikge1xuICAgICAgICAgICRlbCA9ICRkb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gXCJBcnJvd1JpZ2h0XCIpIHtcbiAgICAgICAgICAkZWwgPSAkZG90Lm5leHRTaWJsaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgICAgICAkZWwgPSAkZG90LnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgICRlbCAmJiAkZWwuY2xpY2soKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLiRsaXN0LmFwcGVuZENoaWxkKCRkb3QpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QWN0aXZlRG90KCk7XG4gIH1cblxuICAvKipcbiAgICogTWFyayBhY3RpdmUgZG90IGJ5IHRvZ2dsaW5nIGNsYXNzIG5hbWVcbiAgICovXG4gIHNldEFjdGl2ZURvdCgpIHtcbiAgICBpZiAoIXRoaXMuJGxpc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLiRsaXN0LmNoaWxkTm9kZXMuZm9yRWFjaCgoJGRvdCkgPT4ge1xuICAgICAgJGRvdC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtc2VsZWN0ZWRcIik7XG4gICAgfSk7XG5cbiAgICBjb25zdCAkYWN0aXZlRG90ID0gdGhpcy4kbGlzdC5jaGlsZE5vZGVzW3RoaXMuY2Fyb3VzZWwucGFnZV07XG5cbiAgICBpZiAoJGFjdGl2ZURvdCkge1xuICAgICAgJGFjdGl2ZURvdC5jbGFzc0xpc3QuYWRkKFwiaXMtc2VsZWN0ZWRcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgY2Fyb3VzZWwgYGNoYW5nZWAgZXZlbnRcbiAgICovXG4gIG9uQ2hhbmdlKCkge1xuICAgIHRoaXMuc2V0QWN0aXZlRG90KCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBjYXJvdXNlbCBgcmVmcmVzaGAgZXZlbnRcbiAgICovXG4gIG9uUmVmcmVzaCgpIHtcbiAgICB0aGlzLnJlYnVpbGREb3RzKCk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5jYXJvdXNlbC5vbih0aGlzLmV2ZW50cyk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0KCk7XG5cbiAgICB0aGlzLmNhcm91c2VsLm9mZih0aGlzLmV2ZW50cyk7XG4gICAgdGhpcy5jYXJvdXNlbCA9IG51bGw7XG4gIH1cbn1cbiIsImNvbnN0IGRlZmF1bHRzID0ge1xuICBwcmV2VHBsOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHRhYmluZGV4PVwiLTFcIj48cGF0aCBkPVwiTTE1IDNsLTkgOSA5IDlcIi8+PC9zdmc+JyxcbiAgbmV4dFRwbDogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB0YWJpbmRleD1cIi0xXCI+PHBhdGggZD1cIk05IDNsOSA5LTkgOVwiLz48L3N2Zz4nLFxuXG4gIGNsYXNzTmFtZXM6IHtcbiAgICBtYWluOiBcImNhcm91c2VsX19uYXZcIixcbiAgICBidXR0b246IFwiY2Fyb3VzZWxfX2J1dHRvblwiLFxuXG4gICAgbmV4dDogXCJpcy1uZXh0XCIsXG4gICAgcHJldjogXCJpcy1wcmV2XCIsXG4gIH0sXG59O1xuXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNhcm91c2VsKSB7XG4gICAgdGhpcy4kY29udGFpbmVyID0gbnVsbDtcblxuICAgIHRoaXMuJHByZXYgPSBudWxsO1xuICAgIHRoaXMuJG5leHQgPSBudWxsO1xuXG4gICAgdGhpcy5jYXJvdXNlbCA9IGNhcm91c2VsO1xuXG4gICAgdGhpcy5vblJlZnJlc2ggPSB0aGlzLm9uUmVmcmVzaC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IHRvIGdldCBvcHRpb24gZm9yIHRoaXMgcGx1Z2luXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9wdGlvbiBuYW1lXG4gICAqIEByZXR1cm5zIG9wdGlvbiB2YWx1ZVxuICAgKi9cbiAgb3B0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jYXJvdXNlbC5vcHRpb24oYE5hdmlnYXRpb24uJHtuYW1lfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgbmV3IGJ1dHRvbiBlbGVtZW50IHdpdGggZGVmYXVsdCBjbGFzcyBuYW1lcyBhbmQgY2xpY2sgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICovXG4gIGNyZWF0ZUJ1dHRvbih0eXBlKSB7XG4gICAgY29uc3QgJGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG5cbiAgICAkYnRuLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRoaXMuY2Fyb3VzZWwubG9jYWxpemUoYHt7JHt0eXBlLnRvVXBwZXJDYXNlKCl9fX1gKSk7XG5cbiAgICBjb25zdCBjbGFzc05hbWVzID0gdGhpcy5vcHRpb24oXCJjbGFzc05hbWVzLmJ1dHRvblwiKSArIFwiIFwiICsgdGhpcy5vcHRpb24oYGNsYXNzTmFtZXMuJHt0eXBlfWApO1xuXG4gICAgJGJ0bi5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMuc3BsaXQoXCIgXCIpKTtcbiAgICAkYnRuLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAkYnRuLmlubmVySFRNTCA9IHRoaXMuY2Fyb3VzZWwubG9jYWxpemUodGhpcy5vcHRpb24oYCR7dHlwZX1UcGxgKSk7XG5cbiAgICAkYnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgdGhpcy5jYXJvdXNlbFtgc2xpZGUke3R5cGUgPT09IFwibmV4dFwiID8gXCJOZXh0XCIgOiBcIlByZXZcIn1gXSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICRidG47XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgbmVjZXNzYXJ5IERPTSBlbGVtZW50c1xuICAgKi9cbiAgYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLiRjb250YWluZXIpIHtcbiAgICAgIHRoaXMuJGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLiRjb250YWluZXIuY2xhc3NMaXN0LmFkZCguLi50aGlzLm9wdGlvbihcImNsYXNzTmFtZXMubWFpblwiKS5zcGxpdChcIiBcIikpO1xuXG4gICAgICB0aGlzLmNhcm91c2VsLiRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy4kY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuJG5leHQpIHtcbiAgICAgIHRoaXMuJG5leHQgPSB0aGlzLmNyZWF0ZUJ1dHRvbihcIm5leHRcIik7XG5cbiAgICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiRuZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuJHByZXYpIHtcbiAgICAgIHRoaXMuJHByZXYgPSB0aGlzLmNyZWF0ZUJ1dHRvbihcInByZXZcIik7XG5cbiAgICAgIHRoaXMuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLiRwcmV2KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIFByb2Nlc3MgY2Fyb3VzZWwgYHJlZnJlc2hgIGFuZCBgY2hhbmdlYCBldmVudHMgdG8gZW5hYmxlL2Rpc2FibGUgYnV0dG9ucyBpZiBuZWVkZWRcbiAgICovXG4gIG9uUmVmcmVzaCgpIHtcbiAgICBjb25zdCBwYWdlQ291bnQgPSB0aGlzLmNhcm91c2VsLnBhZ2VzLmxlbmd0aDtcblxuICAgIGlmIChcbiAgICAgIHBhZ2VDb3VudCA8PSAxIHx8XG4gICAgICAocGFnZUNvdW50ID4gMSAmJlxuICAgICAgICB0aGlzLmNhcm91c2VsLmVsZW1EaW1XaWR0aCA8IHRoaXMuY2Fyb3VzZWwud3JhcERpbVdpZHRoICYmXG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuY2Fyb3VzZWwub3B0aW9uKFwic2xpZGVzUGVyUGFnZVwiKSkpXG4gICAgKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYnVpbGQoKTtcblxuICAgIHRoaXMuJHByZXYucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XG4gICAgdGhpcy4kbmV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcblxuICAgIGlmICh0aGlzLmNhcm91c2VsLm9wdGlvbihcImluZmluaXRlWFwiLCB0aGlzLmNhcm91c2VsLm9wdGlvbihcImluZmluaXRlXCIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhcm91c2VsLnBhZ2UgPD0gMCkge1xuICAgICAgdGhpcy4kcHJldi5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jYXJvdXNlbC5wYWdlID49IHBhZ2VDb3VudCAtIDEpIHtcbiAgICAgIHRoaXMuJG5leHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIik7XG4gICAgfVxuICB9XG5cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy4kcHJldikge1xuICAgICAgdGhpcy4kcHJldi5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLiRwcmV2ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLiRuZXh0KSB7XG4gICAgICB0aGlzLiRuZXh0LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuJG5leHQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuJGNvbnRhaW5lcikge1xuICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuJGNvbnRhaW5lciA9IG51bGw7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5jYXJvdXNlbC5vbihcInJlZnJlc2ggY2hhbmdlXCIsIHRoaXMub25SZWZyZXNoKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmNhcm91c2VsLm9mZihcInJlZnJlc2ggY2hhbmdlXCIsIHRoaXMub25SZWZyZXNoKTtcblxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG59XG5cbi8vIEV4cG9zZSBkZWZhdWx0c1xuTmF2aWdhdGlvbi5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuIiwiY29uc3QgZGVmYXVsdHMgPSB7XG4gIGZyaWN0aW9uOiAwLjkyLFxufTtcblxuZXhwb3J0IGNsYXNzIFN5bmMge1xuICBjb25zdHJ1Y3RvcihjYXJvdXNlbCkge1xuICAgIHRoaXMuY2Fyb3VzZWwgPSBjYXJvdXNlbDtcblxuICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IG51bGw7XG4gICAgdGhpcy5mcmljdGlvbiA9IDA7XG5cbiAgICB0aGlzLm9uTmF2UmVhZHkgPSB0aGlzLm9uTmF2UmVhZHkuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTmF2Q2xpY2sgPSB0aGlzLm9uTmF2Q2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTmF2Q3JlYXRlU2xpZGUgPSB0aGlzLm9uTmF2Q3JlYXRlU2xpZGUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMub25UYXJnZXRDaGFuZ2UgPSB0aGlzLm9uVGFyZ2V0Q2hhbmdlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIG9uZSBhcyBtYWluIGNhcm91c2VsIGFuZCBzZWxlY3RlZCBjYXJvdXNlbCBhcyBuYXZpZ2F0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBuYXYgQ2Fyb3VzZWxcbiAgICovXG4gIGFkZEFzVGFyZ2V0Rm9yKG5hdikge1xuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5jYXJvdXNlbDtcbiAgICB0aGlzLm5hdiA9IG5hdjtcblxuICAgIHRoaXMuYXR0YWNoRXZlbnRzKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIG9uZSBhcyBuYXZpZ2F0aW9uIGNhcm91c2VsIGZvciBzZWxlY3RlZCBjYXJvdXNlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqL1xuICBhZGRBc05hdkZvcih0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLm5hdiA9IHRoaXMuY2Fyb3VzZWw7XG5cbiAgICB0aGlzLmF0dGFjaEV2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBldmVudCBsaXN0ZW5lcnMgb24gYm90aCBjYXJvdXNlbHNcbiAgICovXG4gIGF0dGFjaEV2ZW50cygpIHtcbiAgICB0aGlzLm5hdi5vcHRpb25zLmluaXRpYWxTbGlkZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMuaW5pdGlhbFBhZ2U7XG5cbiAgICB0aGlzLm5hdi5vbihcInJlYWR5XCIsIHRoaXMub25OYXZSZWFkeSk7XG4gICAgdGhpcy5uYXYub24oXCJjcmVhdGVTbGlkZVwiLCB0aGlzLm9uTmF2Q3JlYXRlU2xpZGUpO1xuICAgIHRoaXMubmF2Lm9uKFwiUGFuem9vbS5jbGlja1wiLCB0aGlzLm9uTmF2Q2xpY2spO1xuXG4gICAgdGhpcy50YXJnZXQub24oXCJjaGFuZ2VcIiwgdGhpcy5vblRhcmdldENoYW5nZSk7XG4gICAgdGhpcy50YXJnZXQub24oXCJQYW56b29tLmFmdGVyVXBkYXRlXCIsIHRoaXMub25UYXJnZXRDaGFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgbWFpbiBjYXJvdXNlbCBgcmVhZHlgIGV2ZW50OyBiaW5kIGV2ZW50cyBhbmQgc2V0IGluaXRpYWwgcGFnZVxuICAgKi9cbiAgb25OYXZSZWFkeSgpIHtcbiAgICB0aGlzLm9uVGFyZ2V0Q2hhbmdlKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgbWFpbiBjYXJvdXNlbCBgY2xpY2tgIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYW56b29tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKi9cbiAgb25OYXZDbGljayhjYXJvdXNlbCwgcGFuem9vbSwgZXZlbnQpIHtcbiAgICBjb25zdCBjbGlja2VkTmF2U2xpZGUgPSBldmVudC50YXJnZXQuY2xvc2VzdChcIi5jYXJvdXNlbF9fc2xpZGVcIik7XG5cbiAgICBpZiAoIWNsaWNrZWROYXZTbGlkZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgY29uc3Qgc2VsZWN0ZWROYXZJbmRleCA9IHBhcnNlSW50KGNsaWNrZWROYXZTbGlkZS5kYXRhc2V0LmluZGV4LCAxMCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRTeW5jUGFnZSA9IHRoaXMudGFyZ2V0LmZpbmRQYWdlRm9yU2xpZGUoc2VsZWN0ZWROYXZJbmRleCk7XG5cbiAgICBpZiAodGhpcy50YXJnZXQucGFnZSAhPT0gc2VsZWN0ZWRTeW5jUGFnZSkge1xuICAgICAgdGhpcy50YXJnZXQuc2xpZGVUbyhzZWxlY3RlZFN5bmNQYWdlLCB7IGZyaWN0aW9uOiB0aGlzLmZyaWN0aW9uIH0pO1xuICAgIH1cblxuICAgIHRoaXMubWFya1NlbGVjdGVkU2xpZGUoc2VsZWN0ZWROYXZJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBtYWluIGNhcm91c2VsIGBjcmVhdGVTbGlkZWAgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhcm91c2VsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxuICAgKi9cbiAgb25OYXZDcmVhdGVTbGlkZShjYXJvdXNlbCwgc2xpZGUpIHtcbiAgICBpZiAoc2xpZGUuaW5kZXggPT09IHRoaXMuc2VsZWN0ZWRJbmRleCkge1xuICAgICAgdGhpcy5tYXJrU2VsZWN0ZWRTbGlkZShzbGlkZS5pbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGFyZ2V0IGNhcm91c2VsIGBjaGFuZ2VgIGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICovXG4gIG9uVGFyZ2V0Q2hhbmdlKCkge1xuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy50YXJnZXQucGFnZXNbdGhpcy50YXJnZXQucGFnZV0uaW5kZXhlc1swXTtcbiAgICBjb25zdCBzZWxlY3RlZE5hdlBhZ2UgPSB0aGlzLm5hdi5maW5kUGFnZUZvclNsaWRlKHRhcmdldEluZGV4KTtcblxuICAgIHRoaXMubmF2LnNsaWRlVG8oc2VsZWN0ZWROYXZQYWdlKTtcblxuICAgIHRoaXMubWFya1NlbGVjdGVkU2xpZGUodGFyZ2V0SW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBjbGFzc25hbWUgZm9yIHNsaWRlcyB0aGF0IG1hcmtzIGN1cnJlbnRseSBzZWxlY3RlZCBzbGlkZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNlbGVjdGVkSW5kZXhcbiAgICovXG4gIG1hcmtTZWxlY3RlZFNsaWRlKHNlbGVjdGVkSW5kZXgpIHtcbiAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuXG4gICAgWy4uLnRoaXMubmF2LnNsaWRlc10uZmlsdGVyKChzbGlkZSkgPT4gc2xpZGUuJGVsICYmIHNsaWRlLiRlbC5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtbmF2LXNlbGVjdGVkXCIpKTtcblxuICAgIGNvbnN0IHNsaWRlID0gdGhpcy5uYXYuc2xpZGVzW3NlbGVjdGVkSW5kZXhdO1xuXG4gICAgaWYgKHNsaWRlICYmIHNsaWRlLiRlbCkgc2xpZGUuJGVsLmNsYXNzTGlzdC5hZGQoXCJpcy1uYXYtc2VsZWN0ZWRcIik7XG4gIH1cblxuICBhdHRhY2goY2Fyb3VzZWwpIHtcbiAgICBjb25zdCBzeW5jID0gY2Fyb3VzZWwub3B0aW9ucy5TeW5jO1xuXG4gICAgaWYgKCFzeW5jLnRhcmdldCAmJiAhc3luYy5uYXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3luYy50YXJnZXQpIHtcbiAgICAgIHRoaXMuYWRkQXNOYXZGb3Ioc3luYy50YXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoc3luYy5uYXYpIHtcbiAgICAgIHRoaXMuYWRkQXNUYXJnZXRGb3Ioc3luYy5uYXYpO1xuICAgIH1cblxuICAgIHRoaXMuZnJpY3Rpb24gPSBzeW5jLmZyaWN0aW9uO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIGlmICh0aGlzLm5hdikge1xuICAgICAgdGhpcy5uYXYub2ZmKFwicmVhZHlcIiwgdGhpcy5vbk5hdlJlYWR5KTtcbiAgICAgIHRoaXMubmF2Lm9mZihcIlBhbnpvb20uY2xpY2tcIiwgdGhpcy5vbk5hdkNsaWNrKTtcbiAgICAgIHRoaXMubmF2Lm9mZihcImNyZWF0ZVNsaWRlXCIsIHRoaXMub25OYXZDcmVhdGVTbGlkZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICB0aGlzLnRhcmdldC5vZmYoXCJQYW56b29tLmFmdGVyVXBkYXRlXCIsIHRoaXMub25UYXJnZXRDaGFuZ2UpO1xuICAgICAgdGhpcy50YXJnZXQub2ZmKFwiY2hhbmdlXCIsIHRoaXMub25UYXJnZXRDaGFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvc2UgZGVmYXVsdHNcblN5bmMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiIsImltcG9ydCB7IE5hdmlnYXRpb24gfSBmcm9tIFwiLi9OYXZpZ2F0aW9uL05hdmlnYXRpb24uanNcIjtcbmltcG9ydCB7IERvdHMgfSBmcm9tIFwiLi9Eb3RzL0RvdHMuanNcIjtcbmltcG9ydCB7IFN5bmMgfSBmcm9tIFwiLi9TeW5jL1N5bmMuanNcIjtcblxuZXhwb3J0IGNvbnN0IFBsdWdpbnMgPSB7IE5hdmlnYXRpb24sIERvdHMsIFN5bmMgfTtcbiIsImltcG9ydCB7IGV4dGVuZCB9IGZyb20gXCIuLi9zaGFyZWQvdXRpbHMvZXh0ZW5kLmpzXCI7XG5pbXBvcnQgeyBjYW5Vc2VET00gfSBmcm9tIFwiLi4vc2hhcmVkL3V0aWxzL2NhblVzZURPTS5qc1wiO1xuaW1wb3J0IHsgRk9DVVNBQkxFX0VMRU1FTlRTLCBzZXRGb2N1c09uIH0gZnJvbSBcIi4uL3NoYXJlZC91dGlscy9zZXRGb2N1c09uLmpzXCI7XG5cbmltcG9ydCB7IEJhc2UgfSBmcm9tIFwiLi4vc2hhcmVkL0Jhc2UvQmFzZS5qc1wiO1xuXG5pbXBvcnQgeyBDYXJvdXNlbCB9IGZyb20gXCIuLi9DYXJvdXNlbC9DYXJvdXNlbC5qc1wiO1xuXG5pbXBvcnQgeyBQbHVnaW5zIH0gZnJvbSBcIi4vcGx1Z2lucy9pbmRleC5qc1wiO1xuXG4vLyBEZWZhdWx0IGxhbmd1YWdlXG5pbXBvcnQgZW4gZnJvbSBcIi4vbDEwbi9lbi5qc1wiO1xuXG4vLyBEZWZhdWx0IHNldHRpbmdzXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgLy8gSW5kZXggb2YgYWN0aXZlIHNsaWRlIG9uIHRoZSBzdGFydFxuICBzdGFydEluZGV4OiAwLFxuXG4gIC8vIE51bWJlciBvZiBzbGlkZXMgdG8gcHJlbG9hZCBiZWZvcmUgYW5kIGFmdGVyIGFjdGl2ZSBzbGlkZVxuICBwcmVsb2FkOiAxLFxuXG4gIC8vIFNob3VsZCBuYXZpZ2F0aW9uIGJlIGluZmluaXRlXG4gIGluZmluaXRlOiB0cnVlLFxuXG4gIC8vIENsYXNzIG5hbWUgdG8gYmUgYXBwbGllZCB0byB0aGUgY29udGVudCB0byByZXZlYWwgaXRcbiAgc2hvd0NsYXNzOiBcImZhbmN5Ym94LXpvb21JblVwXCIsIC8vIFwiZmFuY3lib3gtZmFkZUluXCIgfCBcImZhbmN5Ym94LXpvb21JblVwXCIgfCBmYWxzZVxuXG4gIC8vIENsYXNzIG5hbWUgdG8gYmUgYXBwbGllZCB0byB0aGUgY29udGVudCB0byBoaWRlIGl0XG4gIGhpZGVDbGFzczogXCJmYW5jeWJveC1mYWRlT3V0XCIsIC8vIFwiZmFuY3lib3gtZmFkZU91dFwiIHwgXCJmYW5jeWJveC16b29tT3V0RG93blwiIHwgZmFsc2VcblxuICAvLyBTaG91bGQgYmFja2Ryb3AgYW5kIFVJIGVsZW1lbnRzIGZhZGUgaW4vb3V0IG9uIHN0YXJ0L2Nsb3NlXG4gIGFuaW1hdGVkOiB0cnVlLFxuXG4gIC8vIElmIGJyb3dzZXIgc2Nyb2xsYmFyIHNob3VsZCBiZSBoaWRkZW5cbiAgaGlkZVNjcm9sbGJhcjogdHJ1ZSxcblxuICAvLyBFbGVtZW50IGNvbnRhaW5pbmcgbWFpbiBzdHJ1Y3R1cmVcbiAgcGFyZW50RWw6IG51bGwsXG5cbiAgLy8gQ3VzdG9tIGNsYXNzIG5hbWUgb3IgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGNsYXNzIG5hbWVzIGZvciB0aGUgY29udGFpbmVyXG4gIG1haW5DbGFzczogbnVsbCxcblxuICAvLyBTZXQgZm9jdXMgb24gZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgYWZ0ZXIgZGlzcGxheWluZyBjb250ZW50XG4gIGF1dG9Gb2N1czogdHJ1ZSxcblxuICAvLyBUcmFwIGZvY3VzIGluc2lkZSBGYW5jeWJveFxuICB0cmFwRm9jdXM6IHRydWUsXG5cbiAgLy8gU2V0IGZvY3VzIGJhY2sgdG8gdHJpZ2dlciBlbGVtZW50IGFmdGVyIGNsb3NpbmcgRmFuY3lib3hcbiAgcGxhY2VGb2N1c0JhY2s6IHRydWUsXG5cbiAgLy8gQWN0aW9uIHRvIHRha2Ugd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIGJhY2tkcm9wXG4gIGNsaWNrOiBcImNsb3NlXCIsIC8vIFwiY2xvc2VcIiB8IFwibmV4dFwiIHwgbnVsbFxuXG4gIC8vIFBvc2l0aW9uIG9mIHRoZSBjbG9zZSBidXR0b24gLSBvdmVyIHRoZSBjb250ZW50IG9yIGF0IHRvcCByaWdodCBjb3JuZXIgb2Ygdmlld3BvcnRcbiAgY2xvc2VCdXR0b246IFwiaW5zaWRlXCIsIC8vIFwiaW5zaWRlXCIgfCBcIm91dHNpZGVcIlxuXG4gIC8vIEFsbG93IHVzZXIgdG8gZHJhZyBjb250ZW50IHVwL2Rvd24gdG8gY2xvc2UgaW5zdGFuY2VcbiAgZHJhZ1RvQ2xvc2U6IHRydWUsXG5cbiAgLy8gRW5hYmxlIGtleWJvYXJkIG5hdmlnYXRpb25cbiAga2V5Ym9hcmQ6IHtcbiAgICBFc2NhcGU6IFwiY2xvc2VcIixcbiAgICBEZWxldGU6IFwiY2xvc2VcIixcbiAgICBCYWNrc3BhY2U6IFwiY2xvc2VcIixcbiAgICBQYWdlVXA6IFwibmV4dFwiLFxuICAgIFBhZ2VEb3duOiBcInByZXZcIixcbiAgICBBcnJvd1VwOiBcIm5leHRcIixcbiAgICBBcnJvd0Rvd246IFwicHJldlwiLFxuICAgIEFycm93UmlnaHQ6IFwibmV4dFwiLFxuICAgIEFycm93TGVmdDogXCJwcmV2XCIsXG4gIH0sXG5cbiAgLy8gSFRNTCB0ZW1wbGF0ZXMgZm9yIHZhcmlvdXMgZWxlbWVudHNcbiAgdGVtcGxhdGU6IHtcbiAgICAvLyBDbG9zZSBidXR0b24gaWNvblxuICAgIGNsb3NlQnV0dG9uOlxuICAgICAgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiB0YWJpbmRleD1cIi0xXCI+PHBhdGggZD1cIk0yMCAyMEw0IDRtMTYgMEw0IDIwXCIvPjwvc3ZnPicsXG4gICAgLy8gTG9hZGluZyBpbmRpY2F0b3IgaWNvblxuICAgIHNwaW5uZXI6XG4gICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCI1MFwiIGhlaWdodD1cIjUwXCIgdmlld0JveD1cIjI1IDI1IDUwIDUwXCIgdGFiaW5kZXg9XCItMVwiPjxjaXJjbGUgY3g9XCI1MFwiIGN5PVwiNTBcIiByPVwiMjBcIi8+PC9zdmc+JyxcblxuICAgIC8vIE1haW4gY29udGFpbmVyIGVsZW1lbnRcbiAgICBtYWluOiBudWxsLFxuICB9LFxuXG4gIC8qIE5vdGU6IElmIHRoZSBgdGVtcGxhdGUubWFpbmAgb3B0aW9uIGlzIG5vdCBwcm92aWRlZCwgdGhlIHN0cnVjdHVyZSBpcyBnZW5lcmF0ZWQgYXMgZm9sbG93cyBieSBkZWZhdWx0OlxuICA8ZGl2IGNsYXNzPVwiZmFuY3lib3hfX2NvbnRhaW5lclwiIHJvbGU9XCJkaWFsb2dcIiBhcmlhLW1vZGFsPVwidHJ1ZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGFyaWEtbGFiZWw9XCJ7e01PREFMfX1cIiB0YWJpbmRleD1cIi0xXCI+XG4gICAgPGRpdiBjbGFzcz1cImZhbmN5Ym94X19iYWNrZHJvcFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmYW5jeWJveF9fY2Fyb3VzZWxcIj48L2Rpdj5cbiAgPC9kaXY+XG4gICovXG5cbiAgLy8gTG9jYWxpemF0aW9uIG9mIHN0cmluZ3NcbiAgbDEwbjogZW4sXG59O1xuXG4vLyBPYmplY3QgdGhhdCBjb250YWlucyBhbGwgYWN0aXZlIGluc3RhbmNlcyBvZiBGYW5jeWJveFxuY29uc3QgaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuXG4vLyBOdW1iZXIgb2YgRmFuY3lib3ggaW5zdGFuY2VzIGNyZWF0ZWQsIGl0IGlzIHVzZWQgdG8gZ2VuZXJhdGUgbmV3IGluc3RhbmNlIFwiaWRcIlxubGV0IGNhbGxlZCA9IDA7XG5cbmNsYXNzIEZhbmN5Ym94IGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBGYW5jeWJveCBjb25zdHJ1Y3RvclxuICAgKiBAY29uc3RydWN0cyBGYW5jeWJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgRmFuY3lib3hcbiAgICovXG4gIGNvbnN0cnVjdG9yKGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBRdWljayBoYWNrIHRvIGZpeCB2YXJpYWJsZSBuYW1pbmcgY29sbGlzaW9uXG4gICAgaXRlbXMgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLndpZHRoKSBpdGVtLl93aWR0aCA9IGl0ZW0ud2lkdGg7XG4gICAgICBpZiAoaXRlbS5oZWlnaHQpIGl0ZW0uX2hlaWdodCA9IGl0ZW0uaGVpZ2h0O1xuXG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcblxuICAgIHN1cGVyKGV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpKTtcblxuICAgIHRoaXMuYmluZEhhbmRsZXJzKCk7XG5cbiAgICB0aGlzLnN0YXRlID0gXCJpbml0XCI7XG5cbiAgICB0aGlzLnNldEl0ZW1zKGl0ZW1zKTtcblxuICAgIHRoaXMuYXR0YWNoUGx1Z2lucyhGYW5jeWJveC5QbHVnaW5zKTtcblxuICAgIC8vIFwiaW5pdFwiIGV2ZW50IG1hcmtzIHRoZSBzdGFydCBvZiBpbml0aWFsaXphdGlvbiBhbmQgaXMgYXZhaWxhYmxlIHRvIHBsdWdpbnNcbiAgICB0aGlzLnRyaWdnZXIoXCJpbml0XCIpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uKFwiaGlkZVNjcm9sbGJhclwiKSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5oaWRlU2Nyb2xsYmFyKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0TGF5b3V0KCk7XG5cbiAgICB0aGlzLmluaXRDYXJvdXNlbCgpO1xuXG4gICAgdGhpcy5hdHRhY2hFdmVudHMoKTtcblxuICAgIGluc3RhbmNlcy5zZXQodGhpcy5pZCwgdGhpcyk7XG5cbiAgICAvLyBcInByZXBhcmVcIiBldmVudCB3aWxsIHRyaWdnZXIgdGhlIGNyZWF0aW9uIG9mIGFkZGl0aW9uYWwgbGF5b3V0IGVsZW1lbnRzLCBzdWNoIGFzIHRodW1ibmFpbHMgYW5kIHRvb2xiYXJcbiAgICB0aGlzLnRyaWdnZXIoXCJwcmVwYXJlXCIpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFwicmVhZHlcIjtcblxuICAgIC8vIFwicmVhZHlcIiBldmVudCB3aWxsIHRyaWdnZXIgdGhlIGNvbnRlbnQgdG8gbG9hZFxuICAgIHRoaXMudHJpZ2dlcihcInJlYWR5XCIpO1xuXG4gICAgLy8gUmV2ZWFsIGNvbnRhaW5lclxuICAgIHRoaXMuJGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcImZhbHNlXCIpO1xuXG4gICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBpbnNpZGUgdGhpcyBpbnN0YW5jZVxuICAgIGlmICh0aGlzLm9wdGlvbihcInRyYXBGb2N1c1wiKSkge1xuICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSBgb3B0aW9uYCBtZXRob2QgdG8gZ2V0IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgc2xpZGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb3B0aW9uIG5hbWVcbiAgICogQHBhcmFtICB7Li4uYW55fSByZXN0IG9wdGlvbmFsIGV4dHJhIHBhcmFtZXRlcnNcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIG9wdGlvbihuYW1lLCAuLi5yZXN0KSB7XG4gICAgY29uc3Qgc2xpZGUgPSB0aGlzLmdldFNsaWRlKCk7XG5cbiAgICBsZXQgdmFsdWUgPSBzbGlkZSA/IHNsaWRlW25hbWVdIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcywgdGhpcywgLi4ucmVzdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIub3B0aW9uKG5hbWUsIC4uLnJlc3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmQgZXZlbnQgaGFuZGxlcnMgZm9yIHJlZmVyZW5jYWJpbGl0eVxuICAgKi9cbiAgYmluZEhhbmRsZXJzKCkge1xuICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBbXG4gICAgICBcIm9uTW91c2Vkb3duXCIsXG4gICAgICBcIm9uS2V5ZG93blwiLFxuICAgICAgXCJvbkNsaWNrXCIsXG5cbiAgICAgIFwib25Gb2N1c1wiLFxuXG4gICAgICBcIm9uQ3JlYXRlU2xpZGVcIixcbiAgICAgIFwib25TZXR0bGVcIixcblxuICAgICAgXCJvblRvdWNoTW92ZVwiLFxuICAgICAgXCJvblRvdWNoRW5kXCIsXG5cbiAgICAgIFwib25UcmFuc2Zvcm1cIixcbiAgICBdKSB7XG4gICAgICB0aGlzW21ldGhvZE5hbWVdID0gdGhpc1ttZXRob2ROYW1lXS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgYSBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGV2ZW50IGlzIGRlbGl2ZXJlZFxuICAgKi9cbiAgYXR0YWNoRXZlbnRzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5vbk1vdXNlZG93bik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbktleWRvd24sIHRydWUpO1xuXG4gICAgLy8gVHJhcCBrZXlib2FyZCBmb2N1cyBpbnNpZGUgb2YgdGhlIG1vZGFsXG4gICAgaWYgKHRoaXMub3B0aW9uKFwidHJhcEZvY3VzXCIpKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5vbkZvY3VzLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLiRjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25DbGljayk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBkZXRhY2hFdmVudHMoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLm9uTW91c2Vkb3duKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uS2V5ZG93biwgdHJ1ZSk7XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5vbkZvY3VzLCB0cnVlKTtcblxuICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5vbkNsaWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGxheW91dDsgY3JlYXRlIG1haW4gY29udGFpbmVyLCBiYWNrZHJvcCBuZCBsYXlvdXQgZm9yIG1haW4gY2Fyb3VzZWxcbiAgICovXG4gIGluaXRMYXlvdXQoKSB7XG4gICAgdGhpcy4kcm9vdCA9IHRoaXMub3B0aW9uKFwicGFyZW50RWxcIikgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgIC8vIENvbnRhaW5lclxuICAgIGxldCBtYWluVGVtcGxhdGUgPSB0aGlzLm9wdGlvbihcInRlbXBsYXRlLm1haW5cIik7XG5cbiAgICBpZiAobWFpblRlbXBsYXRlKSB7XG4gICAgICB0aGlzLiRyb290Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCB0aGlzLmxvY2FsaXplKG1haW5UZW1wbGF0ZSkpO1xuXG4gICAgICB0aGlzLiRjb250YWluZXIgPSB0aGlzLiRyb290LnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX2NvbnRhaW5lclwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuJGNvbnRhaW5lcikge1xuICAgICAgdGhpcy4kY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuJHJvb3QuYXBwZW5kQ2hpbGQodGhpcy4kY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxseSB3ZSB3b3VsZCBub3QgbmVlZCB0aGlzLCBidXQgU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgYHByZXZlbnRTY3JvbGw6ZmFsc2VgIG9wdGlvbiBmb3IgYGZvY3VzYCBtZXRob2RcbiAgICAvLyBhbmQgdGhhdCBjYXVzZXMgbGF5b3V0IGlzc3Vlc1xuICAgIHRoaXMuJGNvbnRhaW5lci5vbnNjcm9sbCA9ICgpID0+IHtcbiAgICAgIHRoaXMuJGNvbnRhaW5lci5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2NvbnRhaW5lclwiLFxuICAgICAgcm9sZTogXCJkaWFsb2dcIixcbiAgICAgIHRhYkluZGV4OiBcIi0xXCIsXG4gICAgICBcImFyaWEtbW9kYWxcIjogXCJ0cnVlXCIsXG4gICAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMubG9jYWxpemUoXCJ7e01PREFMfX1cIiksXG4gICAgfSkuZm9yRWFjaCgoYXJncykgPT4gdGhpcy4kY29udGFpbmVyLnNldEF0dHJpYnV0ZSguLi5hcmdzKSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb24oXCJhbmltYXRlZFwiKSkge1xuICAgICAgdGhpcy4kY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJpcy1hbmltYXRlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBCYWNrZHJvcFxuICAgIHRoaXMuJGJhY2tkcm9wID0gdGhpcy4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX2JhY2tkcm9wXCIpO1xuXG4gICAgaWYgKCF0aGlzLiRiYWNrZHJvcCkge1xuICAgICAgdGhpcy4kYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4kYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X19iYWNrZHJvcFwiKTtcblxuICAgICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuJGJhY2tkcm9wKTtcbiAgICB9XG5cbiAgICAvLyBDYXJvdXNlbFxuICAgIHRoaXMuJGNhcm91c2VsID0gdGhpcy4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX2Nhcm91c2VsXCIpO1xuXG4gICAgaWYgKCF0aGlzLiRjYXJvdXNlbCkge1xuICAgICAgdGhpcy4kY2Fyb3VzZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4kY2Fyb3VzZWwuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X19jYXJvdXNlbFwiKTtcblxuICAgICAgdGhpcy4kY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuJGNhcm91c2VsKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGluc3RhbmNlIHJlZmVyZW5jZSBhY2Nlc3NpYmxlXG4gICAgdGhpcy4kY29udGFpbmVyLkZhbmN5Ym94ID0gdGhpcztcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgY29udGFpbmVyIGhhcyBhbiBJRFxuICAgIHRoaXMuaWQgPSB0aGlzLiRjb250YWluZXIuZ2V0QXR0cmlidXRlKFwiaWRcIik7XG5cbiAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQgfHwgKytjYWxsZWQ7XG4gICAgICB0aGlzLiRjb250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJmYW5jeWJveC1cIiArIHRoaXMuaWQpO1xuICAgIH1cblxuICAgIC8vIEFkZCBjdXN0b20gY2xhc3MgbmFtZSB0byBtYWluIGVsZW1lbnRcbiAgICBjb25zdCBtYWluQ2xhc3MgPSB0aGlzLm9wdGlvbihcIm1haW5DbGFzc1wiKTtcblxuICAgIGlmIChtYWluQ2xhc3MpIHtcbiAgICAgIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKC4uLm1haW5DbGFzcy5zcGxpdChcIiBcIikpO1xuICAgIH1cblxuICAgIC8vIEFkZCBjbGFzcyBuYW1lIGZvciA8aHRtbD4gZWxlbWVudFxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwid2l0aC1mYW5jeWJveFwiKTtcblxuICAgIHRoaXMudHJpZ2dlcihcImluaXRMYXlvdXRcIik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBzbGlkZXMgZm9yIHRoZSBjb3JvdXNlbFxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFNsaWRlc1xuICAgKi9cbiAgc2V0SXRlbXMoaXRlbXMpIHtcbiAgICBjb25zdCBzbGlkZXMgPSBbXTtcblxuICAgIGZvciAoY29uc3Qgc2xpZGUgb2YgaXRlbXMpIHtcbiAgICAgIGNvbnN0ICR0cmlnZ2VyID0gc2xpZGUuJHRyaWdnZXI7XG5cbiAgICAgIGlmICgkdHJpZ2dlcikge1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gJHRyaWdnZXIuZGF0YXNldCB8fCB7fTtcblxuICAgICAgICBzbGlkZS5zcmMgPSBkYXRhc2V0LnNyYyB8fCAkdHJpZ2dlci5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpIHx8IHNsaWRlLnNyYztcbiAgICAgICAgc2xpZGUudHlwZSA9IGRhdGFzZXQudHlwZSB8fCBzbGlkZS50eXBlO1xuXG4gICAgICAgIC8vIFN1cHBvcnQgaXRlbXMgd2l0aG91dCBgc3JjYCwgZS5nLiwgd2hlbiBgZGF0YS1mYW5jeWJveGAgYXR0cmlidXRlIGFkZGVkIGRpcmVjdGx5IHRvIGA8aW1nPmAgZWxlbWVudFxuICAgICAgICBpZiAoIXNsaWRlLnNyYyAmJiAkdHJpZ2dlciBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICBzbGlkZS5zcmMgPSAkdHJpZ2dlci5jdXJyZW50U3JjIHx8IHNsaWRlLiR0cmlnZ2VyLnNyYztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgdGh1bWJuYWlsIGVsZW1lbnRcbiAgICAgIGxldCAkdGh1bWIgPSBzbGlkZS4kdGh1bWI7XG5cbiAgICAgIGlmICghJHRodW1iKSB7XG4gICAgICAgIGxldCBvcmlnVGFyZ2V0ID0gc2xpZGUuJHRyaWdnZXIgJiYgc2xpZGUuJHRyaWdnZXIub3JpZ1RhcmdldDtcblxuICAgICAgICBpZiAob3JpZ1RhcmdldCkge1xuICAgICAgICAgIGlmIChvcmlnVGFyZ2V0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgICAgJHRodW1iID0gb3JpZ1RhcmdldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHRodW1iID0gb3JpZ1RhcmdldC5xdWVyeVNlbGVjdG9yKFwiaW1nOm5vdChbYXJpYS1oaWRkZW5dKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISR0aHVtYiAmJiBzbGlkZS4kdHJpZ2dlcikge1xuICAgICAgICAgICR0aHVtYiA9XG4gICAgICAgICAgICBzbGlkZS4kdHJpZ2dlciBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnRcbiAgICAgICAgICAgICAgPyBzbGlkZS4kdHJpZ2dlclxuICAgICAgICAgICAgICA6IHNsaWRlLiR0cmlnZ2VyLnF1ZXJ5U2VsZWN0b3IoXCJpbWc6bm90KFthcmlhLWhpZGRlbl0pXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNsaWRlLiR0aHVtYiA9ICR0aHVtYiB8fCBudWxsO1xuXG4gICAgICAvLyBHZXQgdGh1bWJuYWlsIGltYWdlIHNvdXJjZVxuICAgICAgbGV0IHRodW1iID0gc2xpZGUudGh1bWI7XG5cbiAgICAgIGlmICghdGh1bWIgJiYgJHRodW1iKSB7XG4gICAgICAgIHRodW1iID0gJHRodW1iLmN1cnJlbnRTcmMgfHwgJHRodW1iLnNyYztcblxuICAgICAgICBpZiAoIXRodW1iICYmICR0aHVtYi5kYXRhc2V0KSB7XG4gICAgICAgICAgdGh1bWIgPSAkdGh1bWIuZGF0YXNldC5sYXp5U3JjIHx8ICR0aHVtYi5kYXRhc2V0LnNyYztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBc3N1bWUgd2UgaGF2ZSBpbWFnZSwgdGhlbiB1c2UgaXQgYXMgdGh1bWJuYWlsXG4gICAgICBpZiAoIXRodW1iICYmIHNsaWRlLnR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICB0aHVtYiA9IHNsaWRlLnNyYztcbiAgICAgIH1cblxuICAgICAgc2xpZGUudGh1bWIgPSB0aHVtYiB8fCBudWxsO1xuXG4gICAgICAvLyBBZGQgZW1wdHkgY2FwdGlvbiB0byBtYWtlIHRoaW5ncyBzaW1wbGVyXG4gICAgICBzbGlkZS5jYXB0aW9uID0gc2xpZGUuY2FwdGlvbiB8fCBcIlwiO1xuXG4gICAgICBzbGlkZXMucHVzaChzbGlkZSk7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVtcyA9IHNsaWRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIG1haW4gQ2Fyb3VzZWwgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSB0aGUgY29udGVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBzbGlkZXNcbiAgICovXG4gIGluaXRDYXJvdXNlbCgpIHtcbiAgICB0aGlzLkNhcm91c2VsID0gbmV3IENhcm91c2VsKFxuICAgICAgdGhpcy4kY2Fyb3VzZWwsXG4gICAgICBleHRlbmQoXG4gICAgICAgIHRydWUsXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJlZml4OiBcIlwiLFxuXG4gICAgICAgICAgY2xhc3NOYW1lczoge1xuICAgICAgICAgICAgdmlld3BvcnQ6IFwiZmFuY3lib3hfX3ZpZXdwb3J0XCIsXG4gICAgICAgICAgICB0cmFjazogXCJmYW5jeWJveF9fdHJhY2tcIixcbiAgICAgICAgICAgIHNsaWRlOiBcImZhbmN5Ym94X19zbGlkZVwiLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICB0ZXh0U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICAgIHByZWxvYWQ6IHRoaXMub3B0aW9uKFwicHJlbG9hZFwiKSxcblxuICAgICAgICAgIGZyaWN0aW9uOiAwLjg4LFxuXG4gICAgICAgICAgc2xpZGVzOiB0aGlzLml0ZW1zLFxuICAgICAgICAgIGluaXRpYWxQYWdlOiB0aGlzLm9wdGlvbnMuc3RhcnRJbmRleCxcbiAgICAgICAgICBzbGlkZXNQZXJQYWdlOiAxLFxuXG4gICAgICAgICAgaW5maW5pdGVYOiB0aGlzLm9wdGlvbihcImluZmluaXRlXCIpLFxuICAgICAgICAgIGluZmluaXRlWTogdHJ1ZSxcblxuICAgICAgICAgIGwxMG46IHRoaXMub3B0aW9uKFwibDEwblwiKSxcblxuICAgICAgICAgIERvdHM6IGZhbHNlLFxuICAgICAgICAgIE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICAgICAgbWFpbjogXCJmYW5jeWJveF9fbmF2XCIsXG4gICAgICAgICAgICAgIGJ1dHRvbjogXCJjYXJvdXNlbF9fYnV0dG9uXCIsXG5cbiAgICAgICAgICAgICAgbmV4dDogXCJpcy1uZXh0XCIsXG4gICAgICAgICAgICAgIHByZXY6IFwiaXMtcHJldlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgUGFuem9vbToge1xuICAgICAgICAgICAgdGV4dFNlbGVjdGlvbjogdHJ1ZSxcblxuICAgICAgICAgICAgcGFuT25seVpvb21lZDogKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuQ2Fyb3VzZWwgJiYgdGhpcy5DYXJvdXNlbC5wYWdlcyAmJiB0aGlzLkNhcm91c2VsLnBhZ2VzLmxlbmd0aCA8IDIgJiYgIXRoaXMub3B0aW9uKFwiZHJhZ1RvQ2xvc2VcIilcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGxvY2tBeGlzOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLkNhcm91c2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJleiA9IFwieFwiO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uKFwiZHJhZ1RvQ2xvc2VcIikpIHtcbiAgICAgICAgICAgICAgICAgIHJleiArPSBcInlcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV6O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCIqXCI6IChuYW1lLCAuLi5kZXRhaWxzKSA9PiB0aGlzLnRyaWdnZXIoYENhcm91c2VsLiR7bmFtZX1gLCAuLi5kZXRhaWxzKSxcbiAgICAgICAgICAgIGluaXQ6IChjYXJvdXNlbCkgPT4gKHRoaXMuQ2Fyb3VzZWwgPSBjYXJvdXNlbCksXG4gICAgICAgICAgICBjcmVhdGVTbGlkZTogdGhpcy5vbkNyZWF0ZVNsaWRlLFxuICAgICAgICAgICAgc2V0dGxlOiB0aGlzLm9uU2V0dGxlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG5cbiAgICAgICAgdGhpcy5vcHRpb24oXCJDYXJvdXNlbFwiKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBpZiAodGhpcy5vcHRpb24oXCJkcmFnVG9DbG9zZVwiKSkge1xuICAgICAgdGhpcy5DYXJvdXNlbC5QYW56b29tLm9uKHtcbiAgICAgICAgLy8gU3RvcCBmdXJ0aGVyIHRvdWNoIGV2ZW50IGhhbmRsaW5nIGlmIGNvbnRlbnQgaXMgc2NhbGVkXG4gICAgICAgIHRvdWNoTW92ZTogdGhpcy5vblRvdWNoTW92ZSxcblxuICAgICAgICAvLyBVcGRhdGUgYmFja2Ryb3Agb3BhY2l0eSBkZXBlbmRpbmcgb24gdmVydGljYWwgZGlzdGFuY2VcbiAgICAgICAgYWZ0ZXJUcmFuc2Zvcm06IHRoaXMub25UcmFuc2Zvcm0sXG5cbiAgICAgICAgLy8gQ2xvc2UgaW5zdGFuY2UgaWYgZHJhZyBkaXN0YW5jZSBleGNlZWRzIGxpbWl0XG4gICAgICAgIHRvdWNoRW5kOiB0aGlzLm9uVG91Y2hFbmQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJpbml0Q2Fyb3VzZWxcIik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGBjcmVhdGVTbGlkZWAgZXZlbnQgdG8gY3JlYXRlIGNhcHRpb24gZWxlbWVudCBpbnNpZGUgbmV3IHNsaWRlXG4gICAqL1xuICBvbkNyZWF0ZVNsaWRlKGNhcm91c2VsLCBzbGlkZSkge1xuICAgIGxldCBjYXB0aW9uID0gc2xpZGUuY2FwdGlvbiB8fCBcIlwiO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FwdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjYXB0aW9uID0gdGhpcy5vcHRpb25zLmNhcHRpb24uY2FsbCh0aGlzLCB0aGlzLCB0aGlzLkNhcm91c2VsLCBzbGlkZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYXB0aW9uID09PSBcInN0cmluZ1wiICYmIGNhcHRpb24ubGVuZ3RoKSB7XG4gICAgICBjb25zdCAkY2FwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb25zdCBpZCA9IGBmYW5jeWJveF9fY2FwdGlvbl8ke3RoaXMuaWR9XyR7c2xpZGUuaW5kZXh9YDtcblxuICAgICAgJGNhcHRpb24uY2xhc3NOYW1lID0gXCJmYW5jeWJveF9fY2FwdGlvblwiO1xuICAgICAgJGNhcHRpb24uaW5uZXJIVE1MID0gY2FwdGlvbjtcbiAgICAgICRjYXB0aW9uLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcblxuICAgICAgc2xpZGUuJGNhcHRpb24gPSBzbGlkZS4kZWwuYXBwZW5kQ2hpbGQoJGNhcHRpb24pO1xuXG4gICAgICBzbGlkZS4kZWwuY2xhc3NMaXN0LmFkZChcImhhcy1jYXB0aW9uXCIpO1xuICAgICAgc2xpZGUuJGVsLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBDYXJvdXNlbCBgc2V0dGxlYCBldmVudFxuICAgKi9cbiAgb25TZXR0bGUoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9uKFwiYXV0b0ZvY3VzXCIpKSB7XG4gICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBmb2N1cyBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIEZvY3VzIGV2ZW50XG4gICAqL1xuICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzVG9wbW9zdCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mb2N1cyhldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGNsaWNrIGV2ZW50IG9uIHRoZSBjb250YWluZXJcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBDbGljayBldmVudFxuICAgKi9cbiAgb25DbGljayhldmVudCkge1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGV2ZW50VGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG5cbiAgICBpZiAoZXZlbnRUYXJnZXQubWF0Y2hlcyhcIltkYXRhLWZhbmN5Ym94LWNsb3NlXVwiKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIEZhbmN5Ym94LmNsb3NlKGZhbHNlLCBldmVudCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUYXJnZXQubWF0Y2hlcyhcIltkYXRhLWZhbmN5Ym94LW5leHRdXCIpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgRmFuY3lib3gubmV4dCgpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VGFyZ2V0Lm1hdGNoZXMoXCJbZGF0YS1mYW5jeWJveC1wcmV2XVwiKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIEZhbmN5Ym94LnByZXYoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGlmIChhY3RpdmVFbGVtZW50LmNsb3Nlc3QoXCJbY29udGVudGVkaXRhYmxlXVwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZXZlbnRUYXJnZXQubWF0Y2hlcyhGT0NVU0FCTEVfRUxFTUVOVFMpKSB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNraXAgaWYgY2xpY2tlZCBpbnNpZGUgY29udGVudCBhcmVhXG4gICAgaWYgKGV2ZW50VGFyZ2V0LmNsb3Nlc3QoXCIuZmFuY3lib3hfX2NvbnRlbnRcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGlmIHRleHQgaXMgc2VsZWN0ZWRcbiAgICBpZiAoZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50cmlnZ2VyKFwiY2xpY2tcIiwgZXZlbnQpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMub3B0aW9uKFwiY2xpY2tcIik7XG5cbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmV4dFwiOlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBwYW56b29tIGB0b3VjaE1vdmVgIGV2ZW50OyBEaXNhYmxlIGRyYWdnaW5nIGlmIGNvbnRlbnQgb2YgY3VycmVudCBzbGlkZSBpcyBzY2FsZWRcbiAgICovXG4gIG9uVG91Y2hNb3ZlKCkge1xuICAgIGNvbnN0IHBhbnpvb20gPSB0aGlzLmdldFNsaWRlKCkuUGFuem9vbTtcblxuICAgIHJldHVybiBwYW56b29tICYmIHBhbnpvb20uY29udGVudC5zY2FsZSAhPT0gMSA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcGFuem9vbSBgdG91Y2hFbmRgIGV2ZW50OyBjbG9zZSB3aGVuIHF1aWNrIGZsaWNrIHVwL2Rvd24gaXMgZGV0ZWN0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhbnpvb20gLSBQYW56b29tIGluc3RhbmNlXG4gICAqL1xuICBvblRvdWNoRW5kKHBhbnpvb20pIHtcbiAgICBjb25zdCBkaXN0YW5jZVkgPSBwYW56b29tLmRyYWdPZmZzZXQueTtcblxuICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVkpID49IDE1MCB8fCAoTWF0aC5hYnMoZGlzdGFuY2VZKSA+PSAzNSAmJiBwYW56b29tLmRyYWdPZmZzZXQudGltZSA8IDM1MCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbihcImhpZGVDbGFzc1wiKSkge1xuICAgICAgICB0aGlzLmdldFNsaWRlKCkuaGlkZUNsYXNzID0gYGZhbmN5Ym94LXRocm93T3V0JHtwYW56b29tLmNvbnRlbnQueSA8IDAgPyBcIlVwXCIgOiBcIkRvd25cIn1gO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChwYW56b29tLmxvY2tBeGlzID09PSBcInlcIikge1xuICAgICAgcGFuem9vbS5wYW5Ubyh7IHk6IDAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgYWZ0ZXJUcmFuc2Zvcm1gIGV2ZW50OyBjaGFuZ2UgYmFja2Ryb3Agb3BhY2l0eSBiYXNlZCBvbiBjdXJyZW50IHkgcG9zaXRpb24gb2YgcGFuem9vbVxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFuem9vbSAtIFBhbnpvb20gaW5zdGFuY2VcbiAgICovXG4gIG9uVHJhbnNmb3JtKHBhbnpvb20pIHtcbiAgICBjb25zdCAkYmFja2Ryb3AgPSB0aGlzLiRiYWNrZHJvcDtcblxuICAgIGlmICgkYmFja2Ryb3ApIHtcbiAgICAgIGNvbnN0IHlQb3MgPSBNYXRoLmFicyhwYW56b29tLmNvbnRlbnQueSk7XG4gICAgICBjb25zdCBvcGFjaXR5ID0geVBvcyA8IDEgPyBcIlwiIDogTWF0aC5tYXgoMC4zMywgTWF0aC5taW4oMSwgMSAtICh5UG9zIC8gcGFuem9vbS5jb250ZW50LmZpdEhlaWdodCkgKiAxLjUpKTtcblxuICAgICAgdGhpcy4kY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KFwiLS1mYW5jeWJveC10c1wiLCBvcGFjaXR5ID8gXCIwc1wiIDogXCJcIik7XG4gICAgICB0aGlzLiRjb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoXCItLWZhbmN5Ym94LW9wYWNpdHlcIiwgb3BhY2l0eSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBldmVudCB0byBtYXJrIHRoYXQgdGhlIG1vdXNlIGlzIGluIHVzZVxuICAgKi9cbiAgb25Nb3VzZWRvd24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwicmVhZHlcIikge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiaXMtdXNpbmctbW91c2VcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBga2V5ZG93bmAgZXZlbnQ7IHRyYXAgZm9jdXNcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgS2V5ZG93biBldmVudFxuICAgKi9cbiAgb25LZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzVG9wbW9zdCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtdXNpbmctbW91c2VcIik7XG5cbiAgICBjb25zdCBrZXkgPSBldmVudC5rZXk7XG4gICAgY29uc3Qga2V5Ym9hcmQgPSB0aGlzLm9wdGlvbihcImtleWJvYXJkXCIpO1xuXG4gICAgaWYgKCFrZXlib2FyZCB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuXG4gICAgY29uc3QgY2xhc3NMaXN0ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsYXNzTGlzdDtcbiAgICBjb25zdCBpc1VJRWxlbWVudCA9IGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29udGFpbnMoXCJjYXJvdXNlbF9fYnV0dG9uXCIpO1xuXG4gICAgLy8gQWxsb3cgdG8gY2xvc2UgdXNpbmcgRXNjYXBlIGJ1dHRvblxuICAgIGlmIChrZXkgIT09IFwiRXNjYXBlXCIgJiYgIWlzVUlFbGVtZW50KSB7XG4gICAgICBsZXQgaWdub3JlRWxlbWVudHMgPVxuICAgICAgICBldmVudC50YXJnZXQuaXNDb250ZW50RWRpdGFibGUgfHxcbiAgICAgICAgW1wiQlVUVE9OXCIsIFwiVEVYVEFSRUFcIiwgXCJPUFRJT05cIiwgXCJJTlBVVFwiLCBcIlNFTEVDVFwiLCBcIlZJREVPXCJdLmluZGV4T2YodGFyZ2V0Lm5vZGVOYW1lKSAhPT0gLTE7XG5cbiAgICAgIGlmIChpZ25vcmVFbGVtZW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJpZ2dlcihcImtleWRvd25cIiwga2V5LCBldmVudCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aW9uID0ga2V5Ym9hcmRba2V5XTtcblxuICAgIGlmICh0eXBlb2YgdGhpc1thY3Rpb25dID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXNbYWN0aW9uXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFjdGl2ZSBzbGlkZS4gVGhpcyB3aWxsIGJlIHRoZSBmaXJzdCBzbGlkZSBmcm9tIHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhlIG1haW4gY2Fyb3VzZWwuXG4gICAqL1xuICBnZXRTbGlkZSgpIHtcbiAgICBjb25zdCBjYXJvdXNlbCA9IHRoaXMuQ2Fyb3VzZWw7XG5cbiAgICBpZiAoIWNhcm91c2VsKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHBhZ2UgPSBjYXJvdXNlbC5wYWdlID09PSBudWxsID8gY2Fyb3VzZWwub3B0aW9uKFwiaW5pdGlhbFBhZ2VcIikgOiBjYXJvdXNlbC5wYWdlO1xuICAgIGNvbnN0IHBhZ2VzID0gY2Fyb3VzZWwucGFnZXMgfHwgW107XG5cbiAgICBpZiAocGFnZXMubGVuZ3RoICYmIHBhZ2VzW3BhZ2VdKSB7XG4gICAgICByZXR1cm4gcGFnZXNbcGFnZV0uc2xpZGVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsYWNlIGZvY3VzIG9uIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBpbnNpZGUgY3VycmVudCBzbGlkZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZlbnRdIC0gRm9jdXMgZXZlbnRcbiAgICovXG4gIGZvY3VzKGV2ZW50KSB7XG4gICAgaWYgKEZhbmN5Ym94Lmlnbm9yZUZvY3VzQ2hhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFtcImluaXRcIiwgXCJjbG9zaW5nXCIsIFwiY3VzdG9tQ2xvc2luZ1wiLCBcImRlc3Ryb3lcIl0uaW5kZXhPZih0aGlzLnN0YXRlKSA+IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgJGNvbnRhaW5lciA9IHRoaXMuJGNvbnRhaW5lcjtcbiAgICBjb25zdCBjdXJyZW50U2xpZGUgPSB0aGlzLmdldFNsaWRlKCk7XG4gICAgY29uc3QgJGN1cnJlbnRTbGlkZSA9IGN1cnJlbnRTbGlkZS5zdGF0ZSA9PT0gXCJkb25lXCIgPyBjdXJyZW50U2xpZGUuJGVsIDogbnVsbDtcblxuICAgIC8vIFNraXAgaWYgdGhlIERPTSBlbGVtZW50IHRoYXQgaXMgY3VycmVudGx5IGluIGZvY3VzIGlzIGFscmVhZHkgaW5zaWRlIHRoZSBjdXJyZW50IHNsaWRlXG4gICAgaWYgKCRjdXJyZW50U2xpZGUgJiYgJGN1cnJlbnRTbGlkZS5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBGYW5jeWJveC5pZ25vcmVGb2N1c0NoYW5nZSA9IHRydWU7XG5cbiAgICBjb25zdCBhbGxGb2N1c2FibGVFbGVtcyA9IEFycmF5LmZyb20oJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKEZPQ1VTQUJMRV9FTEVNRU5UUykpO1xuXG4gICAgbGV0IGVuYWJsZWRFbGVtcyA9IFtdO1xuICAgIGxldCAkZmlyc3RFbDtcblxuICAgIGZvciAobGV0IG5vZGUgb2YgYWxsRm9jdXNhYmxlRWxlbXMpIHtcbiAgICAgIC8vIEVuYWJsZSBlbGVtZW50IGlmIGl0J3MgdmlzaWJsZSBhbmRcbiAgICAgIC8vIGlzIGluc2lkZSB0aGUgY3VycmVudCBzbGlkZSBvciBpcyBvdXRzaWRlIG1haW4gY2Fyb3VzZWwgKGZvciBleGFtcGxlLCBpbnNpZGUgdGhlIHRvb2xiYXIpXG4gICAgICBjb25zdCBpc05vZGVWaXNpYmxlID0gbm9kZS5vZmZzZXRQYXJlbnQ7XG4gICAgICBjb25zdCBpc05vZGVJbnNpZGVDdXJyZW50U2xpZGUgPSAkY3VycmVudFNsaWRlICYmICRjdXJyZW50U2xpZGUuY29udGFpbnMobm9kZSk7XG4gICAgICBjb25zdCBpc05vZGVPdXRzaWRlQ2Fyb3VzZWwgPSAhdGhpcy5DYXJvdXNlbC4kdmlld3BvcnQuY29udGFpbnMobm9kZSk7XG5cbiAgICAgIGlmIChpc05vZGVWaXNpYmxlICYmIChpc05vZGVJbnNpZGVDdXJyZW50U2xpZGUgfHwgaXNOb2RlT3V0c2lkZUNhcm91c2VsKSkge1xuICAgICAgICBlbmFibGVkRWxlbXMucHVzaChub2RlKTtcblxuICAgICAgICBpZiAobm9kZS5kYXRhc2V0Lm9yaWdUYWJpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS50YWJJbmRleCA9IG5vZGUuZGF0YXNldC5vcmlnVGFiaW5kZXg7XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLW9yaWctdGFiaW5kZXhcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgbm9kZS5oYXNBdHRyaWJ1dGUoXCJhdXRvRm9jdXNcIikgfHxcbiAgICAgICAgICAoISRmaXJzdEVsICYmIGlzTm9kZUluc2lkZUN1cnJlbnRTbGlkZSAmJiAhbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoXCJjYXJvdXNlbF9fYnV0dG9uXCIpKVxuICAgICAgICApIHtcbiAgICAgICAgICAkZmlyc3RFbCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVsZW1lbnQgaXMgZWl0aGVyIGhpZGRlbiBvciBpcyBpbnNpZGUgcHJlbG9hZGVkIHNsaWRlIChlLmcuLCBub3QgaW5zaWRlIGN1cnJlbnQgc2xpZGUsIGJ1dCBuZXh0L3ByZXYpXG4gICAgICAgIG5vZGUuZGF0YXNldC5vcmlnVGFiaW5kZXggPVxuICAgICAgICAgIG5vZGUuZGF0YXNldC5vcmlnVGFiaW5kZXggPT09IHVuZGVmaW5lZCA/IG5vZGUuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgOiBub2RlLmRhdGFzZXQub3JpZ1RhYmluZGV4O1xuXG4gICAgICAgIG5vZGUudGFiSW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb24oXCJhdXRvRm9jdXNcIikgJiYgJGZpcnN0RWwpIHtcbiAgICAgICAgc2V0Rm9jdXNPbigkZmlyc3RFbCk7XG4gICAgICB9IGVsc2UgaWYgKGVuYWJsZWRFbGVtcy5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIDwgMCkge1xuICAgICAgICBzZXRGb2N1c09uKCRjb250YWluZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZW5hYmxlZEVsZW1zLmluZGV4T2YoZXZlbnQudGFyZ2V0KSA+IC0xKSB7XG4gICAgICAgIHRoaXMubGFzdEZvY3VzID0gZXZlbnQudGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEZvY3VzID09PSAkY29udGFpbmVyKSB7XG4gICAgICAgICAgc2V0Rm9jdXNPbihlbmFibGVkRWxlbXNbZW5hYmxlZEVsZW1zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRGb2N1c09uKCRjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Rm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgRmFuY3lib3guaWdub3JlRm9jdXNDaGFuZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHZlcnRpY2FsIHBhZ2Ugc2Nyb2xsYmFyIGFuZCBhZGp1c3QgcmlnaHQgcGFkZGluZyB2YWx1ZSBvZiBgYm9keWAgZWxlbWVudCB0byBwcmV2ZW50IGNvbnRlbnQgZnJvbSBzaGlmdGluZ1xuICAgKiAob3RoZXJ3aXNlIHRoZSBgYm9keWAgZWxlbWVudCBtYXkgYmVjb21lIHdpZGVyIGFuZCB0aGUgY29udGVudCBtYXkgZXhwYW5kIGhvcml6b250YWxseSkuXG4gICAqL1xuICBoaWRlU2Nyb2xsYmFyKCkge1xuICAgIGlmICghY2FuVXNlRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICBjb25zdCBpZCA9IFwiZmFuY3lib3gtc3R5bGUtbm9zY3JvbGxcIjtcblxuICAgIGxldCAkc3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICBpZiAoJHN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbGJhcldpZHRoID4gMCkge1xuICAgICAgJHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG4gICAgICAkc3R5bGUuaWQgPSBpZDtcbiAgICAgICRzdHlsZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgJHN0eWxlLmlubmVySFRNTCA9IGAuY29tcGVuc2F0ZS1mb3Itc2Nyb2xsYmFyIHtwYWRkaW5nLXJpZ2h0OiAke3Njcm9sbGJhcldpZHRofXB4O31gO1xuXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoJHN0eWxlKTtcblxuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiY29tcGVuc2F0ZS1mb3Itc2Nyb2xsYmFyXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGhpZGluZyB2ZXJ0aWNhbCBwYWdlIHNjcm9sbGJhclxuICAgKi9cbiAgcmV2ZWFsU2Nyb2xsYmFyKCkge1xuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImNvbXBlbnNhdGUtZm9yLXNjcm9sbGJhclwiKTtcblxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmYW5jeWJveC1zdHlsZS1ub3Njcm9sbFwiKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgZWwucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjb250ZW50IGZvciBnaXZlbiBzbGlkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGUgLSBDYXJvdXNlbCBzbGlkZVxuICAgKi9cbiAgY2xlYXJDb250ZW50KHNsaWRlKSB7XG4gICAgLy8gKiBDbGVhciBwcmV2aW91c2x5IGFkZGVkIGNvbnRlbnQgYW5kIGNsYXNzIG5hbWVcbiAgICB0aGlzLkNhcm91c2VsLnRyaWdnZXIoXCJyZW1vdmVTbGlkZVwiLCBzbGlkZSk7XG5cbiAgICBpZiAoc2xpZGUuJGNvbnRlbnQpIHtcbiAgICAgIHNsaWRlLiRjb250ZW50LnJlbW92ZSgpO1xuICAgICAgc2xpZGUuJGNvbnRlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChzbGlkZS4kY2xvc2VCdXR0b24pIHtcbiAgICAgIHNsaWRlLiRjbG9zZUJ1dHRvbi5yZW1vdmUoKTtcbiAgICAgIHNsaWRlLiRjbG9zZUJ1dHRvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHNsaWRlLl9jbGFzc05hbWUpIHtcbiAgICAgIHNsaWRlLiRlbC5jbGFzc0xpc3QucmVtb3ZlKHNsaWRlLl9jbGFzc05hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IGNvbnRlbnQgZm9yIGdpdmVuIHNsaWRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZSAtIENhcm91c2VsIHNsaWRlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBodG1sIC0gSFRNTCBlbGVtZW50IG9yIHN0cmluZyBjb250YWluaW5nIEhUTUwgY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uc1xuICAgKi9cbiAgc2V0Q29udGVudChzbGlkZSwgaHRtbCwgb3B0cyA9IHt9KSB7XG4gICAgbGV0ICRjb250ZW50O1xuXG4gICAgY29uc3QgJGVsID0gc2xpZGUuJGVsO1xuXG4gICAgaWYgKGh0bWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgaWYgKFtcImltZ1wiLCBcImlmcmFtZVwiLCBcInZpZGVvXCIsIFwiYXVkaW9cIl0uaW5kZXhPZihodG1sLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcbiAgICAgICAgJGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAkY29udGVudC5hcHBlbmRDaGlsZChodG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRjb250ZW50ID0gaHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgJGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoaHRtbCk7XG5cbiAgICAgICRjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICRjb250ZW50LmFwcGVuZENoaWxkKCRmcmFnbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHNsaWRlLmZpbHRlciAmJiAhc2xpZGUuZXJyb3IpIHtcbiAgICAgICRjb250ZW50ID0gJGNvbnRlbnQucXVlcnlTZWxlY3RvcihzbGlkZS5maWx0ZXIpO1xuICAgIH1cblxuICAgIGlmICghKCRjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuc2V0RXJyb3Ioc2xpZGUsIFwie3tFTEVNRU5UX05PVF9GT1VORH19XCIpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gKiBBZGQgY2xhc3MgbmFtZSBpbmRpY2F0aW5nIGNvbnRlbnQgdHlwZSwgZm9yIGV4YW1wbGUgYGhhcy1pbWFnZWBcbiAgICBzbGlkZS5fY2xhc3NOYW1lID0gYGhhcy0ke29wdHMuc3VmZml4IHx8IHNsaWRlLnR5cGUgfHwgXCJ1bmtub3duXCJ9YDtcblxuICAgICRlbC5jbGFzc0xpc3QuYWRkKHNsaWRlLl9jbGFzc05hbWUpO1xuXG4gICAgLy8gKiBTZXQgY29udGVudFxuICAgICRjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fY29udGVudFwiKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGNvbnRlbnQgaXMgbm90IGhpZGRlbiBhbmQgd2lsbCBiZSB2aXNpYmxlXG4gICAgaWYgKCRjb250ZW50LnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGdldENvbXB1dGVkU3R5bGUoJGNvbnRlbnQpLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIikge1xuICAgICAgJGNvbnRlbnQuc3R5bGUuZGlzcGxheSA9IHNsaWRlLmRpc3BsYXkgfHwgdGhpcy5vcHRpb24oXCJkZWZhdWx0RGlzcGxheVwiKSB8fCBcImZsZXhcIjtcbiAgICB9XG5cbiAgICBpZiAoc2xpZGUuaWQpIHtcbiAgICAgICRjb250ZW50LnNldEF0dHJpYnV0ZShcImlkXCIsIHNsaWRlLmlkKTtcbiAgICB9XG5cbiAgICBzbGlkZS4kY29udGVudCA9ICRjb250ZW50O1xuXG4gICAgJGVsLnByZXBlbmQoJGNvbnRlbnQpO1xuXG4gICAgdGhpcy5tYW5hZ2VDbG9zZUJ1dHRvbihzbGlkZSk7XG5cbiAgICBpZiAoc2xpZGUuc3RhdGUgIT09IFwibG9hZGluZ1wiKSB7XG4gICAgICB0aGlzLnJldmVhbENvbnRlbnQoc2xpZGUpO1xuICAgIH1cblxuICAgIHJldHVybiAkY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgY2xvc2UgYnV0dG9uIGlmIG5lZWRlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGVcbiAgICovXG4gIG1hbmFnZUNsb3NlQnV0dG9uKHNsaWRlKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBzbGlkZS5jbG9zZUJ1dHRvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb24oXCJjbG9zZUJ1dHRvblwiKSA6IHNsaWRlLmNsb3NlQnV0dG9uO1xuXG4gICAgaWYgKCFwb3NpdGlvbiB8fCAocG9zaXRpb24gPT09IFwidG9wXCIgJiYgdGhpcy4kY2xvc2VCdXR0b24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgJGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG5cbiAgICAkYnRuLmNsYXNzTGlzdC5hZGQoXCJjYXJvdXNlbF9fYnV0dG9uXCIsIFwiaXMtY2xvc2VcIik7XG4gICAgJGJ0bi5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLCB0aGlzLm9wdGlvbnMubDEwbi5DTE9TRSk7XG4gICAgJGJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbihcInRlbXBsYXRlLmNsb3NlQnV0dG9uXCIpO1xuXG4gICAgJGJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHRoaXMuY2xvc2UoZSkpO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSBcImluc2lkZVwiKSB7XG4gICAgICAvLyBSZW1vdmUgZXhpc3Rpbmcgb25lIHRvIGF2b2lkIHNjb3BlIGlzc3Vlc1xuICAgICAgaWYgKHNsaWRlLiRjbG9zZUJ1dHRvbikge1xuICAgICAgICBzbGlkZS4kY2xvc2VCdXR0b24ucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHNsaWRlLiRjbG9zZUJ1dHRvbiA9IHNsaWRlLiRjb250ZW50LmFwcGVuZENoaWxkKCRidG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRjbG9zZUJ1dHRvbiA9IHRoaXMuJGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoJGJ0biwgdGhpcy4kY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGNvbnRlbnQgdmlzaWJsZSBmb3IgZ2l2ZW4gc2xpZGUgYW5kIG9wdGlvbmFsbHkgc3RhcnQgQ1NTIGFuaW1hdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGUgLSBDYXJvdXNlbCBzbGlkZVxuICAgKi9cbiAgcmV2ZWFsQ29udGVudChzbGlkZSkge1xuICAgIHRoaXMudHJpZ2dlcihcInJldmVhbFwiLCBzbGlkZSk7XG5cbiAgICBzbGlkZS4kY29udGVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcblxuICAgIC8vIEFkZCBDU1MgY2xhc3MgbmFtZSB0aGF0IHJldmVhbHMgY29udGVudCAoZGVmYXVsdCBhbmltYXRpb24gaXMgXCJmYWRlSW5cIilcbiAgICBsZXQgc2hvd0NsYXNzID0gZmFsc2U7XG5cbiAgICBpZiAoXG4gICAgICAhKFxuICAgICAgICBzbGlkZS5lcnJvciB8fFxuICAgICAgICBzbGlkZS5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgfHxcbiAgICAgICAgdGhpcy5DYXJvdXNlbC5wcmV2UGFnZSAhPT0gbnVsbCB8fFxuICAgICAgICBzbGlkZS5pbmRleCAhPT0gdGhpcy5vcHRpb25zLnN0YXJ0SW5kZXhcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHNob3dDbGFzcyA9IHNsaWRlLnNob3dDbGFzcyA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb24oXCJzaG93Q2xhc3NcIikgOiBzbGlkZS5zaG93Q2xhc3M7XG4gICAgfVxuXG4gICAgaWYgKCFzaG93Q2xhc3MpIHtcbiAgICAgIHRoaXMuZG9uZShzbGlkZSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzbGlkZS5zdGF0ZSA9IFwiYW5pbWF0aW5nXCI7XG5cbiAgICB0aGlzLmFuaW1hdGVDU1Moc2xpZGUuJGNvbnRlbnQsIHNob3dDbGFzcywgKCkgPT4ge1xuICAgICAgdGhpcy5kb25lKHNsaWRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgY2xhc3MgbmFtZSB0byBnaXZlbiBIVE1MIGVsZW1lbnQgYW5kIHdhaXQgZm9yIGBhbmltYXRpb25lbmRgIGV2ZW50IHRvIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJGVsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1blxuICAgKi9cbiAgYW5pbWF0ZUNTUygkZWxlbWVudCwgY2xhc3NOYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICgkZWxlbWVudCkge1xuICAgICAgJGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJhbmltYXRpb25lbmRcIiwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoISRlbGVtZW50IHx8ICFjbGFzc05hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldCA9PT0gdGhpcykge1xuICAgICAgICAkZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIGhhbmRsZUFuaW1hdGlvbkVuZCk7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBoYW5kbGVBbmltYXRpb25FbmQpO1xuICAgICRlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIGdpdmVuIHNsaWRlIGFzIGBkb25lYCwgZS5nLiwgY29udGVudCBpcyBsb2FkZWQgYW5kIGRpc3BsYXllZCBjb21wbGV0ZWx5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZSAtIENhcm91c2VsIHNsaWRlXG4gICAqL1xuICBkb25lKHNsaWRlKSB7XG4gICAgc2xpZGUuc3RhdGUgPSBcImRvbmVcIjtcblxuICAgIHRoaXMudHJpZ2dlcihcImRvbmVcIiwgc2xpZGUpO1xuXG4gICAgLy8gVHJpZ2dlciBmb2N1cyBmb3IgY3VycmVudCBzbGlkZSAoYW5kIGlnbm9yZSBwcmVsb2FkZWQgc2xpZGVzKVxuICAgIGNvbnN0IGN1cnJlbnRTbGlkZSA9IHRoaXMuZ2V0U2xpZGUoKTtcblxuICAgIGlmIChjdXJyZW50U2xpZGUgJiYgc2xpZGUuaW5kZXggPT09IGN1cnJlbnRTbGlkZS5pbmRleCAmJiB0aGlzLm9wdGlvbihcImF1dG9Gb2N1c1wiKSkge1xuICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZXJyb3IgbWVzc2FnZSBhcyBzbGlkZSBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZSAtIENhcm91c2VsIHNsaWRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSwgY2FuIGNvbnRhaW4gSFRNTCBjb2RlIGFuZCB0ZW1wbGF0ZSB2YXJpYWJsZXNcbiAgICovXG4gIHNldEVycm9yKHNsaWRlLCBtZXNzYWdlKSB7XG4gICAgc2xpZGUuZXJyb3IgPSBtZXNzYWdlO1xuXG4gICAgdGhpcy5oaWRlTG9hZGluZyhzbGlkZSk7XG4gICAgdGhpcy5jbGVhckNvbnRlbnQoc2xpZGUpO1xuXG4gICAgLy8gQ3JlYXRlIG5ldyBjb250ZW50XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94LWVycm9yXCIpO1xuICAgIGRpdi5pbm5lckhUTUwgPSB0aGlzLmxvY2FsaXplKG1lc3NhZ2UgfHwgXCI8cD57e0VSUk9SfX08L3A+XCIpO1xuXG4gICAgdGhpcy5zZXRDb250ZW50KHNsaWRlLCBkaXYsIHsgc3VmZml4OiBcImVycm9yXCIgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGxvYWRpbmcgaW5kaWNhdG9yIGluc2lkZSBnaXZlbiBzbGlkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGUgLSBDYXJvdXNlbCBzbGlkZVxuICAgKi9cbiAgc2hvd0xvYWRpbmcoc2xpZGUpIHtcbiAgICBzbGlkZS5zdGF0ZSA9IFwibG9hZGluZ1wiO1xuXG4gICAgc2xpZGUuJGVsLmNsYXNzTGlzdC5hZGQoXCJpcy1sb2FkaW5nXCIpO1xuXG4gICAgbGV0ICRzcGlubmVyID0gc2xpZGUuJGVsLnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX3NwaW5uZXJcIik7XG5cbiAgICBpZiAoJHNwaW5uZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAkc3Bpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAkc3Bpbm5lci5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX3NwaW5uZXJcIik7XG4gICAgJHNwaW5uZXIuaW5uZXJIVE1MID0gdGhpcy5vcHRpb24oXCJ0ZW1wbGF0ZS5zcGlubmVyXCIpO1xuXG4gICAgJHNwaW5uZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5DYXJvdXNlbC5QYW56b29tLnZlbG9jaXR5KSB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBzbGlkZS4kZWwucHJlcGVuZCgkc3Bpbm5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGxvYWRpbmcgaW5kaWNhdG9yIGZyb20gZ2l2ZW4gc2xpZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlIC0gQ2Fyb3VzZWwgc2xpZGVcbiAgICovXG4gIGhpZGVMb2FkaW5nKHNsaWRlKSB7XG4gICAgY29uc3QgJHNwaW5uZXIgPSBzbGlkZS4kZWwgJiYgc2xpZGUuJGVsLnF1ZXJ5U2VsZWN0b3IoXCIuZmFuY3lib3hfX3NwaW5uZXJcIik7XG5cbiAgICBpZiAoJHNwaW5uZXIpIHtcbiAgICAgICRzcGlubmVyLnJlbW92ZSgpO1xuXG4gICAgICBzbGlkZS4kZWwuY2xhc3NMaXN0LnJlbW92ZShcImlzLWxvYWRpbmdcIik7XG4gICAgfVxuXG4gICAgaWYgKHNsaWRlLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgdGhpcy50cmlnZ2VyKFwibG9hZFwiLCBzbGlkZSk7XG5cbiAgICAgIHNsaWRlLnN0YXRlID0gXCJyZWFkeVwiO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbGlkZSBjYXJvdXNlbCB0byBuZXh0IHBhZ2VcbiAgICovXG4gIG5leHQoKSB7XG4gICAgY29uc3QgY2Fyb3VzZWwgPSB0aGlzLkNhcm91c2VsO1xuXG4gICAgaWYgKGNhcm91c2VsICYmIGNhcm91c2VsLnBhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNhcm91c2VsLnNsaWRlTmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbGlkZSBjYXJvdXNlbCB0byBwcmV2aW91cyBwYWdlXG4gICAqL1xuICBwcmV2KCkge1xuICAgIGNvbnN0IGNhcm91c2VsID0gdGhpcy5DYXJvdXNlbDtcblxuICAgIGlmIChjYXJvdXNlbCAmJiBjYXJvdXNlbC5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICBjYXJvdXNlbC5zbGlkZVByZXYoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2xpZGUgY2Fyb3VzZWwgdG8gc2VsZWN0ZWQgcGFnZSB3aXRoIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogRXhhbXBsZXM6XG4gICAqICAgIEZhbmN5Ym94LmdldEluc3RhbmNlKCkuanVtcFRvKDIpO1xuICAgKiAgICBGYW5jeWJveC5nZXRJbnN0YW5jZSgpLmp1bXBUbygzLCB7ZnJpY3Rpb246IDB9KVxuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBBcmd1bWVudHMgZm9yIENhcm91c2VsIGBzbGlkZVRvYCBtZXRob2RcbiAgICovXG4gIGp1bXBUbyguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMuQ2Fyb3VzZWwpIHRoaXMuQ2Fyb3VzZWwuc2xpZGVUbyguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBjdXJyZW50IGluc3RhbmNlIGlzIHRyeWluZyB0byBjbG9zZSBvciBpcyBhbHJlYWR5IGNsb3NlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQ2xvc2luZygpIHtcbiAgICByZXR1cm4gW1wiY2xvc2luZ1wiLCBcImN1c3RvbUNsb3NpbmdcIiwgXCJkZXN0cm95XCJdLmluY2x1ZGVzKHRoaXMuc3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGluc3RhbmNlIGlzIG5vdCBibG9ja2VkIGJ5IGFub3RoZXIgaW5zdGFuY2VcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc1RvcG1vc3QoKSB7XG4gICAgcmV0dXJuIEZhbmN5Ym94LmdldEluc3RhbmNlKCkuaWQgPT0gdGhpcy5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBjbG9zaW5nIHRoZSBjdXJyZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7RXZlbnR9IFtldmVudF0gLSBPcHRpb25hbCBjbGljayBldmVudFxuICAgKi9cbiAgY2xvc2UoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBGaXJzdCwgc3RvcCBmdXJ0aGVyIGV4ZWN1dGlvbiBpZiB0aGlzIGluc3RhbmNlIGlzIGFscmVhZHkgY2xvc2luZ1xuICAgIC8vICh0aGlzIGNhbiBoYXBwZW4gaWYsIGZvciBleGFtcGxlLCB1c2VyIGNsaWNrcyBjbG9zZSBidXR0b24gbXVsdGlwbGUgdGltZXMgcmVhbGx5IGZhc3QpXG4gICAgaWYgKHRoaXMuaXNDbG9zaW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBjYWxsYmFja3MgYW5kL29yIHBsdWdpbnMgdG8gcHJldmVudCBjbG9zaW5nXG4gICAgaWYgKHRoaXMudHJpZ2dlcihcInNob3VsZENsb3NlXCIsIGV2ZW50KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gXCJjbG9zaW5nXCI7XG5cbiAgICB0aGlzLkNhcm91c2VsLlBhbnpvb20uZGVzdHJveSgpO1xuXG4gICAgdGhpcy5kZXRhY2hFdmVudHMoKTtcblxuICAgIHRoaXMudHJpZ2dlcihcImNsb3NpbmdcIiwgZXZlbnQpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZGVzdHJveVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBkZWZhdWx0IENTUyBjbG9zaW5nIGFuaW1hdGlvbiBmb3IgYmFja2Ryb3AgYW5kIGludGVyZmFjZSBlbGVtZW50c1xuICAgIHRoaXMuJGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG5cbiAgICB0aGlzLiRjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImlzLWNsb3NpbmdcIik7XG5cbiAgICAvLyBDbGVhciBpbmFjdGl2ZSBzbGlkZXNcbiAgICBjb25zdCBjdXJyZW50U2xpZGUgPSB0aGlzLmdldFNsaWRlKCk7XG5cbiAgICB0aGlzLkNhcm91c2VsLnNsaWRlcy5mb3JFYWNoKChzbGlkZSkgPT4ge1xuICAgICAgaWYgKHNsaWRlLiRjb250ZW50ICYmIHNsaWRlLmluZGV4ICE9PSBjdXJyZW50U2xpZGUuaW5kZXgpIHtcbiAgICAgICAgdGhpcy5DYXJvdXNlbC50cmlnZ2VyKFwicmVtb3ZlU2xpZGVcIiwgc2xpZGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU3RhcnQgZGVmYXVsdCBjbG9zaW5nIGFuaW1hdGlvblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBcImNsb3NpbmdcIikge1xuICAgICAgY29uc3QgaGlkZUNsYXNzID0gY3VycmVudFNsaWRlLmhpZGVDbGFzcyA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb24oXCJoaWRlQ2xhc3NcIikgOiBjdXJyZW50U2xpZGUuaGlkZUNsYXNzO1xuXG4gICAgICB0aGlzLmFuaW1hdGVDU1MoXG4gICAgICAgIGN1cnJlbnRTbGlkZS4kY29udGVudCxcbiAgICAgICAgaGlkZUNsYXNzLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGFmdGVyIGNsb3NpbmcgZmFuY3lib3hcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZGVzdHJveVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IFwiZGVzdHJveVwiO1xuXG4gICAgdGhpcy50cmlnZ2VyKFwiZGVzdHJveVwiKTtcblxuICAgIGNvbnN0ICR0cmlnZ2VyID0gdGhpcy5vcHRpb24oXCJwbGFjZUZvY3VzQmFja1wiKSA/IHRoaXMub3B0aW9uKFwidHJpZ2dlclRhcmdldFwiLCB0aGlzLmdldFNsaWRlKCkuJHRyaWdnZXIpIDogbnVsbDtcblxuICAgIC8vIERlc3Ryb3kgQ2Fyb3VzZWwgYW5kIHRoZW4gZGV0YWNoIHBsdWdpbnM7XG4gICAgLy8gKiBOb3RlOiB0aGlzIG9yZGVyIGFsbG93cyBwbHVnaW5zIHRvIHJlY2VpdmUgYHJlbW92ZVNsaWRlYCBldmVudFxuICAgIHRoaXMuQ2Fyb3VzZWwuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5kZXRhY2hQbHVnaW5zKCk7XG5cbiAgICB0aGlzLkNhcm91c2VsID0gbnVsbDtcblxuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZXZlbnRzID0ge307XG5cbiAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlKCk7XG5cbiAgICB0aGlzLiRjb250YWluZXIgPSB0aGlzLiRiYWNrZHJvcCA9IHRoaXMuJGNhcm91c2VsID0gbnVsbDtcblxuICAgIGlmICgkdHJpZ2dlcikge1xuICAgICAgc2V0Rm9jdXNPbigkdHJpZ2dlcik7XG4gICAgfVxuXG4gICAgaW5zdGFuY2VzLmRlbGV0ZSh0aGlzLmlkKTtcblxuICAgIGNvbnN0IG5leHRJbnN0YW5jZSA9IEZhbmN5Ym94LmdldEluc3RhbmNlKCk7XG5cbiAgICBpZiAobmV4dEluc3RhbmNlKSB7XG4gICAgICBuZXh0SW5zdGFuY2UuZm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIndpdGgtZmFuY3lib3hcIik7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiaXMtdXNpbmctbW91c2VcIik7XG5cbiAgICB0aGlzLnJldmVhbFNjcm9sbGJhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBuZXcgRmFuY3lib3ggaW5zdGFuY2Ugd2l0aCBwcm92aWRlZCBvcHRpb25zXG4gICAqIEV4YW1wbGU6XG4gICAqICAgRmFuY3lib3guc2hvdyhbeyBzcmMgOiAnaHR0cHM6Ly9saXBzdW0uYXBwL2lkLzEvMzAweDIyNScgfV0pO1xuICAgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIEdhbGxlcnkgaXRlbXNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGN1c3RvbSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZhbmN5Ym94IGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgc2hvdyhpdGVtcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBGYW5jeWJveChpdGVtcywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIEZhbmN5Ym94IGlmIGV2ZW50IHRhcmdldCBtYXRjaGVzIGFueSBvcGVuZXIgb3IgdGFyZ2V0IGlzIGB0cmlnZ2VyIGVsZW1lbnRgXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gQ2xpY2sgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGN1c3RvbSBvcHRpb25zXG4gICAqL1xuICBzdGF0aWMgZnJvbUV2ZW50KGV2ZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAvLyAgQWxsb3cgb3RoZXIgc2NyaXB0cyB0byBwcmV2ZW50IHN0YXJ0aW5nIGZhbmN5Ym94IG9uIGNsaWNrXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBydW4gaWYgcmlnaHQtY2xpY2tcbiAgICBpZiAoZXZlbnQuYnV0dG9uICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElnbm9yZSBjb21tYW5kL2NvbnRyb2wgKyBjbGlja1xuICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcmlnVGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgbGV0IGV2ZW50VGFyZ2V0ID0gb3JpZ1RhcmdldDtcblxuICAgIC8vIFN1cHBvcnQgYHRyaWdnZXJgIGVsZW1lbnQsIGUuZy4sIHN0YXJ0IGZhbmN5Ym94IGZyb20gZGlmZmVyZW50IERPTSBlbGVtZW50LCBmb3IgZXhhbXBsZSxcbiAgICAvLyB0byBoYXZlIG9uZSBwcmV2aWV3IGltYWdlIGZvciBoaWRkZW4gaW1hZ2UgZ2FsbGVyeVxuICAgIGxldCB0cmlnZ2VyR3JvdXBOYW1lO1xuXG4gICAgaWYgKFxuICAgICAgZXZlbnRUYXJnZXQubWF0Y2hlcyhcIltkYXRhLWZhbmN5Ym94LXRyaWdnZXJdXCIpIHx8XG4gICAgICAoZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldC5jbG9zZXN0KFwiW2RhdGEtZmFuY3lib3gtdHJpZ2dlcl1cIikpXG4gICAgKSB7XG4gICAgICBvcHRpb25zLnRyaWdnZXJUYXJnZXQgPSBldmVudFRhcmdldDtcbiAgICAgIHRyaWdnZXJHcm91cE5hbWUgPSBldmVudFRhcmdldCAmJiBldmVudFRhcmdldC5kYXRhc2V0ICYmIGV2ZW50VGFyZ2V0LmRhdGFzZXQuZmFuY3lib3hUcmlnZ2VyO1xuICAgIH1cblxuICAgIGlmICh0cmlnZ2VyR3JvdXBOYW1lKSB7XG4gICAgICBjb25zdCB0cmlnZ2VySXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1mYW5jeWJveD1cIiR7dHJpZ2dlckdyb3VwTmFtZX1cIl1gKTtcbiAgICAgIGNvbnN0IHRyaWdnZXJJbmRleCA9IHBhcnNlSW50KGV2ZW50VGFyZ2V0LmRhdGFzZXQuZmFuY3lib3hJbmRleCwgMTApIHx8IDA7XG5cbiAgICAgIGV2ZW50VGFyZ2V0ID0gdHJpZ2dlckl0ZW1zLmxlbmd0aCA/IHRyaWdnZXJJdGVtc1t0cmlnZ2VySW5kZXhdIDogZXZlbnRUYXJnZXQ7XG4gICAgfVxuXG4gICAgLy8gKiBUcnkgdG8gZmluZCBtYXRjaGluZyBvcGVuZW5lclxuICAgIGxldCBtYXRjaGluZ09wZW5lcjtcbiAgICBsZXQgdGFyZ2V0O1xuXG4gICAgQXJyYXkuZnJvbShGYW5jeWJveC5vcGVuZXJzLmtleXMoKSlcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5zb21lKChvcGVuZXIpID0+IHtcbiAgICAgICAgdGFyZ2V0ID0gZXZlbnRUYXJnZXQgfHwgb3JpZ1RhcmdldDtcblxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ICYmICh0eXBlb2Ygb3BlbmVyID09PSBcInN0cmluZ1wiIHx8IG9wZW5lciBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIC8vIENoYWluIGNsb3Nlc3QoKSB0byBldmVudC50YXJnZXQgdG8gZmluZCBhbmQgcmV0dXJuIHRoZSBwYXJlbnQgZWxlbWVudCxcbiAgICAgICAgICAgIC8vIHJlZ2FyZGxlc3MgaWYgY2xpY2tpbmcgb24gdGhlIGNoaWxkIGVsZW1lbnRzIChpY29uLCBsYWJlbCwgZXRjKVxuICAgICAgICAgICAgZm91bmQgPSB0YXJnZXQubWF0Y2hlcyhvcGVuZXIpIHx8ICh0YXJnZXQgPSB0YXJnZXQuY2xvc2VzdChvcGVuZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgbWF0Y2hpbmdPcGVuZXIgPSBvcGVuZXI7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcblxuICAgIGxldCByZXogPSBmYWxzZTtcblxuICAgIGlmIChtYXRjaGluZ09wZW5lcikge1xuICAgICAgb3B0aW9ucy5ldmVudCA9IGV2ZW50O1xuICAgICAgb3B0aW9ucy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgIHRhcmdldC5vcmlnVGFyZ2V0ID0gb3JpZ1RhcmdldDtcblxuICAgICAgcmV6ID0gRmFuY3lib3guZnJvbU9wZW5lcihtYXRjaGluZ09wZW5lciwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBtb3VzZSBpcyBiZWluZyB1c2VkXG4gICAgICAvLyBXYWl0aW5nIGZvciBiZXR0ZXIgYnJvd3NlciBzdXBwb3J0IGZvciBgOmZvY3VzLXZpc2libGVgIC1cbiAgICAgIC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9zZWxlY3RvcnMtNC8jdGhlLWZvY3VzLXZpc2libGUtcHNldWRvXG4gICAgICBjb25zdCBuZXh0SW5zdGFuY2UgPSBGYW5jeWJveC5nZXRJbnN0YW5jZSgpO1xuXG4gICAgICBpZiAobmV4dEluc3RhbmNlICYmIG5leHRJbnN0YW5jZS5zdGF0ZSA9PT0gXCJyZWFkeVwiICYmIGV2ZW50LmRldGFpbCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJpcy11c2luZy1tb3VzZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV6O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBGYW5jeWJveCB1c2luZyBzZWxlY3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlbmVyIC0gVmFsaWQgQ1NTIHNlbGVjdG9yIHN0cmluZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgY3VzdG9tIG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBmcm9tT3BlbmVyKG9wZW5lciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIG9uY2UgZm9yIGVhY2ggZ3JvdXAgZWxlbWVudCB0aGF0XG4gICAgLy8gMSkgY29udmVydHMgZGF0YSBhdHRyaWJ1dGVzIHRvIGJvb2xlYW4gb3IgSlNPTlxuICAgIC8vIDIpIHJlbW92ZXMgdmFsdWVzIHRoYXQgY291bGQgY2F1c2UgaXNzdWVzXG4gICAgY29uc3QgbWFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGNvbnN0IGZhbHNlVmFsdWVzID0gW1wiZmFsc2VcIiwgXCIwXCIsIFwibm9cIiwgXCJudWxsXCIsIFwidW5kZWZpbmVkXCJdO1xuICAgICAgY29uc3QgdHJ1ZVZhbHVlcyA9IFtcInRydWVcIiwgXCIxXCIsIFwieWVzXCJdO1xuXG4gICAgICBjb25zdCBkYXRhc2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgZWwuZGF0YXNldCk7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhc2V0KSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcImZhbmN5Ym94XCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgPT09IFwid2lkdGhcIiB8fCBrZXkgPT09IFwiaGVpZ2h0XCIpIHtcbiAgICAgICAgICBvcHRpb25zW2BfJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICBpZiAoZmFsc2VWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICh0cnVlVmFsdWVzLmluZGV4T2Yob3B0aW9uc1trZXldKSA+IC0xKSB7XG4gICAgICAgICAgICBvcHRpb25zW2tleV0gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgb3B0aW9ucy4kdHJpZ2dlciA9IGVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9O1xuXG4gICAgbGV0IGl0ZW1zID0gW10sXG4gICAgICBpbmRleCA9IG9wdGlvbnMuc3RhcnRJbmRleCB8fCAwLFxuICAgICAgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgbnVsbDtcblxuICAgIC8vIEdldCBvcHRpb25zXG4gICAgLy8gPT09XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgRmFuY3lib3gub3BlbmVycy5nZXQob3BlbmVyKSk7XG5cbiAgICAvLyBHZXQgbWF0Y2hpbmcgbm9kZXNcbiAgICAvLyA9PT1cbiAgICBjb25zdCBncm91cEFsbCA9IG9wdGlvbnMuZ3JvdXBBbGwgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy5ncm91cEFsbDtcblxuICAgIGNvbnN0IGdyb3VwQXR0ciA9IG9wdGlvbnMuZ3JvdXBBdHRyID09PSB1bmRlZmluZWQgPyBcImRhdGEtZmFuY3lib3hcIiA6IG9wdGlvbnMuZ3JvdXBBdHRyO1xuICAgIGNvbnN0IGdyb3VwVmFsdWUgPSBncm91cEF0dHIgJiYgdGFyZ2V0ID8gdGFyZ2V0LmdldEF0dHJpYnV0ZShgJHtncm91cEF0dHJ9YCkgOiBcIlwiO1xuXG4gICAgaWYgKCF0YXJnZXQgfHwgZ3JvdXBWYWx1ZSB8fCBncm91cEFsbCkge1xuICAgICAgY29uc3QgJHJvb3QgPSBvcHRpb25zLnJvb3QgfHwgKHRhcmdldCA/IHRhcmdldC5nZXRSb290Tm9kZSgpIDogZG9jdW1lbnQuYm9keSk7XG5cbiAgICAgIGl0ZW1zID0gW10uc2xpY2UuY2FsbCgkcm9vdC5xdWVyeVNlbGVjdG9yQWxsKG9wZW5lcikpO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQgJiYgIWdyb3VwQWxsKSB7XG4gICAgICBpZiAoZ3JvdXBWYWx1ZSkge1xuICAgICAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcigoZWwpID0+IGVsLmdldEF0dHJpYnV0ZShgJHtncm91cEF0dHJ9YCkgPT09IGdyb3VwVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXMgPSBbdGFyZ2V0XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEV4aXQgaWYgY3VycmVudCBpbnN0YW5jZSBpcyB0cmlnZ2VyZWQgZnJvbSB0aGUgc2FtZSBlbGVtZW50XG4gICAgLy8gPT09XG4gICAgY29uc3QgY3VycmVudEluc3RhbmNlID0gRmFuY3lib3guZ2V0SW5zdGFuY2UoKTtcblxuICAgIGlmIChjdXJyZW50SW5zdGFuY2UgJiYgaXRlbXMuaW5kZXhPZihjdXJyZW50SW5zdGFuY2Uub3B0aW9ucy4kdHJpZ2dlcikgPiAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IEZhbmN5Ym94XG4gICAgLy8gPT09XG5cbiAgICAvLyBHZXQgaW5kZXggb2YgY3VycmVudCBpdGVtIGluIHRoZSBnYWxsZXJ5XG4gICAgaW5kZXggPSB0YXJnZXQgPyBpdGVtcy5pbmRleE9mKHRhcmdldCkgOiBpbmRleDtcblxuICAgIC8vIENvbnZlcnQgaXRlbXMgaW4gYSBmb3JtYXQgc3VwcG9ydGVkIGJ5IGZhbmN5Ym94XG4gICAgaXRlbXMgPSBpdGVtcy5tYXAobWFwQ2FsbGJhY2spO1xuXG4gICAgLy8gKiBDcmVhdGUgbmV3IGZhbmN5Ym94IGluc3RhbmNlXG4gICAgcmV0dXJuIG5ldyBGYW5jeWJveChcbiAgICAgIGl0ZW1zLFxuICAgICAgZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHN0YXJ0SW5kZXg6IGluZGV4LFxuICAgICAgICAkdHJpZ2dlcjogdGFyZ2V0LFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGNsaWNrIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCBzdGFydHMgRmFuY3lib3ggdG8gdGhlIHNlbGVjdGVkIGl0ZW1zLCBhcyB3ZWxsIGFzIHRvIGFsbCBmdXR1cmUgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIFNlbGVjdG9yIHRoYXQgc2hvdWxkIG1hdGNoIHRyaWdnZXIgZWxlbWVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEN1c3RvbSBvcHRpb25zXG4gICAqL1xuICBzdGF0aWMgYmluZChzZWxlY3Rvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZnVuY3Rpb24gYXR0YWNoQ2xpY2tFdmVudCgpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEZhbmN5Ym94LmZyb21FdmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmICghY2FuVXNlRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFGYW5jeWJveC5vcGVuZXJzLnNpemUpIHtcbiAgICAgIGlmICgvY29tcGxldGV8aW50ZXJhY3RpdmV8bG9hZGVkLy50ZXN0KGRvY3VtZW50LnJlYWR5U3RhdGUpKSB7XG4gICAgICAgIGF0dGFjaENsaWNrRXZlbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGF0dGFjaENsaWNrRXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEZhbmN5Ym94Lm9wZW5lcnMuc2V0KHNlbGVjdG9yLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGNsaWNrIGhhbmRsZXIgdGhhdCB3YXMgYXR0YWNoZWQgd2l0aCBgYmluZCgpYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSBBIHNlbGVjdG9yIHdoaWNoIHNob3VsZCBtYXRjaCB0aGUgb25lIG9yaWdpbmFsbHkgcGFzc2VkIHRvIC5iaW5kKClcbiAgICovXG4gIHN0YXRpYyB1bmJpbmQoc2VsZWN0b3IpIHtcbiAgICBGYW5jeWJveC5vcGVuZXJzLmRlbGV0ZShzZWxlY3Rvcik7XG5cbiAgICBpZiAoIUZhbmN5Ym94Lm9wZW5lcnMuc2l6ZSkge1xuICAgICAgRmFuY3lib3guZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbW1lZGlhdGVseSBkZXN0cm95IGFsbCBpbnN0YW5jZXMgKHdpdGhvdXQgY2xvc2luZyBhbmltYXRpb24pIGFuZCBjbGVhbiB1cCBhbGwgYmluZGluZ3MuLlxuICAgKi9cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgbGV0IGZiO1xuXG4gICAgd2hpbGUgKChmYiA9IEZhbmN5Ym94LmdldEluc3RhbmNlKCkpKSB7XG4gICAgICBmYi5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgRmFuY3lib3gub3BlbmVycyA9IG5ldyBNYXAoKTtcblxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIEZhbmN5Ym94LmZyb21FdmVudCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGluc3RhbmNlIGJ5IGlkZW50aWZpZXIgb3IgdGhlIHRvcCBtb3N0IGluc3RhbmNlLCBpZiBpZGVudGlmaWVyIGlzIG5vdCBwcm92aWRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1lcmljfSBbaWRdIC0gT3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxuICAgKi9cbiAgc3RhdGljIGdldEluc3RhbmNlKGlkKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2VzLmdldChpZCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBBcnJheS5mcm9tKGluc3RhbmNlcy52YWx1ZXMoKSlcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBpZiAoIWluc3RhbmNlLmlzQ2xvc2luZygpKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2UgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSBhbGwgb3IgdG9wbW9zdCBjdXJyZW50bHkgYWN0aXZlIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbGxdIC0gQWxsIG9yIG9ubHkgdG9wbW9zdCBhY3RpdmUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHthbnl9IFthcmd1bWVudHNdIC0gT3B0aW9uYWwgZGF0YVxuICAgKi9cbiAgc3RhdGljIGNsb3NlKGFsbCA9IHRydWUsIGFyZ3MpIHtcbiAgICBpZiAoYWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcy52YWx1ZXMoKSkge1xuICAgICAgICBpbnN0YW5jZS5jbG9zZShhcmdzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBGYW5jeWJveC5nZXRJbnN0YW5jZSgpO1xuXG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UuY2xvc2UoYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNsaWRlIHRvcG1vc3QgY3VycmVudGx5IGFjdGl2ZSBpbnN0YW5jZSB0byBuZXh0IHBhZ2VcbiAgICovXG4gIHN0YXRpYyBuZXh0KCkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gRmFuY3lib3guZ2V0SW5zdGFuY2UoKTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTbGlkZSB0b3Btb3N0IGN1cnJlbnRseSBhY3RpdmUgaW5zdGFuY2UgdG8gcHJldmlvdXMgcGFnZVxuICAgKi9cbiAgc3RhdGljIHByZXYoKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBGYW5jeWJveC5nZXRJbnN0YW5jZSgpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS5wcmV2KCk7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9zZSB2ZXJzaW9uXG5GYW5jeWJveC52ZXJzaW9uID0gXCJfX1ZFUlNJT05fX1wiO1xuXG4vLyBFeHBvc2UgZGVmYXVsdHNcbkZhbmN5Ym94LmRlZmF1bHRzID0gZGVmYXVsdHM7XG5cbi8vIEV4cG9zZSBvcGVuZXJzXG5GYW5jeWJveC5vcGVuZXJzID0gbmV3IE1hcCgpO1xuXG4vLyBBZGQgZGVmYXVsdCBwbHVnaW5zXG5GYW5jeWJveC5QbHVnaW5zID0gUGx1Z2lucztcblxuLy8gQXV0byBpbml0IHdpdGggZGVmYXVsdCBvcHRpb25zXG5GYW5jeWJveC5iaW5kKFwiW2RhdGEtZmFuY3lib3hdXCIpO1xuXG4vLyBQcmVwYXJlIHBsdWdpbnNcbmZvciAoY29uc3QgW2tleSwgUGx1Z2luXSBvZiBPYmplY3QuZW50cmllcyhGYW5jeWJveC5QbHVnaW5zIHx8IHt9KSkge1xuICBpZiAodHlwZW9mIFBsdWdpbi5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIFBsdWdpbi5jcmVhdGUoRmFuY3lib3gpO1xuICB9XG59XG5cbmV4cG9ydCB7IEZhbmN5Ym94IH07XG4iLCJleHBvcnQgZGVmYXVsdCB7XHJcbiAgQ0xPU0U6IFwiQ2xvc2VcIixcclxuICBORVhUOiBcIk5leHRcIixcclxuICBQUkVWOiBcIlByZXZpb3VzXCIsXHJcbiAgTU9EQUw6IFwiWW91IGNhbiBjbG9zZSB0aGlzIG1vZGFsIGNvbnRlbnQgd2l0aCB0aGUgRVNDIGtleVwiLFxyXG4gIEVSUk9SOiBcIlNvbWV0aGluZyBXZW50IFdyb25nLCBQbGVhc2UgVHJ5IEFnYWluIExhdGVyXCIsXHJcbiAgSU1BR0VfRVJST1I6IFwiSW1hZ2UgTm90IEZvdW5kXCIsXHJcbiAgRUxFTUVOVF9OT1RfRk9VTkQ6IFwiSFRNTCBFbGVtZW50IE5vdCBGb3VuZFwiLFxyXG4gIEFKQVhfTk9UX0ZPVU5EOiBcIkVycm9yIExvYWRpbmcgQUpBWCA6IE5vdCBGb3VuZFwiLFxyXG4gIEFKQVhfRk9SQklEREVOOiBcIkVycm9yIExvYWRpbmcgQUpBWCA6IEZvcmJpZGRlblwiLFxyXG4gIElGUkFNRV9FUlJPUjogXCJFcnJvciBMb2FkaW5nIFBhZ2VcIixcclxuICBUT0dHTEVfWk9PTTogXCJUb2dnbGUgem9vbSBsZXZlbFwiLFxyXG4gIFRPR0dMRV9USFVNQlM6IFwiVG9nZ2xlIHRodW1ibmFpbHNcIixcclxuICBUT0dHTEVfU0xJREVTSE9XOiBcIlRvZ2dsZSBzbGlkZXNob3dcIixcclxuICBUT0dHTEVfRlVMTFNDUkVFTjogXCJUb2dnbGUgZnVsbC1zY3JlZW4gbW9kZVwiLFxyXG4gIERPV05MT0FEOiBcIkRvd25sb2FkXCIsXHJcbn07XHJcbiIsImltcG9ydCB7IGNhblVzZURPTSB9IGZyb20gXCIuLi8uLi8uLi9zaGFyZWQvdXRpbHMvY2FuVXNlRE9NLmpzXCI7XG5cbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgY29uc3RydWN0b3IoZmFuY3lib3gpIHtcbiAgICB0aGlzLmZhbmN5Ym94ID0gZmFuY3lib3g7XG5cbiAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgW1wib25DaGFuZ2VcIiwgXCJvbkNsb3NpbmdcIl0pIHtcbiAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSB0aGlzW21ldGhvZE5hbWVdLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBpbml0Q2Fyb3VzZWw6IHRoaXMub25DaGFuZ2UsXG4gICAgICBcIkNhcm91c2VsLmNoYW5nZVwiOiB0aGlzLm9uQ2hhbmdlLFxuICAgICAgY2xvc2luZzogdGhpcy5vbkNsb3NpbmcsXG4gICAgfTtcblxuICAgIHRoaXMuaGFzQ3JlYXRlZEhpc3RvcnkgPSBmYWxzZTtcbiAgICB0aGlzLm9yaWdIYXNoID0gXCJcIjtcbiAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGBDYXJvdXNlbC5yZWFkeWAgYW5kIGBDYXJvdXNlbC5jaGFuZ2VgIGV2ZW50cyB0byB1cGRhdGUgVVJMIGhhc2hcbiAgICogQHBhcmFtIHtPYmplY3R9IGZhbmN5Ym94XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYXJvdXNlbFxuICAgKi9cbiAgb25DaGFuZ2UoZmFuY3lib3gpIHtcbiAgICBjb25zdCBjYXJvdXNlbCA9IGZhbmN5Ym94LkNhcm91c2VsO1xuXG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFJ1biA9IGNhcm91c2VsLnByZXZQYWdlID09PSBudWxsO1xuICAgIGNvbnN0IGN1cnJlbnRTbGlkZSA9IGZhbmN5Ym94LmdldFNsaWRlKCk7XG5cbiAgICBjb25zdCBjdXJyZW50SGFzaCA9IG5ldyBVUkwoZG9jdW1lbnQuVVJMKS5oYXNoO1xuXG4gICAgbGV0IG5ld0hhc2ggPSBmYWxzZTtcblxuICAgIGlmIChjdXJyZW50U2xpZGUuc2x1Zykge1xuICAgICAgbmV3SGFzaCA9IFwiI1wiICsgY3VycmVudFNsaWRlLnNsdWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBjdXJyZW50U2xpZGUuJHRyaWdnZXIgJiYgY3VycmVudFNsaWRlLiR0cmlnZ2VyLmRhdGFzZXQ7XG4gICAgICBjb25zdCBzbHVnID0gZmFuY3lib3gub3B0aW9uKFwic2x1Z1wiKSB8fCAoZGF0YXNldCAmJiBkYXRhc2V0LmZhbmN5Ym94KTtcblxuICAgICAgaWYgKHNsdWcgJiYgc2x1Zy5sZW5ndGggJiYgc2x1ZyAhPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgbmV3SGFzaCA9IFwiI1wiICsgc2x1ZyArIChjYXJvdXNlbC5zbGlkZXMubGVuZ3RoID4gMSA/IFwiLVwiICsgKGN1cnJlbnRTbGlkZS5pbmRleCArIDEpIDogXCJcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0UnVuKSB7XG4gICAgICB0aGlzLm9yaWdIYXNoID0gY3VycmVudEhhc2ggIT09IG5ld0hhc2ggPyBjdXJyZW50SGFzaCA6IFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0hhc2ggJiYgY3VycmVudEhhc2ggIT09IG5ld0hhc2gpIHtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeVtmaXJzdFJ1biA/IFwicHVzaFN0YXRlXCIgOiBcInJlcGxhY2VTdGF0ZVwiXShcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgZG9jdW1lbnQudGl0bGUsXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgbmV3SGFzaFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoZmlyc3RSdW4pIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQ3JlYXRlZEhpc3RvcnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH0sIDMwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYGNsb3NpbmdgIGV2ZW50IHRvIGNsZWFuIHVwXG4gICAqL1xuICBvbkNsb3NpbmcoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGlmIGNsb3NpbmcgaXMgdHJpZ2dlcmVkIGJ5IHByZXNzaW5nICBicm93c2VyIGJhY2sgYnV0dG9uIG9yIGJ5IGNoYW5naW5nIGhhc2ggbWFudWFsbHlcbiAgICBpZiAodGhpcy5oYXNTaWxlbnRDbG9zZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgdXJsXG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShcbiAgICAgICAge30sXG4gICAgICAgIGRvY3VtZW50LnRpdGxlLFxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgKHRoaXMub3JpZ0hhc2ggfHwgXCJcIilcbiAgICAgICk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgYXR0YWNoKGZhbmN5Ym94KSB7XG4gICAgZmFuY3lib3gub24odGhpcy5ldmVudHMpO1xuICB9XG5cbiAgZGV0YWNoKGZhbmN5Ym94KSB7XG4gICAgZmFuY3lib3gub2ZmKHRoaXMuZXZlbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBmYW5jeWJveCBmcm9tIGN1cnJlbnQgVVJMIGhhc2gsXG4gICAqIHRoaXMgd2lsbCBiZSBjYWxsZWQgb24gcGFnZSBsb2FkIE9SL0FORCBhZnRlciBjaGFuZ2luZyBVUkwgaGFzaFxuICAgKiBAcGFyYW0ge0NsYXNzfSBGYW5jeWJveFxuICAgKi9cbiAgc3RhdGljIHN0YXJ0RnJvbVVybCgpIHtcbiAgICBjb25zdCBGYW5jeWJveCA9IEhhc2guRmFuY3lib3g7XG5cbiAgICBpZiAoIUZhbmN5Ym94IHx8IEZhbmN5Ym94LmdldEluc3RhbmNlKCkgfHwgRmFuY3lib3guZGVmYXVsdHMuSGFzaCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGhhc2gsIHNsdWcsIGluZGV4IH0gPSBIYXNoLmdldFBhcnNlZFVSTCgpO1xuXG4gICAgaWYgKCFzbHVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydCBjdXN0b20gc2x1Z1xuICAgIC8vID09PVxuICAgIGxldCBzZWxlY3RlZEVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1zbHVnPVwiJHtoYXNofVwiXWApO1xuXG4gICAgaWYgKHNlbGVjdGVkRWxlbSkge1xuICAgICAgc2VsZWN0ZWRFbGVtLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2xpY2tcIiwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pKTtcbiAgICB9XG5cbiAgICBpZiAoRmFuY3lib3guZ2V0SW5zdGFuY2UoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGVsZW1lbnRzIGFyZSBub3QgZm91bmQgYnkgY3VzdG9tIHNsdWcsIHVzZSBVUkwgaGFzaCB2YWx1ZSBhcyBncm91cCBuYW1lXG4gICAgLy8gPT09XG4gICAgY29uc3QgZ3JvdXBFbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLWZhbmN5Ym94PVwiJHtzbHVnfVwiXWApO1xuXG4gICAgaWYgKCFncm91cEVsZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gbnVsbCAmJiBncm91cEVsZW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc2VsZWN0ZWRFbGVtID0gZ3JvdXBFbGVtc1swXTtcbiAgICB9IGVsc2UgaWYgKGluZGV4KSB7XG4gICAgICBzZWxlY3RlZEVsZW0gPSBncm91cEVsZW1zW2luZGV4IC0gMV07XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkRWxlbSkge1xuICAgICAgc2VsZWN0ZWRFbGVtLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiY2xpY2tcIiwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlIH0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGBoYXNoYCBjaGFuZ2UsIGNoYW5nZSBnYWxsZXJ5IGl0ZW0gdG8gY3VycmVudCBpbmRleCBvciBzdGFydC9jbG9zZSBjdXJyZW50IGluc3RhbmNlXG4gICAqL1xuICBzdGF0aWMgb25IYXNoQ2hhbmdlKCkge1xuICAgIGNvbnN0IHsgc2x1ZywgaW5kZXggfSA9IEhhc2guZ2V0UGFyc2VkVVJMKCk7XG5cbiAgICBjb25zdCBGYW5jeWJveCA9IEhhc2guRmFuY3lib3g7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBGYW5jeWJveCAmJiBGYW5jeWJveC5nZXRJbnN0YW5jZSgpO1xuXG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLnBsdWdpbnMuSGFzaCkge1xuICAgICAgLy8gQ2hlY2sgaWYgaGFzaCBtYXRjaGVzIGN1cnJlbnRseSBhY3RpdmUgZ2FsbGVyeVxuICAgICAgaWYgKHNsdWcpIHtcbiAgICAgICAgY29uc3QgY2Fyb3VzZWwgPSBpbnN0YW5jZS5DYXJvdXNlbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3VwcG9ydCBtYW51YWxseSBvcGVuZWQgZ2FsbGVyeVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHNsdWcgPT09IGluc3RhbmNlLm9wdGlvbihcInNsdWdcIikpIHtcbiAgICAgICAgICByZXR1cm4gY2Fyb3VzZWwuc2xpZGVUbyhpbmRleCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIFVSTCBoYXNoIG1hdGNoZXMgYGRhdGEtc2x1Z2AgdmFsdWUgb2YgYWN0aXZlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IHNsaWRlIG9mIGNhcm91c2VsLnNsaWRlcykge1xuICAgICAgICAgIGlmIChzbGlkZS5zbHVnICYmIHNsaWRlLnNsdWcgPT09IHNsdWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXJvdXNlbC5zbGlkZVRvKHNsaWRlLmluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgVVJMIGhhc2ggbWF0Y2hlcyBgZGF0YS1mYW5jeWJveGAgdmFsdWUgb2YgYWN0aXZlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHNsaWRlID0gaW5zdGFuY2UuZ2V0U2xpZGUoKTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IHNsaWRlLiR0cmlnZ2VyICYmIHNsaWRlLiR0cmlnZ2VyLmRhdGFzZXQ7XG5cbiAgICAgICAgaWYgKGRhdGFzZXQgJiYgZGF0YXNldC5mYW5jeWJveCA9PT0gc2x1Zykge1xuICAgICAgICAgIHJldHVybiBjYXJvdXNlbC5zbGlkZVRvKGluZGV4IC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZSBpZiBubyBtYXRjaGluZyBlbGVtZW50IGZvdW5kXG4gICAgICAgKi9cbiAgICAgIGluc3RhbmNlLnBsdWdpbnMuSGFzaC5oYXNTaWxlbnRDbG9zZSA9IHRydWU7XG5cbiAgICAgIGluc3RhbmNlLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBzdGFydFxuICAgICAqL1xuICAgIEhhc2guc3RhcnRGcm9tVXJsKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGV2ZW50IGJpbmRpbmdzIHRoYXQgd2lsbCBzdGFydCBuZXcgRmFuY3lib3ggaW5zdGFuY2UgYmFzZWQgaW4gdGhlIGN1cnJlbnQgVVJMXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKEZhbmN5Ym94KSB7XG4gICAgSGFzaC5GYW5jeWJveCA9IEZhbmN5Ym94O1xuXG4gICAgZnVuY3Rpb24gcHJvY2VlZCgpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiaGFzaGNoYW5nZVwiLCBIYXNoLm9uSGFzaENoYW5nZSwgZmFsc2UpO1xuXG4gICAgICBIYXNoLnN0YXJ0RnJvbVVybCgpO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VET00pIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBpZiAoL2NvbXBsZXRlfGludGVyYWN0aXZlfGxvYWRlZC8udGVzdChkb2N1bWVudC5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgIHByb2NlZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBwcm9jZWVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJoYXNoY2hhbmdlXCIsIEhhc2gub25IYXNoQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBzcGxpdCBVUkwgaGFzaCBpbnRvIHVzZWZ1bCBwaWVjZXNcbiAgICovXG4gIHN0YXRpYyBnZXRQYXJzZWRVUkwoKSB7XG4gICAgY29uc3QgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cigxKSxcbiAgICAgIHRtcCA9IGhhc2guc3BsaXQoXCItXCIpLFxuICAgICAgaW5kZXggPSB0bXAubGVuZ3RoID4gMSAmJiAvXlxcKz9cXGQrJC8udGVzdCh0bXBbdG1wLmxlbmd0aCAtIDFdKSA/IHBhcnNlSW50KHRtcC5wb3AoLTEpLCAxMCkgfHwgbnVsbCA6IG51bGwsXG4gICAgICBzbHVnID0gdG1wLmpvaW4oXCItXCIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc2gsXG4gICAgICBzbHVnLFxuICAgICAgaW5kZXgsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSBcIi4uLy4uLy4uL3NoYXJlZC91dGlscy9leHRlbmQuanNcIjtcblxuY29uc3QgYnVpbGRVUkxRdWVyeSA9IChzcmMsIG9iaikgPT4ge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHNyYyk7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLnNlYXJjaCk7XG5cbiAgbGV0IHJleiA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBbLi4ucGFyYW1zLCAuLi5PYmplY3QuZW50cmllcyhvYmopXSkge1xuICAgIC8vIFlvdXR1YmVcbiAgICBpZiAoa2V5ID09PSBcInRcIikge1xuICAgICAgcmV6LnNldChcInN0YXJ0XCIsIHBhcnNlSW50KHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlei5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29udmVydCB0byAnZm9vPTEmYmFyPTImYmF6PTMnXG4gIHJleiA9IHJlei50b1N0cmluZygpO1xuXG4gIC8vIFZpbWVvXG4gIC8vIGh0dHBzOi8vdmltZW8uemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDAwMTIxNjY4LVN0YXJ0aW5nLXBsYXliYWNrLWF0LWEtc3BlY2lmaWMtdGltZWNvZGVcbiAgbGV0IG1hdGNoZXMgPSBzcmMubWF0Y2goLyN0PSgoLiopP1xcZCtzKS8pO1xuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgcmV6ICs9IGAjdD0ke21hdGNoZXNbMV19YDtcbiAgfVxuXG4gIHJldHVybiByZXo7XG59O1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgLy8gR2VuZXJhbCBvcHRpb25zIGZvciBhbnkgdmlkZW8gY29udGVudCAoWW91dHViZSwgVmltZW8sIEhUTUw1IHZpZGVvKVxuICB2aWRlbzoge1xuICAgIGF1dG9wbGF5OiB0cnVlLFxuICAgIHJhdGlvOiAxNiAvIDksXG4gIH0sXG4gIC8vIFlvdXR1YmUgZW1iZWQgcGFyYW1ldGVyc1xuICB5b3V0dWJlOiB7XG4gICAgYXV0b2hpZGU6IDEsXG4gICAgZnM6IDEsXG4gICAgcmVsOiAwLFxuICAgIGhkOiAxLFxuICAgIHdtb2RlOiBcInRyYW5zcGFyZW50XCIsXG4gICAgZW5hYmxlanNhcGk6IDEsXG4gICAgaHRtbDU6IDEsXG4gIH0sXG4gIC8vIFZpbWVvIGVtYmVkIHBhcmFtZXRlcnNcbiAgdmltZW86IHtcbiAgICBoZDogMSxcbiAgICBzaG93X3RpdGxlOiAxLFxuICAgIHNob3dfYnlsaW5lOiAxLFxuICAgIHNob3dfcG9ydHJhaXQ6IDAsXG4gICAgZnVsbHNjcmVlbjogMSxcbiAgfSxcbiAgLy8gSFRNTDUgdmlkZW8gcGFyYW1ldGVyc1xuICBodG1sNXZpZGVvOiB7XG4gICAgdHBsOiBgPHZpZGVvIGNsYXNzPVwiZmFuY3lib3hfX2h0bWw1dmlkZW9cIiBwbGF5c2lubGluZSBjb250cm9scyBjb250cm9sc0xpc3Q9XCJub2Rvd25sb2FkXCIgcG9zdGVyPVwie3twb3N0ZXJ9fVwiPlxuICA8c291cmNlIHNyYz1cInt7c3JjfX1cIiB0eXBlPVwie3tmb3JtYXR9fVwiIC8+U29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgZW1iZWRkZWQgdmlkZW9zLjwvdmlkZW8+YCxcbiAgICBmb3JtYXQ6IFwiXCIsXG4gIH0sXG59O1xuXG5leHBvcnQgY2xhc3MgSHRtbCB7XG4gIGNvbnN0cnVjdG9yKGZhbmN5Ym94KSB7XG4gICAgdGhpcy5mYW5jeWJveCA9IGZhbmN5Ym94O1xuXG4gICAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIFtcbiAgICAgIFwib25Jbml0XCIsXG4gICAgICBcIm9uUmVhZHlcIixcblxuICAgICAgXCJvbkNyZWF0ZVNsaWRlXCIsXG4gICAgICBcIm9uUmVtb3ZlU2xpZGVcIixcblxuICAgICAgXCJvblNlbGVjdFNsaWRlXCIsXG4gICAgICBcIm9uVW5zZWxlY3RTbGlkZVwiLFxuXG4gICAgICBcIm9uUmVmcmVzaFwiLFxuXG4gICAgICAvLyBGb3IgY29tbXVuaWNhdGlvbiB3aXRoIGlmcmFtZWQgdmlkZW8gKHlvdXR1YmUvdmltZW8pXG4gICAgICBcIm9uTWVzc2FnZVwiLFxuICAgIF0pIHtcbiAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSB0aGlzW21ldGhvZE5hbWVdLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBpbml0OiB0aGlzLm9uSW5pdCxcbiAgICAgIHJlYWR5OiB0aGlzLm9uUmVhZHksXG5cbiAgICAgIFwiQ2Fyb3VzZWwuY3JlYXRlU2xpZGVcIjogdGhpcy5vbkNyZWF0ZVNsaWRlLFxuICAgICAgXCJDYXJvdXNlbC5yZW1vdmVTbGlkZVwiOiB0aGlzLm9uUmVtb3ZlU2xpZGUsXG5cbiAgICAgIFwiQ2Fyb3VzZWwuc2VsZWN0U2xpZGVcIjogdGhpcy5vblNlbGVjdFNsaWRlLFxuICAgICAgXCJDYXJvdXNlbC51bnNlbGVjdFNsaWRlXCI6IHRoaXMub25VbnNlbGVjdFNsaWRlLFxuXG4gICAgICBcIkNhcm91c2VsLnJlZnJlc2hcIjogdGhpcy5vblJlZnJlc2gsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBlYWNoIGdhbGxlcnkgaXRlbSBoYXMgdHlwZSB3aGVuIGZhbmN5Ym94IHN0YXJ0c1xuICAgKi9cbiAgb25Jbml0KCkge1xuICAgIGZvciAoY29uc3Qgc2xpZGUgb2YgdGhpcy5mYW5jeWJveC5pdGVtcykge1xuICAgICAgdGhpcy5wcm9jZXNzVHlwZShzbGlkZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb250ZW50IHR5cGUgZm9yIHRoZSBzbGlkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGVcbiAgICovXG4gIHByb2Nlc3NUeXBlKHNsaWRlKSB7XG4gICAgLy8gQWRkIHN1cHBvcnQgZm9yIGBuZXcgRmFuY3lib3goe2l0ZW1zIDogW3todG1sIDogJ3NtdGgnfV19KTtgXG4gICAgaWYgKHNsaWRlLmh0bWwpIHtcbiAgICAgIHNsaWRlLnNyYyA9IHNsaWRlLmh0bWw7XG4gICAgICBzbGlkZS50eXBlID0gXCJodG1sXCI7XG5cbiAgICAgIGRlbGV0ZSBzbGlkZS5odG1sO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3JjID0gc2xpZGUuc3JjIHx8IFwiXCI7XG5cbiAgICBsZXQgdHlwZSA9IHNsaWRlLnR5cGUgfHwgdGhpcy5mYW5jeWJveC5vcHRpb25zLnR5cGUsXG4gICAgICByZXogPSBudWxsO1xuXG4gICAgaWYgKHNyYyAmJiB0eXBlb2Ygc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgKHJleiA9IHNyYy5tYXRjaChcbiAgICAgICAgLyg/OnlvdXR1YmVcXC5jb218eW91dHVcXC5iZXx5b3V0dWJlXFwtbm9jb29raWVcXC5jb20pXFwvKD86d2F0Y2hcXD8oPzouKiYpP3Y9fHZcXC98dVxcL3xlbWJlZFxcLz8pPyh2aWRlb3Nlcmllc1xcP2xpc3Q9KD86LiopfFtcXHctXXsxMX18XFw/bGlzdFR5cGU9KD86LiopJmxpc3Q9KD86LiopKSg/Oi4qKS9pXG4gICAgICApKVxuICAgICkge1xuICAgICAgY29uc3QgcGFyYW1zID0gYnVpbGRVUkxRdWVyeShzcmMsIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSHRtbC55b3V0dWJlXCIpKTtcbiAgICAgIGNvbnN0IHZpZGVvSWQgPSBlbmNvZGVVUklDb21wb25lbnQocmV6WzFdKTtcblxuICAgICAgc2xpZGUudmlkZW9JZCA9IHZpZGVvSWQ7XG4gICAgICBzbGlkZS5zcmMgPSBgaHR0cHM6Ly93d3cueW91dHViZS1ub2Nvb2tpZS5jb20vZW1iZWQvJHt2aWRlb0lkfT8ke3BhcmFtc31gO1xuICAgICAgc2xpZGUudGh1bWIgPSBzbGlkZS50aHVtYiB8fCBgaHR0cHM6Ly9pLnl0aW1nLmNvbS92aS8ke3ZpZGVvSWR9L21xZGVmYXVsdC5qcGdgO1xuICAgICAgc2xpZGUudmVuZG9yID0gXCJ5b3V0dWJlXCI7XG5cbiAgICAgIHR5cGUgPSBcInZpZGVvXCI7XG4gICAgfSBlbHNlIGlmICgocmV6ID0gc3JjLm1hdGNoKC9eLit2aW1lby5jb21cXC8oPzpcXC8pPyhbXFxkXSspKC4qKT8vKSkpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGJ1aWxkVVJMUXVlcnkoc3JjLCB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkh0bWwudmltZW9cIikpO1xuICAgICAgY29uc3QgdmlkZW9JZCA9IGVuY29kZVVSSUNvbXBvbmVudChyZXpbMV0pO1xuXG4gICAgICBzbGlkZS52aWRlb0lkID0gdmlkZW9JZDtcbiAgICAgIHNsaWRlLnNyYyA9IGBodHRwczovL3BsYXllci52aW1lby5jb20vdmlkZW8vJHt2aWRlb0lkfT8ke3BhcmFtc31gO1xuICAgICAgc2xpZGUudmVuZG9yID0gXCJ2aW1lb1wiO1xuXG4gICAgICB0eXBlID0gXCJ2aWRlb1wiO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAocmV6ID0gc3JjLm1hdGNoKFxuICAgICAgICAvKD86bWFwc1xcLik/Z29vZ2xlXFwuKFthLXpdezIsM30oPzpcXC5bYS16XXsyfSk/KVxcLyg/Oig/Oig/Om1hcHNcXC8oPzpwbGFjZVxcLyg/Oi4qKVxcLyk/XFxAKC4qKSwoXFxkKy4/XFxkKz8peikpfCg/OlxcP2xsPSkpKC4qKT8vaVxuICAgICAgKSlcbiAgICApIHtcbiAgICAgIHNsaWRlLnNyYyA9IGAvL21hcHMuZ29vZ2xlLiR7cmV6WzFdfS8/bGw9JHsocmV6WzJdXG4gICAgICAgID8gcmV6WzJdICsgXCImej1cIiArIE1hdGguZmxvb3IocmV6WzNdKSArIChyZXpbNF0gPyByZXpbNF0ucmVwbGFjZSgvXlxcLy8sIFwiJlwiKSA6IFwiXCIpXG4gICAgICAgIDogcmV6WzRdICsgXCJcIlxuICAgICAgKS5yZXBsYWNlKC9cXD8vLCBcIiZcIil9Jm91dHB1dD0ke3Jlels0XSAmJiByZXpbNF0uaW5kZXhPZihcImxheWVyPWNcIikgPiAwID8gXCJzdmVtYmVkXCIgOiBcImVtYmVkXCJ9YDtcblxuICAgICAgdHlwZSA9IFwibWFwXCI7XG4gICAgfSBlbHNlIGlmICgocmV6ID0gc3JjLm1hdGNoKC8oPzptYXBzXFwuKT9nb29nbGVcXC4oW2Etel17MiwzfSg/OlxcLlthLXpdezJ9KT8pXFwvKD86bWFwc1xcL3NlYXJjaFxcLykoLiopL2kpKSkge1xuICAgICAgc2xpZGUuc3JjID0gYC8vbWFwcy5nb29nbGUuJHtyZXpbMV19L21hcHM/cT0ke3JlelsyXS5yZXBsYWNlKFwicXVlcnk9XCIsIFwicT1cIikucmVwbGFjZShcImFwaT0xXCIsIFwiXCIpfSZvdXRwdXQ9ZW1iZWRgO1xuXG4gICAgICB0eXBlID0gXCJtYXBcIjtcbiAgICB9XG5cbiAgICAvLyBHdWVzcyBjb250ZW50IHR5cGVcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIGlmIChzcmMuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICB0eXBlID0gXCJpbmxpbmVcIjtcbiAgICAgIH0gZWxzZSBpZiAoKHJleiA9IHNyYy5tYXRjaCgvXFwuKG1wNHxtb3Z8b2d2fHdlYm0pKChcXD98IykuKik/JC9pKSkpIHtcbiAgICAgICAgdHlwZSA9IFwiaHRtbDV2aWRlb1wiO1xuXG4gICAgICAgIHNsaWRlLmZvcm1hdCA9IHNsaWRlLmZvcm1hdCB8fCBcInZpZGVvL1wiICsgKHJlelsxXSA9PT0gXCJvZ3ZcIiA/IFwib2dnXCIgOiByZXpbMV0pO1xuICAgICAgfSBlbHNlIGlmIChzcmMubWF0Y2goLyheZGF0YTppbWFnZVxcL1thLXowLTkrXFwvPV0qLCl8KFxcLihqcChlfGd8ZWcpfGdpZnxwbmd8Ym1wfHdlYnB8c3ZnfGljbykoKFxcP3wjKS4qKT8kKS9pKSkge1xuICAgICAgICB0eXBlID0gXCJpbWFnZVwiO1xuICAgICAgfSBlbHNlIGlmIChzcmMubWF0Y2goL1xcLihwZGYpKChcXD98IykuKik/JC9pKSkge1xuICAgICAgICB0eXBlID0gXCJwZGZcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzbGlkZS50eXBlID0gdHlwZSB8fCB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcImRlZmF1bHRUeXBlXCIsIFwiaW1hZ2VcIik7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJodG1sNXZpZGVvXCIgfHwgdHlwZSA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICBzbGlkZS52aWRlbyA9IGV4dGVuZCh7fSwgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJIdG1sLnZpZGVvXCIpLCBzbGlkZS52aWRlbyk7XG5cbiAgICAgIGlmIChzbGlkZS5fd2lkdGggJiYgc2xpZGUuX2hlaWdodCkge1xuICAgICAgICBzbGlkZS5yYXRpbyA9IHBhcnNlRmxvYXQoc2xpZGUuX3dpZHRoKSAvIHBhcnNlRmxvYXQoc2xpZGUuX2hlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbGlkZS5yYXRpbyA9IHNsaWRlLnJhdGlvIHx8IHNsaWRlLnZpZGVvLnJhdGlvIHx8IGRlZmF1bHRzLnZpZGVvLnJhdGlvO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBsb2FkaW5nIGNvbnRlbnQgd2hlbiBGYW5jeWJveCBpcyByZWFkeVxuICAgKi9cbiAgb25SZWFkeSgpIHtcbiAgICB0aGlzLmZhbmN5Ym94LkNhcm91c2VsLnNsaWRlcy5mb3JFYWNoKChzbGlkZSkgPT4ge1xuICAgICAgaWYgKHNsaWRlLiRlbCkge1xuICAgICAgICB0aGlzLnNldENvbnRlbnQoc2xpZGUpO1xuXG4gICAgICAgIGlmIChzbGlkZS5pbmRleCA9PT0gdGhpcy5mYW5jeWJveC5nZXRTbGlkZSgpLmluZGV4KSB7XG4gICAgICAgICAgdGhpcy5wbGF5VmlkZW8oc2xpZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBgQ2Fyb3VzZWwuY3JlYXRlU2xpZGVgIGV2ZW50IHRvIGNyZWF0ZSBpbWFnZSBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYW5jeWJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2Fyb3VzZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXG4gICAqL1xuICBvbkNyZWF0ZVNsaWRlKGZhbmN5Ym94LCBjYXJvdXNlbCwgc2xpZGUpIHtcbiAgICBpZiAodGhpcy5mYW5jeWJveC5zdGF0ZSAhPT0gXCJyZWFkeVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRDb250ZW50KHNsaWRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhbmQgc2V0IHNsaWRlIGNvbnRlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXG4gICAqL1xuICBsb2FkSW5saW5lQ29udGVudChzbGlkZSkge1xuICAgIGxldCAkY29udGVudDtcblxuICAgIGlmIChzbGlkZS5zcmMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgJGNvbnRlbnQgPSBzbGlkZS5zcmM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2xpZGUuc3JjID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCB0bXAgPSBzbGlkZS5zcmMuc3BsaXQoXCIjXCIsIDIpO1xuICAgICAgY29uc3QgaWQgPSB0bXAubGVuZ3RoID09PSAyICYmIHRtcFswXSA9PT0gXCJcIiA/IHRtcFsxXSA6IHRtcFswXTtcblxuICAgICAgJGNvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgfVxuXG4gICAgaWYgKCRjb250ZW50KSB7XG4gICAgICBpZiAoc2xpZGUudHlwZSA9PT0gXCJjbG9uZVwiIHx8ICRjb250ZW50LiRwbGFjZUhvbGRlcikge1xuICAgICAgICAkY29udGVudCA9ICRjb250ZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgbGV0IGF0dHJJZCA9ICRjb250ZW50LmdldEF0dHJpYnV0ZShcImlkXCIpO1xuXG4gICAgICAgIGF0dHJJZCA9IGF0dHJJZCA/IGAke2F0dHJJZH0tLWNsb25lYCA6IGBjbG9uZS0ke3RoaXMuZmFuY3lib3guaWR9LSR7c2xpZGUuaW5kZXh9YDtcblxuICAgICAgICAkY29udGVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBhdHRySWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgJHBsYWNlSG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgJHBsYWNlSG9sZGVyLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveC1wbGFjZWhvbGRlclwiKTtcbiAgICAgICAgJGNvbnRlbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoJHBsYWNlSG9sZGVyLCAkY29udGVudCk7XG4gICAgICAgICRjb250ZW50LiRwbGFjZUhvbGRlciA9ICRwbGFjZUhvbGRlcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mYW5jeWJveC5zZXRDb250ZW50KHNsaWRlLCAkY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFuY3lib3guc2V0RXJyb3Ioc2xpZGUsIFwie3tFTEVNRU5UX05PVF9GT1VORH19XCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBBSkFYIHJlcXVlc3QgYW5kIHNldHMgcmVzcG9uc2UgYXMgc2xpZGUgY29udGVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGVcbiAgICovXG4gIGxvYWRBamF4Q29udGVudChzbGlkZSkge1xuICAgIGNvbnN0IGZhbmN5Ym94ID0gdGhpcy5mYW5jeWJveDtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIGZhbmN5Ym94LnNob3dMb2FkaW5nKHNsaWRlKTtcblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgaWYgKGZhbmN5Ym94LnN0YXRlID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICBmYW5jeWJveC5oaWRlTG9hZGluZyhzbGlkZSk7XG5cbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICBmYW5jeWJveC5zZXRDb250ZW50KHNsaWRlLCB4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFuY3lib3guc2V0RXJyb3Ioc2xpZGUsIHhoci5zdGF0dXMgPT09IDQwNCA/IFwie3tBSkFYX05PVF9GT1VORH19XCIgOiBcInt7QUpBWF9GT1JCSURERU59fVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZGF0YSA9IHNsaWRlLmFqYXggfHwgbnVsbDtcblxuICAgIHhoci5vcGVuKGRhdGEgPyBcIlBPU1RcIiA6IFwiR0VUXCIsIHNsaWRlLnNyYyk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIik7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJYLVJlcXVlc3RlZC1XaXRoXCIsIFwiWE1MSHR0cFJlcXVlc3RcIik7XG4gICAgeGhyLnNlbmQoZGF0YSk7XG5cbiAgICBzbGlkZS54aHIgPSB4aHI7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBpZnJhbWUgYXMgc2xpZGUgY29udGVudCwgcHJlbG9hZHMgaWYgbmVlZGVkIGJlZm9yZSBkaXNwbGF5aW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxuICAgKi9cbiAgbG9hZElmcmFtZUNvbnRlbnQoc2xpZGUpIHtcbiAgICBjb25zdCBmYW5jeWJveCA9IHRoaXMuZmFuY3lib3g7XG4gICAgY29uc3QgJGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG5cbiAgICAkaWZyYW1lLmNsYXNzTmFtZSA9IFwiZmFuY3lib3hfX2lmcmFtZVwiO1xuXG4gICAgJGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgZmFuY3lib3hfX2lmcmFtZV8ke2ZhbmN5Ym94LmlkfV8ke3NsaWRlLmluZGV4fWApO1xuXG4gICAgJGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJhbGxvd1wiLCBcImF1dG9wbGF5OyBmdWxsc2NyZWVuXCIpO1xuICAgICRpZnJhbWUuc2V0QXR0cmlidXRlKFwic2Nyb2xsaW5nXCIsIFwiYXV0b1wiKTtcblxuICAgIHNsaWRlLiRpZnJhbWUgPSAkaWZyYW1lO1xuXG4gICAgaWYgKHNsaWRlLnR5cGUgIT09IFwiaWZyYW1lXCIgfHwgc2xpZGUucHJlbG9hZCA9PT0gZmFsc2UpIHtcbiAgICAgICRpZnJhbWUuc2V0QXR0cmlidXRlKFwic3JjXCIsIHNsaWRlLnNyYyk7XG5cbiAgICAgIHRoaXMuZmFuY3lib3guc2V0Q29udGVudChzbGlkZSwgJGlmcmFtZSk7XG5cbiAgICAgIHRoaXMucmVzaXplSWZyYW1lKHNsaWRlKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhbmN5Ym94LnNob3dMb2FkaW5nKHNsaWRlKTtcblxuICAgIGNvbnN0ICRjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAkY29udGVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblxuICAgIHRoaXMuZmFuY3lib3guc2V0Q29udGVudChzbGlkZSwgJGNvbnRlbnQpO1xuXG4gICAgJGNvbnRlbnQuYXBwZW5kQ2hpbGQoJGlmcmFtZSk7XG5cbiAgICAkaWZyYW1lLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBmYW5jeWJveC5zZXRFcnJvcihzbGlkZSwgXCJ7e0lGUkFNRV9FUlJPUn19XCIpO1xuICAgIH07XG5cbiAgICAkaWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGZhbmN5Ym94LmhpZGVMb2FkaW5nKHNsaWRlKTtcblxuICAgICAgbGV0IGlzRmlyc3RMb2FkID0gZmFsc2U7XG5cbiAgICAgIGlmICghJGlmcmFtZS5pc1JlYWR5KSB7XG4gICAgICAgICRpZnJhbWUuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIGlzRmlyc3RMb2FkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEkaWZyYW1lLnNyYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAkaWZyYW1lLnBhcmVudE5vZGUuc3R5bGUudmlzaWJpbGl0eSA9IFwiXCI7XG5cbiAgICAgIHRoaXMucmVzaXplSWZyYW1lKHNsaWRlKTtcblxuICAgICAgaWYgKGlzRmlyc3RMb2FkKSB7XG4gICAgICAgIGZhbmN5Ym94LnJldmVhbENvbnRlbnQoc2xpZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAkaWZyYW1lLnNldEF0dHJpYnV0ZShcInNyY1wiLCBzbGlkZS5zcmMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBDU1MgbWF4L21pbiB3aWR0aC9oZWlnaHQgcHJvcGVydGllcyBvZiB0aGUgY29udGVudCB0byBoYXZlIHRoZSBjb3JyZWN0IGFzcGVjdCByYXRpb1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGVcbiAgICovXG4gIHNldEFzcGVjdFJhdGlvKHNsaWRlKSB7XG4gICAgY29uc3QgJGNvbnRlbnQgPSBzbGlkZS4kY29udGVudDtcbiAgICBjb25zdCByYXRpbyA9IHNsaWRlLnJhdGlvO1xuXG4gICAgaWYgKCEkY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB3aWR0aCA9IHNsaWRlLl93aWR0aDtcbiAgICBsZXQgaGVpZ2h0ID0gc2xpZGUuX2hlaWdodDtcblxuICAgIGlmIChyYXRpbyB8fCAod2lkdGggJiYgaGVpZ2h0KSkge1xuICAgICAgT2JqZWN0LmFzc2lnbigkY29udGVudC5zdHlsZSwge1xuICAgICAgICB3aWR0aDogd2lkdGggJiYgaGVpZ2h0ID8gXCIxMDAlXCIgOiBcIlwiLFxuICAgICAgICBoZWlnaHQ6IHdpZHRoICYmIGhlaWdodCA/IFwiMTAwJVwiIDogXCJcIixcbiAgICAgICAgbWF4V2lkdGg6IFwiXCIsXG4gICAgICAgIG1heEhlaWdodDogXCJcIixcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgbWF4V2lkdGggPSAkY29udGVudC5vZmZzZXRXaWR0aDtcbiAgICAgIGxldCBtYXhIZWlnaHQgPSAkY29udGVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIHdpZHRoID0gd2lkdGggfHwgbWF4V2lkdGg7XG4gICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgbWF4SGVpZ2h0O1xuXG4gICAgICAvLyBSZXNpemUgdG8gZml0XG4gICAgICBpZiAod2lkdGggPiBtYXhXaWR0aCB8fCBoZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgbGV0IG1heFJhdGlvID0gTWF0aC5taW4obWF4V2lkdGggLyB3aWR0aCwgbWF4SGVpZ2h0IC8gaGVpZ2h0KTtcblxuICAgICAgICB3aWR0aCA9IHdpZHRoICogbWF4UmF0aW87XG4gICAgICAgIGhlaWdodCA9IGhlaWdodCAqIG1heFJhdGlvO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWNoZWNrIHJhdGlvXG4gICAgICBpZiAoTWF0aC5hYnMod2lkdGggLyBoZWlnaHQgLSByYXRpbykgPiAwLjAxKSB7XG4gICAgICAgIGlmIChyYXRpbyA8IHdpZHRoIC8gaGVpZ2h0KSB7XG4gICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiByYXRpbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIHJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oJGNvbnRlbnQuc3R5bGUsIHtcbiAgICAgICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgaWZyYW1lIGFjY29yZGluZyB0byB0aGUgY29udGVudCBkaW1lbnNpb25zLCBvciBkZWZpbmVkIHNpemVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxuICAgKi9cbiAgcmVzaXplSWZyYW1lKHNsaWRlKSB7XG4gICAgY29uc3QgJGlmcmFtZSA9IHNsaWRlLiRpZnJhbWU7XG5cbiAgICBpZiAoISRpZnJhbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgd2lkdGhfID0gc2xpZGUuX3dpZHRoIHx8IDA7XG4gICAgbGV0IGhlaWdodF8gPSBzbGlkZS5faGVpZ2h0IHx8IDA7XG5cbiAgICBpZiAod2lkdGhfICYmIGhlaWdodF8pIHtcbiAgICAgIHNsaWRlLmF1dG9TaXplID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgJHBhcmVudCA9ICRpZnJhbWUucGFyZW50Tm9kZTtcbiAgICBjb25zdCBwYXJlbnRTdHlsZSA9ICRwYXJlbnQgJiYgJHBhcmVudC5zdHlsZTtcblxuICAgIGlmIChzbGlkZS5wcmVsb2FkICE9PSBmYWxzZSAmJiBzbGlkZS5hdXRvU2l6ZSAhPT0gZmFsc2UgJiYgcGFyZW50U3R5bGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbXBTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgkcGFyZW50KSxcbiAgICAgICAgICBwYWRkaW5nWCA9IHBhcnNlRmxvYXQoY29tcFN0eWxlcy5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KGNvbXBTdHlsZXMucGFkZGluZ1JpZ2h0KSxcbiAgICAgICAgICBwYWRkaW5nWSA9IHBhcnNlRmxvYXQoY29tcFN0eWxlcy5wYWRkaW5nVG9wKSArIHBhcnNlRmxvYXQoY29tcFN0eWxlcy5wYWRkaW5nQm90dG9tKTtcblxuICAgICAgICBjb25zdCBkb2N1bWVudCA9ICRpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudCxcbiAgICAgICAgICAkaHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaHRtbFwiKVswXSxcbiAgICAgICAgICAkYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgLy8gQWxsb3cgY29udGVudCB0byBleHBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICAgIHBhcmVudFN0eWxlLndpZHRoID0gXCJcIjtcblxuICAgICAgICAvLyBHZXQgcmlkIG9mIHZlcnRpY2FsIHNjcm9sbGJhclxuICAgICAgICAkYm9keS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cbiAgICAgICAgd2lkdGhfID0gd2lkdGhfIHx8ICRodG1sLnNjcm9sbFdpZHRoICsgcGFkZGluZ1g7XG5cbiAgICAgICAgcGFyZW50U3R5bGUud2lkdGggPSBgJHt3aWR0aF99cHhgO1xuXG4gICAgICAgICRib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJcIjtcblxuICAgICAgICBwYXJlbnRTdHlsZS5mbGV4ID0gXCIwIDAgYXV0b1wiO1xuICAgICAgICBwYXJlbnRTdHlsZS5oZWlnaHQgPSBgJHskYm9keS5zY3JvbGxIZWlnaHR9cHhgO1xuXG4gICAgICAgIGhlaWdodF8gPSAkaHRtbC5zY3JvbGxIZWlnaHQgKyBwYWRkaW5nWTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdpZHRoXyB8fCBoZWlnaHRfKSB7XG4gICAgICBjb25zdCBuZXdTdHlsZSA9IHtcbiAgICAgICAgZmxleDogXCIwIDEgYXV0b1wiLFxuICAgICAgfTtcblxuICAgICAgaWYgKHdpZHRoXykge1xuICAgICAgICBuZXdTdHlsZS53aWR0aCA9IGAke3dpZHRoX31weGA7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHRfKSB7XG4gICAgICAgIG5ld1N0eWxlLmhlaWdodCA9IGAke2hlaWdodF99cHhgO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKHBhcmVudFN0eWxlLCBuZXdTdHlsZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYENhcm91c2VsLm9uUmVmcmVzaGAgZXZlbnQsXG4gICAqIHRyaWdnZXIgaWZyYW1lIGF1dG9zaXppbmcgYW5kIHNldCBjb250ZW50IGFzcGVjdCByYXRpbyBmb3IgZWFjaCBzbGlkZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZmFuY3lib3hcbiAgICogQHBhcmFtIHtPYmplY3R9IGNhcm91c2VsXG4gICAqL1xuICBvblJlZnJlc2goZmFuY3lib3gsIGNhcm91c2VsKSB7XG4gICAgY2Fyb3VzZWwuc2xpZGVzLmZvckVhY2goKHNsaWRlKSA9PiB7XG4gICAgICBpZiAoIXNsaWRlLiRlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzbGlkZS4kaWZyYW1lKSB7XG4gICAgICAgIHRoaXMucmVzaXplSWZyYW1lKHNsaWRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNsaWRlLnJhdGlvKSB7XG4gICAgICAgIHRoaXMuc2V0QXNwZWN0UmF0aW8oc2xpZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYENhcm91c2VsLm9uQ3JlYXRlU2xpZGVgIGV2ZW50IHRvIHNldCBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYW5jeWJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2Fyb3VzZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXG4gICAqL1xuICBzZXRDb250ZW50KHNsaWRlKSB7XG4gICAgaWYgKCFzbGlkZSB8fCBzbGlkZS5pc0RvbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc2xpZGUudHlwZSkge1xuICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgdGhpcy5mYW5jeWJveC5zZXRDb250ZW50KHNsaWRlLCBzbGlkZS5zcmMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImh0bWw1dmlkZW9cIjpcbiAgICAgICAgdGhpcy5mYW5jeWJveC5zZXRDb250ZW50KFxuICAgICAgICAgIHNsaWRlLFxuICAgICAgICAgIHRoaXMuZmFuY3lib3hcbiAgICAgICAgICAgIC5vcHRpb24oXCJIdG1sLmh0bWw1dmlkZW8udHBsXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx7XFx7c3JjXFx9XFx9L2dpLCBzbGlkZS5zcmMpXG4gICAgICAgICAgICAucmVwbGFjZShcInt7Zm9ybWF0fX1cIiwgc2xpZGUuZm9ybWF0IHx8IChzbGlkZS5odG1sNXZpZGVvICYmIHNsaWRlLmh0bWw1dmlkZW8uZm9ybWF0KSB8fCBcIlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCJ7e3Bvc3Rlcn19XCIsIHNsaWRlLnBvc3RlciB8fCBzbGlkZS50aHVtYiB8fCBcIlwiKVxuICAgICAgICApO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiaW5saW5lXCI6XG4gICAgICBjYXNlIFwiY2xvbmVcIjpcbiAgICAgICAgdGhpcy5sb2FkSW5saW5lQ29udGVudChzbGlkZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiYWpheFwiOlxuICAgICAgICB0aGlzLmxvYWRBamF4Q29udGVudChzbGlkZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicGRmXCI6XG4gICAgICBjYXNlIFwidmlkZW9cIjpcbiAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgc2xpZGUucHJlbG9hZCA9IGZhbHNlO1xuXG4gICAgICBjYXNlIFwiaWZyYW1lXCI6XG4gICAgICAgIHRoaXMubG9hZElmcmFtZUNvbnRlbnQoc2xpZGUpO1xuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzbGlkZS5yYXRpbykge1xuICAgICAgdGhpcy5zZXRBc3BlY3RSYXRpbyhzbGlkZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYENhcm91c2VsLm9uU2VsZWN0U2xpZGVgIGV2ZW50IHRvIHN0YXJ0IHZpZGVvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYW5jeWJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2Fyb3VzZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXG4gICAqL1xuICBvblNlbGVjdFNsaWRlKGZhbmN5Ym94LCBjYXJvdXNlbCwgc2xpZGUpIHtcbiAgICBpZiAoZmFuY3lib3guc3RhdGUgPT09IFwicmVhZHlcIikge1xuICAgICAgdGhpcy5wbGF5VmlkZW8oc2xpZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBiZWdpbiBwbGF5YmFjayBvZiB0aGUgbWVkaWFcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXG4gICAqL1xuICBwbGF5VmlkZW8oc2xpZGUpIHtcbiAgICBpZiAoc2xpZGUudHlwZSA9PT0gXCJodG1sNXZpZGVvXCIgJiYgc2xpZGUudmlkZW8uYXV0b3BsYXkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0ICR2aWRlbyA9IHNsaWRlLiRlbC5xdWVyeVNlbGVjdG9yKFwidmlkZW9cIik7XG5cbiAgICAgICAgaWYgKCR2aWRlbykge1xuICAgICAgICAgIGNvbnN0IHByb21pc2UgPSAkdmlkZW8ucGxheSgpO1xuXG4gICAgICAgICAgaWYgKHByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvbWlzZVxuICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQXV0b3BsYXkgc3RhcnRlZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQXV0b3BsYXkgd2FzIHByZXZlbnRlZC5cbiAgICAgICAgICAgICAgICAkdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICR2aWRlby5wbGF5KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgIH1cblxuICAgIGlmIChzbGlkZS50eXBlICE9PSBcInZpZGVvXCIgfHwgIShzbGlkZS4kaWZyYW1lICYmIHNsaWRlLiRpZnJhbWUuY29udGVudFdpbmRvdykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVwZWF0ZWRseSBjYWxsZWQgdG8gY2hlY2tcbiAgICAvLyBpZiB2aWRlbyBpZnJhbWUgaGFzIGJlZW4gbG9hZGVkIHRvIHNlbmQgbWVzc2FnZSB0byBzdGFydCB0aGUgdmlkZW9cbiAgICBjb25zdCBwb2xsZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoc2xpZGUuc3RhdGUgPT09IFwiZG9uZVwiICYmIHNsaWRlLiRpZnJhbWUgJiYgc2xpZGUuJGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgIGxldCBjb21tYW5kO1xuXG4gICAgICAgIGlmIChzbGlkZS4kaWZyYW1lLmlzUmVhZHkpIHtcbiAgICAgICAgICBpZiAoc2xpZGUudmlkZW8gJiYgc2xpZGUudmlkZW8uYXV0b3BsYXkpIHtcbiAgICAgICAgICAgIGlmIChzbGlkZS52ZW5kb3IgPT0gXCJ5b3V0dWJlXCIpIHtcbiAgICAgICAgICAgICAgY29tbWFuZCA9IHtcbiAgICAgICAgICAgICAgICBldmVudDogXCJjb21tYW5kXCIsXG4gICAgICAgICAgICAgICAgZnVuYzogXCJwbGF5VmlkZW9cIixcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbW1hbmQgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcInBsYXlcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ0cnVlXCIsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIHNsaWRlLiRpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShjb21tYW5kKSwgXCIqXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbGlkZS52ZW5kb3IgPT09IFwieW91dHViZVwiKSB7XG4gICAgICAgICAgY29tbWFuZCA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBcImxpc3RlbmluZ1wiLFxuICAgICAgICAgICAgaWQ6IHNsaWRlLiRpZnJhbWUuZ2V0QXR0cmlidXRlKFwiaWRcIiksXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHNsaWRlLiRpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShjb21tYW5kKSwgXCIqXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNsaWRlLnBvbGxlciA9IHNldFRpbWVvdXQocG9sbGVyLCAyNTApO1xuICAgIH07XG5cbiAgICBwb2xsZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGBDYXJvdXNlbC5vblVuc2VsZWN0U2xpZGVgIGV2ZW50IHRvIHBhdXNlIHZpZGVvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYW5jeWJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2Fyb3VzZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXG4gICAqL1xuICBvblVuc2VsZWN0U2xpZGUoZmFuY3lib3gsIGNhcm91c2VsLCBzbGlkZSkge1xuICAgIGlmIChzbGlkZS50eXBlID09PSBcImh0bWw1dmlkZW9cIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2xpZGUuJGVsLnF1ZXJ5U2VsZWN0b3IoXCJ2aWRlb1wiKS5wYXVzZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY29tbWFuZCA9IGZhbHNlO1xuXG4gICAgaWYgKHNsaWRlLnZlbmRvciA9PSBcInZpbWVvXCIpIHtcbiAgICAgIGNvbW1hbmQgPSB7XG4gICAgICAgIG1ldGhvZDogXCJwYXVzZVwiLFxuICAgICAgICB2YWx1ZTogXCJ0cnVlXCIsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc2xpZGUudmVuZG9yID09PSBcInlvdXR1YmVcIikge1xuICAgICAgY29tbWFuZCA9IHtcbiAgICAgICAgZXZlbnQ6IFwiY29tbWFuZFwiLFxuICAgICAgICBmdW5jOiBcInBhdXNlVmlkZW9cIixcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNvbW1hbmQgJiYgc2xpZGUuJGlmcmFtZSAmJiBzbGlkZS4kaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgIHNsaWRlLiRpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShjb21tYW5kKSwgXCIqXCIpO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChzbGlkZS5wb2xsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYENhcm91c2VsLm9uUmVtb3ZlU2xpZGVgIGV2ZW50IHRvIGRvIGNsZWFuIHVwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYW5jeWJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2Fyb3VzZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXG4gICAqL1xuICBvblJlbW92ZVNsaWRlKGZhbmN5Ym94LCBjYXJvdXNlbCwgc2xpZGUpIHtcbiAgICAvLyBBYm9ydCBhamF4IHJlcXVlc3QgaWYgZXhpc3RzXG4gICAgaWYgKHNsaWRlLnhocikge1xuICAgICAgc2xpZGUueGhyLmFib3J0KCk7XG4gICAgICBzbGlkZS54aHIgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFVubG9hZCBpZnJhbWUgY29udGVudCBpZiBleGlzdHNcbiAgICBpZiAoc2xpZGUuJGlmcmFtZSkge1xuICAgICAgc2xpZGUuJGlmcmFtZS5vbmxvYWQgPSBzbGlkZS4kaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzbGlkZS4kaWZyYW1lLnNyYyA9IFwiLy9hYm91dDpibGFua1wiO1xuICAgICAgc2xpZGUuJGlmcmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgaW5saW5lIGNvbnRlbnRcbiAgICBjb25zdCAkY29udGVudCA9IHNsaWRlLiRjb250ZW50O1xuXG4gICAgaWYgKHNsaWRlLnR5cGUgPT09IFwiaW5saW5lXCIgJiYgJGNvbnRlbnQpIHtcbiAgICAgICRjb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJmYW5jeWJveF9fY29udGVudFwiKTtcblxuICAgICAgaWYgKCRjb250ZW50LnN0eWxlLmRpc3BsYXkgIT09IFwibm9uZVwiKSB7XG4gICAgICAgICRjb250ZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2xpZGUuJGNsb3NlQnV0dG9uKSB7XG4gICAgICBzbGlkZS4kY2xvc2VCdXR0b24ucmVtb3ZlKCk7XG4gICAgICBzbGlkZS4kY2xvc2VCdXR0b24gPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0ICRwbGFjZUhvbGRlciA9ICRjb250ZW50ICYmICRjb250ZW50LiRwbGFjZUhvbGRlcjtcblxuICAgIGlmICgkcGxhY2VIb2xkZXIpIHtcbiAgICAgICRwbGFjZUhvbGRlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgkY29udGVudCwgJHBsYWNlSG9sZGVyKTtcbiAgICAgICRwbGFjZUhvbGRlci5yZW1vdmUoKTtcbiAgICAgICRjb250ZW50LiRwbGFjZUhvbGRlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYHdpbmRvdy5tZXNzYWdlYCBldmVudCB0byBtYXJrIHZpZGVvIGlmcmFtZSBlbGVtZW50IGFzIGByZWFkeWBcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgLSBFdmVudFxuICAgKi9cbiAgb25NZXNzYWdlKGUpIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGUuZGF0YSk7XG5cbiAgICAgIGlmIChlLm9yaWdpbiA9PT0gXCJodHRwczovL3BsYXllci52aW1lby5jb21cIikge1xuICAgICAgICBpZiAoZGF0YS5ldmVudCA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgZm9yIChsZXQgJGlmcmFtZSBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZmFuY3lib3hfX2lmcmFtZVwiKSkge1xuICAgICAgICAgICAgaWYgKCRpZnJhbWUuY29udGVudFdpbmRvdyA9PT0gZS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgJGlmcmFtZS5pc1JlYWR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZS5vcmlnaW4gPT09IFwiaHR0cHM6Ly93d3cueW91dHViZS1ub2Nvb2tpZS5jb21cIikge1xuICAgICAgICBpZiAoZGF0YS5ldmVudCA9PT0gXCJvblJlYWR5XCIpIHtcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkYXRhLmlkKS5pc1JlYWR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7fVxuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIHRoaXMuZmFuY3lib3gub24odGhpcy5ldmVudHMpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMub25NZXNzYWdlLCBmYWxzZSk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5mYW5jeWJveC5vZmYodGhpcy5ldmVudHMpO1xuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMub25NZXNzYWdlLCBmYWxzZSk7XG4gIH1cbn1cblxuLy8gRXhwb3NlIGRlZmF1bHRzXG5IdG1sLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4iLCJpbXBvcnQgeyBleHRlbmQgfSBmcm9tIFwiLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2V4dGVuZC5qc1wiO1xyXG5cclxuaW1wb3J0IHsgUGFuem9vbSB9IGZyb20gXCIuLi8uLi8uLi9QYW56b29tL1Bhbnpvb20uanNcIjtcclxuXHJcbmNvbnN0IGRlZmF1bHRzID0ge1xyXG4gIC8vIENsYXNzIG5hbWUgZm9yIHNsaWRlIGVsZW1lbnQgaW5kaWNhdGluZyB0aGF0IGNvbnRlbnQgY2FuIGJlIHpvb21lZCBpblxyXG4gIGNhblpvb21JbkNsYXNzOiBcImNhbi16b29tX2luXCIsXHJcblxyXG4gIC8vIENsYXNzIG5hbWUgZm9yIHNsaWRlIGVsZW1lbnQgaW5kaWNhdGluZyB0aGF0IGNvbnRlbnQgY2FuIGJlIHpvb21lZCBvdXRcclxuICBjYW5ab29tT3V0Q2xhc3M6IFwiY2FuLXpvb21fb3V0XCIsXHJcblxyXG4gIC8vIERvIHpvb20gYW5pbWF0aW9uIGZyb20gdGh1bWJuYWlsIGltYWdlIHdoZW4gc3RhcnRpbmcgb3IgY2xvc2luZyBmYW5jeWJveFxyXG4gIHpvb206IHRydWUsXHJcblxyXG4gIC8vIEFuaW1hdGUgb3BhY2l0eSB3aGlsZSB6b29taW5nXHJcbiAgem9vbU9wYWNpdHk6IFwiYXV0b1wiLCAvLyBcImF1dG9cIiB8IHRydWUgfCBmYWxzZSxcclxuXHJcbiAgLy8gWm9vbSBhbmltYXRpb24gZnJpY3Rpb25cclxuICB6b29tRnJpY3Rpb246IDAuODIsXHJcblxyXG4gIC8vIERpc2FibGUgem9vbSBhbmltYXRpb24gaWYgdGh1bWJuYWlsIGlzIHZpc2libGUgb25seSBwYXJ0bHlcclxuICBpZ25vcmVDb3ZlcmVkVGh1bWJuYWlsOiBmYWxzZSxcclxuXHJcbiAgLy8gRW5hYmxlIGd1ZXN0dXJlc1xyXG4gIHRvdWNoOiB0cnVlLFxyXG5cclxuICAvLyBBY3Rpb24gdG8gYmUgcGVyZm9ybWVkIHdoZW4gdXNlciBjbGlja3Mgb24gdGhlIGltYWdlXHJcbiAgY2xpY2s6IFwidG9nZ2xlWm9vbVwiLCAvLyBcInRvZ2dsZVpvb21cIiB8IFwibmV4dFwiIHwgXCJjbG9zZVwiIHwgbnVsbFxyXG5cclxuICAvLyBBY3Rpb24gdG8gYmUgcGVyZm9ybWVkIHdoZW4gZG91YmxlLWNsaWNrIGV2ZW50IGlzIGRldGVjdGVkIG9uIHRoZSBpbWFnZVxyXG4gIGRvdWJsZUNsaWNrOiBudWxsLCAvLyBcInRvZ2dsZVpvb21cIiB8IG51bGxcclxuXHJcbiAgLy8gQWN0aW9uIHRvIGJlIHBlcmZvcm1lZCB3aGVuIHVzZXIgcm90YXRlcyBhIHdoZWVsIGJ1dHRvbiBvbiBhIHBvaW50aW5nIGRldmljZVxyXG4gIHdoZWVsOiBcInpvb21cIiwgLy8gXCJ6b29tXCIgfCBcInNsaWRlXCIgfCBcImNsb3NlXCIgfCBudWxsXHJcblxyXG4gIC8vIEhvdyBpbWFnZSBzaG91bGQgYmUgcmVzaXplZCB0byBmaXQgaXRzIGNvbnRhaW5lclxyXG4gIGZpdDogXCJjb250YWluXCIsIC8vIFwiY29udGFpblwiIHwgXCJjb250YWluLXdcIiB8IFwiY292ZXJcIlxyXG5cclxuICAvLyBTaG91bGQgY3JlYXRlIHdyYXBwaW5nIGVsZW1lbnQgYXJvdW5kIHRoZSBpbWFnZVxyXG4gIHdyYXA6IGZhbHNlLFxyXG5cclxuICAvLyBDdXN0b20gUGFuem9vbSBvcHRpb25zXHJcbiAgUGFuem9vbToge1xyXG4gICAgcmF0aW86IDEsXHJcbiAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBJbWFnZSB7XHJcbiAgY29uc3RydWN0b3IoZmFuY3lib3gpIHtcclxuICAgIHRoaXMuZmFuY3lib3ggPSBmYW5jeWJveDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgW1xyXG4gICAgICAvLyBGYW5jeWJveFxyXG4gICAgICBcIm9uUmVhZHlcIixcclxuICAgICAgXCJvbkNsb3NpbmdcIixcclxuICAgICAgXCJvbkRvbmVcIixcclxuXHJcbiAgICAgIC8vIEZhbmN5Ym94LkNhcm91c2VsXHJcbiAgICAgIFwib25QYWdlQ2hhbmdlXCIsXHJcbiAgICAgIFwib25DcmVhdGVTbGlkZVwiLFxyXG4gICAgICBcIm9uUmVtb3ZlU2xpZGVcIixcclxuXHJcbiAgICAgIC8vIEltYWdlIGxvYWQvZXJyb3JcclxuICAgICAgXCJvbkltYWdlU3RhdHVzQ2hhbmdlXCIsXHJcbiAgICBdKSB7XHJcbiAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSB0aGlzW21ldGhvZE5hbWVdLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5ldmVudHMgPSB7XHJcbiAgICAgIHJlYWR5OiB0aGlzLm9uUmVhZHksXHJcbiAgICAgIGNsb3Npbmc6IHRoaXMub25DbG9zaW5nLFxyXG4gICAgICBkb25lOiB0aGlzLm9uRG9uZSxcclxuXHJcbiAgICAgIFwiQ2Fyb3VzZWwuY2hhbmdlXCI6IHRoaXMub25QYWdlQ2hhbmdlLFxyXG4gICAgICBcIkNhcm91c2VsLmNyZWF0ZVNsaWRlXCI6IHRoaXMub25DcmVhdGVTbGlkZSxcclxuICAgICAgXCJDYXJvdXNlbC5yZW1vdmVTbGlkZVwiOiB0aGlzLm9uUmVtb3ZlU2xpZGUsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGByZWFkeWAgZXZlbnQgdG8gc3RhcnQgbG9hZGluZyBjb250ZW50XHJcbiAgICovXHJcbiAgb25SZWFkeSgpIHtcclxuICAgIHRoaXMuZmFuY3lib3guQ2Fyb3VzZWwuc2xpZGVzLmZvckVhY2goKHNsaWRlKSA9PiB7XHJcbiAgICAgIGlmIChzbGlkZS4kZWwpIHtcclxuICAgICAgICB0aGlzLnNldENvbnRlbnQoc2xpZGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBgZG9uZWAgZXZlbnQgdG8gdXBkYXRlIGN1cnNvclxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYW5jeWJveFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxyXG4gICAqL1xyXG4gIG9uRG9uZShmYW5jeWJveCwgc2xpZGUpIHtcclxuICAgIHRoaXMuaGFuZGxlQ3Vyc29yKHNsaWRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBgY2xvc2luZ2AgZXZlbnQgdG8gY2xlYW4gdXAgYWxsIHNsaWRlcyBhbmQgdG8gc3RhcnQgem9vbS1vdXQgYW5pbWF0aW9uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGZhbmN5Ym94XHJcbiAgICovXHJcbiAgb25DbG9zaW5nKGZhbmN5Ym94KSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja1RpbWVyKTtcclxuICAgIHRoaXMuY2xpY2tUaW1lciA9IG51bGw7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGV2ZW50c1xyXG4gICAgZmFuY3lib3guQ2Fyb3VzZWwuc2xpZGVzLmZvckVhY2goKHNsaWRlKSA9PiB7XHJcbiAgICAgIGlmIChzbGlkZS4kaW1hZ2UpIHtcclxuICAgICAgICBzbGlkZS5zdGF0ZSA9IFwiZGVzdHJveVwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2xpZGUuUGFuem9vbSkge1xyXG4gICAgICAgIHNsaWRlLlBhbnpvb20uZGV0YWNoRXZlbnRzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIElmIHBvc3NpYmxlLCBzdGFydCB0aGUgem9vbSBhbmltYXRpb24sIGl0IHdpbGwgaW50ZXJydXB0IHRoZSBkZWZhdWx0IGNsb3NpbmcgcHJvY2Vzc1xyXG4gICAgaWYgKHRoaXMuZmFuY3lib3guc3RhdGUgPT09IFwiY2xvc2luZ1wiICYmIHRoaXMuY2FuWm9vbShmYW5jeWJveC5nZXRTbGlkZSgpKSkge1xyXG4gICAgICB0aGlzLnpvb21PdXQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByb2Nlc3MgYENhcm91c2VsLmNyZWF0ZVNsaWRlYCBldmVudCB0byBjcmVhdGUgaW1hZ2UgY29udGVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYW5jeWJveFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYXJvdXNlbFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxyXG4gICAqL1xyXG4gIG9uQ3JlYXRlU2xpZGUoZmFuY3lib3gsIGNhcm91c2VsLCBzbGlkZSkge1xyXG4gICAgaWYgKHRoaXMuZmFuY3lib3guc3RhdGUgIT09IFwicmVhZHlcIikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRDb250ZW50KHNsaWRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBgQ2Fyb3VzZWwucmVtb3ZlU2xpZGVgIGV2ZW50IHRvIGRvIGNsZWFuIHVwIHRoZSBzbGlkZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYW5jeWJveFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYXJvdXNlbFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxyXG4gICAqL1xyXG4gIG9uUmVtb3ZlU2xpZGUoZmFuY3lib3gsIGNhcm91c2VsLCBzbGlkZSkge1xyXG4gICAgaWYgKHNsaWRlLiRpbWFnZSkge1xyXG4gICAgICBzbGlkZS4kZWwuY2xhc3NMaXN0LnJlbW92ZShmYW5jeWJveC5vcHRpb24oXCJJbWFnZS5jYW5ab29tSW5DbGFzc1wiKSk7XHJcblxyXG4gICAgICBzbGlkZS4kaW1hZ2UucmVtb3ZlKCk7XHJcbiAgICAgIHNsaWRlLiRpbWFnZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNsaWRlLlBhbnpvb20pIHtcclxuICAgICAgc2xpZGUuUGFuem9vbS5kZXN0cm95KCk7XHJcbiAgICAgIHNsaWRlLlBhbnpvb20gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzbGlkZS4kZWwgJiYgc2xpZGUuJGVsLmRhdGFzZXQpIHtcclxuICAgICAgZGVsZXRlIHNsaWRlLiRlbC5kYXRhc2V0LmltYWdlRml0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGQgRE9NIGVsZW1lbnRzIGFuZCBhZGQgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXHJcbiAgICovXHJcbiAgc2V0Q29udGVudChzbGlkZSkge1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBzbGlkZSBzaG91bGQgY29udGFpbiBhbiBpbWFnZVxyXG4gICAgaWYgKHNsaWRlLmlzRG9tIHx8IHNsaWRlLmh0bWwgfHwgKHNsaWRlLnR5cGUgJiYgc2xpZGUudHlwZSAhPT0gXCJpbWFnZVwiKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNsaWRlLiRpbWFnZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc2xpZGUudHlwZSA9IFwiaW1hZ2VcIjtcclxuICAgIHNsaWRlLnN0YXRlID0gXCJsb2FkaW5nXCI7XHJcblxyXG4gICAgLy8gKiBCdWlsZCBsYXlvdXRcclxuICAgIC8vIENvbnRhaW5lclxyXG4gICAgY29uc3QgJGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgJGNvbnRlbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XHJcblxyXG4gICAgLy8gSW1hZ2UgZWxlbWVudFxyXG4gICAgY29uc3QgJGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuXHJcbiAgICAkaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKGV2ZW50KSA9PiB7XHJcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgdGhpcy5vbkltYWdlU3RhdHVzQ2hhbmdlKHNsaWRlKTtcclxuICAgIH0pO1xyXG5cclxuICAgICRpbWFnZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKCkgPT4ge1xyXG4gICAgICB0aGlzLm9uSW1hZ2VTdGF0dXNDaGFuZ2Uoc2xpZGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgJGltYWdlLnNyYyA9IHNsaWRlLnNyYztcclxuICAgICRpbWFnZS5hbHQgPSBcIlwiO1xyXG4gICAgJGltYWdlLmRyYWdnYWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICRpbWFnZS5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX2ltYWdlXCIpO1xyXG5cclxuICAgIGlmIChzbGlkZS5zcmNzZXQpIHtcclxuICAgICAgJGltYWdlLnNldEF0dHJpYnV0ZShcInNyY3NldFwiLCBzbGlkZS5zcmNzZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzbGlkZS5zaXplcykge1xyXG4gICAgICAkaW1hZ2Uuc2V0QXR0cmlidXRlKFwic2l6ZXNcIiwgc2xpZGUuc2l6ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNsaWRlLiRpbWFnZSA9ICRpbWFnZTtcclxuXHJcbiAgICBjb25zdCBzaG91bGRXcmFwID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS53cmFwXCIpO1xyXG5cclxuICAgIGlmIChzaG91bGRXcmFwKSB7XHJcbiAgICAgIGNvbnN0ICR3cmFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgJHdyYXAuY2xhc3NMaXN0LmFkZCh0eXBlb2Ygc2hvdWxkV3JhcCA9PT0gXCJzdHJpbmdcIiA/IHNob3VsZFdyYXAgOiBcImZhbmN5Ym94X19pbWFnZS13cmFwXCIpO1xyXG5cclxuICAgICAgJHdyYXAuYXBwZW5kQ2hpbGQoJGltYWdlKTtcclxuXHJcbiAgICAgICRjb250ZW50LmFwcGVuZENoaWxkKCR3cmFwKTtcclxuXHJcbiAgICAgIHNsaWRlLiR3cmFwID0gJHdyYXA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAkY29udGVudC5hcHBlbmRDaGlsZCgkaW1hZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBkYXRhIGF0dHJpYnV0ZSBpZiBvdGhlciB0aGF0IGRlZmF1bHRcclxuICAgIC8vIGZvciBleGFtcGxlLCBzZXQgYFtkYXRhLWltYWdlLWZpdD1cImNvbnRhaW4td1wiXWBcclxuICAgIHNsaWRlLiRlbC5kYXRhc2V0LmltYWdlRml0ID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5maXRcIik7XHJcblxyXG4gICAgLy8gQXBwZW5kIGNvbnRlbnRcclxuICAgIHRoaXMuZmFuY3lib3guc2V0Q29udGVudChzbGlkZSwgJGNvbnRlbnQpO1xyXG5cclxuICAgIC8vIERpc3BsYXkgbG9hZGluZyBpY29uXHJcbiAgICBpZiAoJGltYWdlLmNvbXBsZXRlIHx8ICRpbWFnZS5lcnJvcikge1xyXG4gICAgICB0aGlzLm9uSW1hZ2VTdGF0dXNDaGFuZ2Uoc2xpZGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5mYW5jeWJveC5zaG93TG9hZGluZyhzbGlkZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgaW1hZ2Ugc3RhdGUgY2hhbmdlLCBkaXNwbGF5IGVycm9yIG9yIHN0YXJ0IHJldmVhbGluZyBpbWFnZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxyXG4gICAqL1xyXG4gIG9uSW1hZ2VTdGF0dXNDaGFuZ2Uoc2xpZGUpIHtcclxuICAgIGNvbnN0ICRpbWFnZSA9IHNsaWRlLiRpbWFnZTtcclxuXHJcbiAgICBpZiAoISRpbWFnZSB8fCBzbGlkZS5zdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKCRpbWFnZS5jb21wbGV0ZSAmJiAkaW1hZ2UubmF0dXJhbFdpZHRoICYmICRpbWFnZS5uYXR1cmFsSGVpZ2h0KSkge1xyXG4gICAgICB0aGlzLmZhbmN5Ym94LnNldEVycm9yKHNsaWRlLCBcInt7SU1BR0VfRVJST1J9fVwiKTtcclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZhbmN5Ym94LmhpZGVMb2FkaW5nKHNsaWRlKTtcclxuXHJcbiAgICBpZiAodGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5maXRcIikgPT09IFwiY29udGFpblwiKSB7XHJcbiAgICAgIHRoaXMuaW5pdFNsaWRlUGFuem9vbShzbGlkZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIGB3aGVlbGAgYW5kIGBjbGlja2AgZXZlbnQgaGFuZGxlclxyXG4gICAgc2xpZGUuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCAoZXZlbnQpID0+IHRoaXMub25XaGVlbChzbGlkZSwgZXZlbnQpLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG4gICAgc2xpZGUuJGNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChldmVudCkgPT4gdGhpcy5vbkNsaWNrKHNsaWRlLCBldmVudCksIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcblxyXG4gICAgdGhpcy5yZXZlYWxDb250ZW50KHNsaWRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE1ha2UgaW1hZ2Ugem9vbWFibGUgYW5kIGRyYWdnYWJsZSB1c2luZyBQYW56b29tXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNsaWRlXHJcbiAgICovXHJcbiAgaW5pdFNsaWRlUGFuem9vbShzbGlkZSkge1xyXG4gICAgaWYgKHNsaWRlLlBhbnpvb20pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vKiBJbml0aWFsaXplIFBhbnpvb21cclxuICAgIHNsaWRlLlBhbnpvb20gPSBuZXcgUGFuem9vbShcclxuICAgICAgc2xpZGUuJGVsLFxyXG4gICAgICBleHRlbmQodHJ1ZSwgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5QYW56b29tXCIsIHt9KSwge1xyXG4gICAgICAgIHZpZXdwb3J0OiBzbGlkZS4kd3JhcCxcclxuICAgICAgICBjb250ZW50OiBzbGlkZS4kaW1hZ2UsXHJcblxyXG4gICAgICAgIHdpZHRoOiBzbGlkZS5fd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0OiBzbGlkZS5faGVpZ2h0LFxyXG5cclxuICAgICAgICB3cmFwSW5uZXI6IGZhbHNlLFxyXG5cclxuICAgICAgICAvLyBBbGxvdyB0byBzZWxlY3QgY2FwdGlvbiB0ZXh0XHJcbiAgICAgICAgdGV4dFNlbGVjdGlvbjogdHJ1ZSxcclxuXHJcbiAgICAgICAgLy8gVG9nZ2xlIGdlc3R1cmVzXHJcbiAgICAgICAgdG91Y2g6IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UudG91Y2hcIiksXHJcblxyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGNsaWNrIGNvbmZsaWN0IHdpdGggZmFuY3lib3ggbWFpbiBjYXJvdXNlbFxyXG4gICAgICAgIHBhbk9ubHlab29tZWQ6IHRydWUsXHJcblxyXG4gICAgICAgIC8vIERpc2FibGUgZGVmYXVsdCBjbGljayAvIHdoZWVsIGV2ZW50cyBhcyBjdXN0b20gZXZlbnQgbGlzdGVuZXJzIHdpbGwgcmVwbGFjZSB0aGVtLFxyXG4gICAgICAgIC8vIGJlY2F1c2UgY2xpY2sgYW5kIHdoZWVsIGV2ZW50cyBzaG91bGQgd29yayB3aXRob3V0IFBhbnpvb21cclxuICAgICAgICBjbGljazogZmFsc2UsXHJcbiAgICAgICAgd2hlZWw6IGZhbHNlLFxyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBzbGlkZS5QYW56b29tLm9uKFwic3RhcnRBbmltYXRpb25cIiwgKCkgPT4ge1xyXG4gICAgICB0aGlzLmZhbmN5Ym94LnRyaWdnZXIoXCJJbWFnZS5zdGFydEFuaW1hdGlvblwiLCBzbGlkZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzbGlkZS5QYW56b29tLm9uKFwiZW5kQW5pbWF0aW9uXCIsICgpID0+IHtcclxuICAgICAgaWYgKHNsaWRlLnN0YXRlID09PSBcInpvb21JblwiKSB7XHJcbiAgICAgICAgdGhpcy5mYW5jeWJveC5kb25lKHNsaWRlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5oYW5kbGVDdXJzb3Ioc2xpZGUpO1xyXG5cclxuICAgICAgdGhpcy5mYW5jeWJveC50cmlnZ2VyKFwiSW1hZ2UuZW5kQW5pbWF0aW9uXCIsIHNsaWRlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHNsaWRlLlBhbnpvb20ub24oXCJhZnRlclVwZGF0ZVwiLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuaGFuZGxlQ3Vyc29yKHNsaWRlKTtcclxuXHJcbiAgICAgIHRoaXMuZmFuY3lib3gudHJpZ2dlcihcIkltYWdlLmFmdGVyVXBkYXRlXCIsIHNsaWRlKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgem9vbS1pbiBhbmltYXRpb24gaWYgcG9zc2libGUsIG9yIHNpbXBseSByZXZlYWwgY29udGVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxyXG4gICAqL1xyXG4gIHJldmVhbENvbnRlbnQoc2xpZGUpIHtcclxuICAgIC8vIEFuaW1hdGUgb25seSBvbiBmaXJzdCBydW5cclxuICAgIGlmIChcclxuICAgICAgdGhpcy5mYW5jeWJveC5DYXJvdXNlbC5wcmV2UGFnZSA9PT0gbnVsbCAmJlxyXG4gICAgICBzbGlkZS5pbmRleCA9PT0gdGhpcy5mYW5jeWJveC5vcHRpb25zLnN0YXJ0SW5kZXggJiZcclxuICAgICAgdGhpcy5jYW5ab29tKHNsaWRlKVxyXG4gICAgKSB7XHJcbiAgICAgIHRoaXMuem9vbUluKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmZhbmN5Ym94LnJldmVhbENvbnRlbnQoc2xpZGUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHpvb20gaW5mbyBmb3Igc2VsZWN0ZWQgc2xpZGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGVcclxuICAgKi9cclxuICBnZXRab29tSW5mbyhzbGlkZSkge1xyXG4gICAgY29uc3QgJHRodW1iID0gc2xpZGUuJHRodW1iLFxyXG4gICAgICB0aHVtYlJlY3QgPSAkdGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXHJcbiAgICAgIHRodW1iV2lkdGggPSB0aHVtYlJlY3Qud2lkdGgsXHJcbiAgICAgIHRodW1iSGVpZ2h0ID0gdGh1bWJSZWN0LmhlaWdodCxcclxuICAgICAgLy9cclxuICAgICAgY29udGVudFJlY3QgPSBzbGlkZS4kY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuICAgICAgY29udGVudFdpZHRoID0gY29udGVudFJlY3Qud2lkdGgsXHJcbiAgICAgIGNvbnRlbnRIZWlnaHQgPSBjb250ZW50UmVjdC5oZWlnaHQsXHJcbiAgICAgIC8vXHJcbiAgICAgIHNoaWZ0ZWRUb3AgPSBjb250ZW50UmVjdC50b3AgLSB0aHVtYlJlY3QudG9wLFxyXG4gICAgICBzaGlmdGVkTGVmdCA9IGNvbnRlbnRSZWN0LmxlZnQgLSB0aHVtYlJlY3QubGVmdDtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBuZWVkIHRvIHVwZGF0ZSBvcGFjaXR5XHJcbiAgICBsZXQgb3BhY2l0eSA9IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2Uuem9vbU9wYWNpdHlcIik7XHJcblxyXG4gICAgaWYgKG9wYWNpdHkgPT09IFwiYXV0b1wiKSB7XHJcbiAgICAgIG9wYWNpdHkgPSBNYXRoLmFicyh0aHVtYldpZHRoIC8gdGh1bWJIZWlnaHQgLSBjb250ZW50V2lkdGggLyBjb250ZW50SGVpZ2h0KSA+IDAuMTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b3A6IHNoaWZ0ZWRUb3AsXHJcbiAgICAgIGxlZnQ6IHNoaWZ0ZWRMZWZ0LFxyXG4gICAgICBzY2FsZTogY29udGVudFdpZHRoICYmIHRodW1iV2lkdGggPyB0aHVtYldpZHRoIC8gY29udGVudFdpZHRoIDogMSxcclxuICAgICAgb3BhY2l0eTogb3BhY2l0eSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgaWYgaXQgaXMgcG9zc2libGUgdG8gZG8gem9vbS1pbiBhbmltYXRpb25cclxuICAgKi9cclxuICBjYW5ab29tKHNsaWRlKSB7XHJcbiAgICBjb25zdCBmYW5jeWJveCA9IHRoaXMuZmFuY3lib3gsXHJcbiAgICAgICRjb250YWluZXIgPSBmYW5jeWJveC4kY29udGFpbmVyO1xyXG5cclxuICAgIGlmICh3aW5kb3cudmlzdWFsVmlld3BvcnQgJiYgd2luZG93LnZpc3VhbFZpZXdwb3J0LnNjYWxlICE9PSAxKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2xpZGUuUGFuem9vbSAmJiAhc2xpZGUuUGFuem9vbS5jb250ZW50LndpZHRoKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLnpvb21cIikgfHwgZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuZml0XCIpICE9PSBcImNvbnRhaW5cIikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgJHRodW1iID0gc2xpZGUuJHRodW1iO1xyXG5cclxuICAgIGlmICghJHRodW1iIHx8IHNsaWRlLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gKiBDaGVjayBpZiB0aHVtYm5haWwgaW1hZ2UgaXMgcmVhbGx5IHZpc2libGVcclxuICAgICRjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X19uby1jbGlja1wiKTtcclxuXHJcbiAgICBjb25zdCByZWN0ID0gJHRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgIGxldCByZXo7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGh1bWJuYWlsIGltYWdlIGlzIGFjdHVhbGx5IHZpc2libGUgb24gdGhlIHNjcmVlblxyXG4gICAgaWYgKHRoaXMuZmFuY3lib3gub3B0aW9uKFwiSW1hZ2UuaWdub3JlQ292ZXJlZFRodW1ibmFpbFwiKSkge1xyXG4gICAgICBjb25zdCB2aXNpYmxlVG9wTGVmdCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocmVjdC5sZWZ0ICsgMSwgcmVjdC50b3AgKyAxKSA9PT0gJHRodW1iO1xyXG4gICAgICBjb25zdCB2aXNpYmxlQm90dG9tUmlnaHQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHJlY3QucmlnaHQgLSAxLCByZWN0LmJvdHRvbSAtIDEpID09PSAkdGh1bWI7XHJcblxyXG4gICAgICByZXogPSB2aXNpYmxlVG9wTGVmdCAmJiB2aXNpYmxlQm90dG9tUmlnaHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXogPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHJlY3QubGVmdCArIHJlY3Qud2lkdGggKiAwLjUsIHJlY3QudG9wICsgcmVjdC5oZWlnaHQgKiAwLjUpID09PSAkdGh1bWI7XHJcbiAgICB9XHJcblxyXG4gICAgJGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiZmFuY3lib3hfX25vLWNsaWNrXCIpO1xyXG5cclxuICAgIHJldHVybiByZXo7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJmb3JtIHpvb20taW4gYW5pbWF0aW9uXHJcbiAgICovXHJcbiAgem9vbUluKCkge1xyXG4gICAgY29uc3QgZmFuY3lib3ggPSB0aGlzLmZhbmN5Ym94LFxyXG4gICAgICBzbGlkZSA9IGZhbmN5Ym94LmdldFNsaWRlKCksXHJcbiAgICAgIFBhbnpvb20gPSBzbGlkZS5QYW56b29tO1xyXG5cclxuICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCBzY2FsZSwgb3BhY2l0eSB9ID0gdGhpcy5nZXRab29tSW5mbyhzbGlkZSk7XHJcblxyXG4gICAgZmFuY3lib3gudHJpZ2dlcihcInJldmVhbFwiLCBzbGlkZSk7XHJcblxyXG4gICAgLy8gU2NhbGUgYW5kIG1vdmUgdG8gc3RhcnQgcG9zaXRpb25cclxuICAgIFBhbnpvb20ucGFuVG8oe1xyXG4gICAgICB4OiBsZWZ0ICogLTEsXHJcbiAgICAgIHk6IHRvcCAqIC0xLFxyXG4gICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgIGZyaWN0aW9uOiAwLFxyXG4gICAgICBpZ25vcmVCb3VuZHM6IHRydWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICBzbGlkZS4kY29udGVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcclxuXHJcbiAgICBzbGlkZS5zdGF0ZSA9IFwiem9vbUluXCI7XHJcblxyXG4gICAgaWYgKG9wYWNpdHkgPT09IHRydWUpIHtcclxuICAgICAgUGFuem9vbS5vbihcImFmdGVyVHJhbnNmb3JtXCIsIChwYW56b29tKSA9PiB7XHJcbiAgICAgICAgaWYgKHNsaWRlLnN0YXRlID09PSBcInpvb21JblwiIHx8IHNsaWRlLnN0YXRlID09PSBcInpvb21PdXRcIikge1xyXG4gICAgICAgICAgcGFuem9vbS4kY29udGVudC5zdHlsZS5vcGFjaXR5ID0gTWF0aC5taW4oMSwgMSAtICgxIC0gcGFuem9vbS5jb250ZW50LnNjYWxlKSAvICgxIC0gc2NhbGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFuaW1hdGUgYmFjayB0byBvcmlnaW5hbCBwb3NpdGlvblxyXG4gICAgUGFuem9vbS5wYW5Ubyh7XHJcbiAgICAgIHg6IDAsXHJcbiAgICAgIHk6IDAsXHJcbiAgICAgIHNjYWxlOiAxLFxyXG4gICAgICBmcmljdGlvbjogdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS56b29tRnJpY3Rpb25cIiksXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmZvcm0gem9vbS1vdXQgYW5pbWF0aW9uXHJcbiAgICovXHJcbiAgem9vbU91dCgpIHtcclxuICAgIGNvbnN0IGZhbmN5Ym94ID0gdGhpcy5mYW5jeWJveCxcclxuICAgICAgc2xpZGUgPSBmYW5jeWJveC5nZXRTbGlkZSgpLFxyXG4gICAgICBQYW56b29tID0gc2xpZGUuUGFuem9vbTtcclxuXHJcbiAgICBpZiAoIVBhbnpvb20pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHNsaWRlLnN0YXRlID0gXCJ6b29tT3V0XCI7XHJcbiAgICBmYW5jeWJveC5zdGF0ZSA9IFwiY3VzdG9tQ2xvc2luZ1wiO1xyXG5cclxuICAgIGlmIChzbGlkZS4kY2FwdGlvbikge1xyXG4gICAgICBzbGlkZS4kY2FwdGlvbi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZnJpY3Rpb24gPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLnpvb21GcmljdGlvblwiKTtcclxuXHJcbiAgICBjb25zdCBhbmltYXRlUG9zaXRpb24gPSAoZXZlbnQpID0+IHtcclxuICAgICAgY29uc3QgeyB0b3AsIGxlZnQsIHNjYWxlLCBvcGFjaXR5IH0gPSB0aGlzLmdldFpvb21JbmZvKHNsaWRlKTtcclxuXHJcbiAgICAgIC8vIEluY3JlYXNlIHNwZWVkIG9uIHRoZSBmaXJzdCBydW4gaWYgb3BhY2l0eSBpcyBub3QgYW5pbWF0ZWRcclxuICAgICAgaWYgKCFldmVudCAmJiAhb3BhY2l0eSkge1xyXG4gICAgICAgIGZyaWN0aW9uICo9IDAuODI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFBhbnpvb20ucGFuVG8oe1xyXG4gICAgICAgIHg6IGxlZnQgKiAtMSxcclxuICAgICAgICB5OiB0b3AgKiAtMSxcclxuICAgICAgICBzY2FsZSxcclxuICAgICAgICBmcmljdGlvbixcclxuICAgICAgICBpZ25vcmVCb3VuZHM6IHRydWUsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gR3JhZHVhbGx5IGluY3JlYXNlIHNwZWVkXHJcbiAgICAgIGZyaWN0aW9uICo9IDAuOTg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBhZ2Ugc2Nyb2xsaW5nIHdpbGwgY2F1c2UgdGh1bWJuYWlsIHRvIGNoYW5nZSBwb3NpdGlvbiBvbiB0aGUgZGlzcGxheSxcclxuICAgIC8vIHRoZXJlZm9yZSBhbmltYXRpb24gZW5kIHBvc2l0aW9uIGhhcyB0byBiZSByZWNhbGN1bGF0ZWQgYWZ0ZXIgZWFjaCBwYWdlIHNjcm9sbFxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgYW5pbWF0ZVBvc2l0aW9uKTtcclxuXHJcbiAgICBQYW56b29tLm9uY2UoXCJlbmRBbmltYXRpb25cIiwgKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBhbmltYXRlUG9zaXRpb24pO1xyXG4gICAgICBmYW5jeWJveC5kZXN0cm95KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhbmltYXRlUG9zaXRpb24oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgdHlwZSBvZiBtb3VzZSBjdXJzb3IgdG8gaW5kaWNhdGUgaWYgY29udGVudCBpcyB6b29tYWJsZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxyXG4gICAqL1xyXG4gIGhhbmRsZUN1cnNvcihzbGlkZSkge1xyXG4gICAgaWYgKHNsaWRlLnR5cGUgIT09IFwiaW1hZ2VcIiB8fCAhc2xpZGUuJGVsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYW56b29tID0gc2xpZGUuUGFuem9vbTtcclxuICAgIGNvbnN0IGNsaWNrQWN0aW9uID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5jbGlja1wiLCBmYWxzZSwgc2xpZGUpO1xyXG4gICAgY29uc3QgdG91Y2hJc0VuYWJsZWQgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLnRvdWNoXCIpO1xyXG5cclxuICAgIGNvbnN0IGNsYXNzTGlzdCA9IHNsaWRlLiRlbC5jbGFzc0xpc3Q7XHJcblxyXG4gICAgY29uc3Qgem9vbUluQ2xhc3MgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLmNhblpvb21JbkNsYXNzXCIpO1xyXG4gICAgY29uc3Qgem9vbU91dENsYXNzID0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJJbWFnZS5jYW5ab29tT3V0Q2xhc3NcIik7XHJcblxyXG4gICAgY2xhc3NMaXN0LnJlbW92ZSh6b29tT3V0Q2xhc3MpO1xyXG4gICAgY2xhc3NMaXN0LnJlbW92ZSh6b29tSW5DbGFzcyk7XHJcblxyXG4gICAgaWYgKHBhbnpvb20gJiYgY2xpY2tBY3Rpb24gPT09IFwidG9nZ2xlWm9vbVwiKSB7XHJcbiAgICAgIGNvbnN0IGNhblpvb21JbiA9XHJcbiAgICAgICAgcGFuem9vbSAmJiBwYW56b29tLmNvbnRlbnQuc2NhbGUgPT09IDEgJiYgcGFuem9vbS5vcHRpb24oXCJtYXhTY2FsZVwiKSAtIHBhbnpvb20uY29udGVudC5zY2FsZSA+IDAuMDE7XHJcblxyXG4gICAgICBpZiAoY2FuWm9vbUluKSB7XHJcbiAgICAgICAgY2xhc3NMaXN0LmFkZCh6b29tSW5DbGFzcyk7XHJcbiAgICAgIH0gZWxzZSBpZiAocGFuem9vbS5jb250ZW50LnNjYWxlID4gMSAmJiAhdG91Y2hJc0VuYWJsZWQpIHtcclxuICAgICAgICBjbGFzc0xpc3QuYWRkKHpvb21PdXRDbGFzcyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoY2xpY2tBY3Rpb24gPT09IFwiY2xvc2VcIikge1xyXG4gICAgICBjbGFzc0xpc3QuYWRkKHpvb21PdXRDbGFzcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYHdoZWVsYCBldmVudFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzbGlkZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxyXG4gICAqL1xyXG4gIG9uV2hlZWwoc2xpZGUsIGV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5mYW5jeWJveC5zdGF0ZSAhPT0gXCJyZWFkeVwiKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mYW5jeWJveC50cmlnZ2VyKFwiSW1hZ2Uud2hlZWxcIiwgZXZlbnQpID09PSBmYWxzZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoICh0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLndoZWVsXCIpKSB7XHJcbiAgICAgIGNhc2UgXCJ6b29tXCI6XHJcbiAgICAgICAgaWYgKHNsaWRlLnN0YXRlID09PSBcImRvbmVcIikge1xyXG4gICAgICAgICAgc2xpZGUuUGFuem9vbSAmJiBzbGlkZS5QYW56b29tLnpvb21XaXRoV2hlZWwoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIFwiY2xvc2VcIjpcclxuICAgICAgICB0aGlzLmZhbmN5Ym94LmNsb3NlKCk7XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBcInNsaWRlXCI6XHJcbiAgICAgICAgdGhpcy5mYW5jeWJveFtldmVudC5kZWx0YVkgPCAwID8gXCJwcmV2XCIgOiBcIm5leHRcIl0oKTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYGNsaWNrYCBhbmQgYGRibGNsaWNrYCBldmVudHNcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2xpZGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICAgKi9cclxuICBvbkNsaWNrKHNsaWRlLCBldmVudCkge1xyXG4gICAgLy8gQ2hlY2sgdGhhdCBjbGlja3Mgc2hvdWxkIGJlIGFsbG93ZWRcclxuICAgIGlmICh0aGlzLmZhbmN5Ym94LnN0YXRlICE9PSBcInJlYWR5XCIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhbnpvb20gPSBzbGlkZS5QYW56b29tO1xyXG5cclxuICAgIGlmIChcclxuICAgICAgcGFuem9vbSAmJlxyXG4gICAgICAocGFuem9vbS5kcmFnUG9zaXRpb24ubWlkUG9pbnQgfHxcclxuICAgICAgICBwYW56b29tLmRyYWdPZmZzZXQueCAhPT0gMCB8fFxyXG4gICAgICAgIHBhbnpvb20uZHJhZ09mZnNldC55ICE9PSAwIHx8XHJcbiAgICAgICAgcGFuem9vbS5kcmFnT2Zmc2V0LnNjYWxlICE9PSAxKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5mYW5jeWJveC5DYXJvdXNlbC5QYW56b29tLmxvY2tBeGlzKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwcm9jZXNzID0gKGFjdGlvbikgPT4ge1xyXG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xyXG4gICAgICAgIGNhc2UgXCJ0b2dnbGVab29tXCI6XHJcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICBzbGlkZS5QYW56b29tICYmIHNsaWRlLlBhbnpvb20uem9vbVdpdGhDbGljayhldmVudCk7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgXCJjbG9zZVwiOlxyXG4gICAgICAgICAgdGhpcy5mYW5jeWJveC5jbG9zZSgpO1xyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIFwibmV4dFwiOlxyXG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgdGhpcy5mYW5jeWJveC5uZXh0KCk7XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgY2xpY2tBY3Rpb24gPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLmNsaWNrXCIpO1xyXG4gICAgY29uc3QgZGJsY2xpY2tBY3Rpb24gPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIkltYWdlLmRvdWJsZUNsaWNrXCIpO1xyXG5cclxuICAgIGlmIChkYmxjbGlja0FjdGlvbikge1xyXG4gICAgICBpZiAodGhpcy5jbGlja1RpbWVyKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xpY2tUaW1lcik7XHJcbiAgICAgICAgdGhpcy5jbGlja1RpbWVyID0gbnVsbDtcclxuXHJcbiAgICAgICAgcHJvY2VzcyhkYmxjbGlja0FjdGlvbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5jbGlja1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmNsaWNrVGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgcHJvY2VzcyhjbGlja0FjdGlvbik7XHJcbiAgICAgICAgfSwgMzAwKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHJvY2VzcyhjbGlja0FjdGlvbik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYENhcm91c2VsLmNoYW5nZWAgZXZlbnQgdG8gcmVzZXQgem9vbSBsZXZlbCBmb3IgYW55IHpvb21lZCBpbi9vdXQgY29udGVudFxyXG4gICAqIGFuZCB0byByZXZlbCBjb250ZW50IG9mIHRoZSBjdXJyZW50IHBhZ2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZmFuY3lib3hcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY2Fyb3VzZWxcclxuICAgKi9cclxuICBvblBhZ2VDaGFuZ2UoZmFuY3lib3gsIGNhcm91c2VsKSB7XHJcbiAgICBjb25zdCBjdXJyU2xpZGUgPSBmYW5jeWJveC5nZXRTbGlkZSgpO1xyXG5cclxuICAgIGNhcm91c2VsLnNsaWRlcy5mb3JFYWNoKChzbGlkZSkgPT4ge1xyXG4gICAgICBpZiAoIXNsaWRlLlBhbnpvb20gfHwgc2xpZGUuc3RhdGUgIT09IFwiZG9uZVwiKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2xpZGUuaW5kZXggIT09IGN1cnJTbGlkZS5pbmRleCkge1xyXG4gICAgICAgIHNsaWRlLlBhbnpvb20ucGFuVG8oe1xyXG4gICAgICAgICAgeDogMCxcclxuICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICBzY2FsZTogMSxcclxuICAgICAgICAgIGZyaWN0aW9uOiAwLjgsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgYXR0YWNoKCkge1xyXG4gICAgdGhpcy5mYW5jeWJveC5vbih0aGlzLmV2ZW50cyk7XHJcbiAgfVxyXG5cclxuICBkZXRhY2goKSB7XHJcbiAgICB0aGlzLmZhbmN5Ym94Lm9mZih0aGlzLmV2ZW50cyk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeHBvc2UgZGVmYXVsdHNcclxuSW1hZ2UuZGVmYXVsdHMgPSBkZWZhdWx0cztcclxuIiwiaW1wb3J0IHsgaXNTY3JvbGxhYmxlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvdXRpbHMvaXNTY3JvbGxhYmxlLmpzXCI7XG5cbmV4cG9ydCBjbGFzcyBTY3JvbGxMb2NrIHtcbiAgY29uc3RydWN0b3IoZmFuY3lib3gpIHtcbiAgICB0aGlzLmZhbmN5Ym94ID0gZmFuY3lib3g7XG4gICAgdGhpcy52aWV3cG9ydCA9IG51bGw7XG5cbiAgICB0aGlzLnBlbmRpbmdVcGRhdGUgPSBudWxsO1xuXG4gICAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIFtcIm9uUmVhZHlcIiwgXCJvblJlc2l6ZVwiLCBcIm9uVG91Y2hzdGFydFwiLCBcIm9uVG91Y2htb3ZlXCJdKSB7XG4gICAgICB0aGlzW21ldGhvZE5hbWVdID0gdGhpc1ttZXRob2ROYW1lXS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGBpbml0TGF5b3V0YCBldmVudCB0byBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIGFuZCByZXNpemUgdmlld3BvcnQgaWYgbmVlZGVkXG4gICAqL1xuICBvblJlYWR5KCkge1xuICAgIC8vKiBTdXBwb3J0IFZpc3VhbCBWaWV3cG9ydCBBUElcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVmlzdWFsX1ZpZXdwb3J0X0FQSVxuICAgIGNvbnN0IHZpZXdwb3J0ID0gd2luZG93LnZpc3VhbFZpZXdwb3J0O1xuXG4gICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICB0aGlzLnN0YXJ0WSA9IDA7XG5cbiAgICAgIHZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG5cbiAgICAgIHRoaXMudXBkYXRlVmlld3BvcnQoKTtcbiAgICB9XG5cbiAgICAvLyogUHJldmVudCBib3VuY2luZyB3aGlsZSBzY3JvbGxpbmcgb24gbW9iaWxlIGRldmljZXNcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblRvdWNoc3RhcnQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5vblRvdWNobW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIC8vKiBQcmV2ZW50IHdpbmRvdyBzY3JvbGxpbmcgd2l0aCBtb3VzZSB3aGVlbFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5vbldoZWVsLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgcmVzaXplYCBldmVudCB0byBjYWxsIGB1cGRhdGVWaWV3cG9ydGBcbiAgICovXG4gIG9uUmVzaXplKCkge1xuICAgIHRoaXMudXBkYXRlVmlld3BvcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZSAkY29udGFpbmVyIHByb3BvcnRpb25hbGx5IHRvIGFjdHVhbGx5IGZpdCBpbnNpZGUgYnJvd3NlcixcbiAgICogZS5nLiwgZGlzYWJsZSB2aWV3cG9ydCB6b29taW5nXG4gICAqL1xuICB1cGRhdGVWaWV3cG9ydCgpIHtcbiAgICBjb25zdCBmYW5jeWJveCA9IHRoaXMuZmFuY3lib3gsXG4gICAgICB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQsXG4gICAgICBzY2FsZSA9IHZpZXdwb3J0LnNjYWxlIHx8IDEsXG4gICAgICAkY29udGFpbmVyID0gZmFuY3lib3guJGNvbnRhaW5lcjtcblxuICAgIGlmICghJGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB3aWR0aCA9IFwiXCIsXG4gICAgICBoZWlnaHQgPSBcIlwiLFxuICAgICAgdHJhbnNmb3JtID0gXCJcIjtcblxuICAgIGlmIChzY2FsZSAtIDEgPiAwLjEpIHtcbiAgICAgIHdpZHRoID0gYCR7dmlld3BvcnQud2lkdGggKiBzY2FsZX1weGA7XG4gICAgICBoZWlnaHQgPSBgJHt2aWV3cG9ydC5oZWlnaHQgKiBzY2FsZX1weGA7XG4gICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt2aWV3cG9ydC5vZmZzZXRMZWZ0fXB4LCAke3ZpZXdwb3J0Lm9mZnNldFRvcH1weCwgMCkgc2NhbGUoJHsxIC8gc2NhbGV9KWA7XG4gICAgfVxuXG4gICAgJGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICRjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICRjb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgdG91Y2hzdGFydGAgZXZlbnQgdG8gbWFyayBkcmFnIHN0YXJ0IHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKi9cbiAgb25Ub3VjaHN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5zdGFydFkgPSBldmVudC50b3VjaGVzID8gZXZlbnQudG91Y2hlc1swXS5zY3JlZW5ZIDogZXZlbnQuc2NyZWVuWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYHRvdWNobW92ZWAgZXZlbnQgdG8gZml4IHNjcm9sbGluZyBvbiBtb2JpbGUgZGV2aWNlcyAoaU9TKVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICovXG4gIG9uVG91Y2htb3ZlKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhcnRZID0gdGhpcy5zdGFydFk7XG4gICAgY29uc3Qgem9vbSA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcblxuICAgIGlmICghZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgfHwgem9vbSAhPT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVsID0gaXNTY3JvbGxhYmxlKGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdKTtcblxuICAgIGlmICghZWwpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImhlaWdodFwiKSwgMTApO1xuXG4gICAgY29uc3QgY3VyWSA9IGV2ZW50LnRvdWNoZXMgPyBldmVudC50b3VjaGVzWzBdLnNjcmVlblkgOiBldmVudC5zY3JlZW5ZO1xuXG4gICAgY29uc3QgaXNBdFRvcCA9IHN0YXJ0WSA8PSBjdXJZICYmIGVsLnNjcm9sbFRvcCA9PT0gMDtcbiAgICBjb25zdCBpc0F0Qm90dG9tID0gc3RhcnRZID49IGN1clkgJiYgZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuc2Nyb2xsVG9wID09PSBoZWlnaHQ7XG5cbiAgICBpZiAoaXNBdFRvcCB8fCBpc0F0Qm90dG9tKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYHdoZWVsYCBldmVudFxuICAgKi9cbiAgb25XaGVlbChldmVudCkge1xuICAgIGlmICghaXNTY3JvbGxhYmxlKGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW4gZXZlcnl0aGluZyB1cFxuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nVXBkYXRlKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnBlbmRpbmdVcGRhdGUpO1xuICAgICAgdGhpcy5wZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQ7XG5cbiAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgIHZpZXdwb3J0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5vblJlc2l6ZSk7XG4gICAgICB0aGlzLnZpZXdwb3J0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5vblRvdWNoc3RhcnQsIGZhbHNlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uVG91Y2htb3ZlLCBmYWxzZSk7XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmZhbmN5Ym94Lm9uKFwiaW5pdExheW91dFwiLCB0aGlzLm9uUmVhZHkpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZmFuY3lib3gub2ZmKFwiaW5pdExheW91dFwiLCB0aGlzLm9uUmVhZHkpO1xuXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGV4dGVuZCB9IGZyb20gXCIuLi8uLi8uLi9zaGFyZWQvdXRpbHMvZXh0ZW5kLmpzXCI7XG5pbXBvcnQgeyBDYXJvdXNlbCB9IGZyb20gXCIuLi8uLi8uLi9DYXJvdXNlbC9DYXJvdXNlbC5qc1wiO1xuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgLy8gVGhlIG1pbmltdW0gbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgZ2FsbGVyeSB0byBkaXNwbGF5IHRodW1ibmFpbHNcbiAgbWluU2xpZGVDb3VudDogMixcblxuICAvLyBNaW5pbXVtIHNjcmVlbiBoZWlnaHQgdG8gZGlzcGxheSB0aHVtYm5haWxzXG4gIG1pblNjcmVlbkhlaWdodDogNTAwLFxuXG4gIC8vIEF1dG9tYXRpY2FsbHkgc2hvdyB0aHVtYm5haWxzIHdoZW4gb3BlbmVkXG4gIGF1dG9TdGFydDogdHJ1ZSxcblxuICAvLyBLZXlib2FyZCBzaG9ydGN1dCB0byB0b2dnbGUgdGh1bWJuYWlsIGNvbnRhaW5lclxuICBrZXk6IFwidFwiLFxuXG4gIC8vIEN1c3RvbWl6ZSBDYXJvdXNlbCBpbnN0YW5jZVxuICBDYXJvdXNlbDoge30sXG5cbiAgdHBsOiBgPGRpdiBjbGFzcz1cImZhbmN5Ym94X190aHVtYlwiIHN0eWxlPVwiYmFja2dyb3VuZC1pbWFnZTp1cmwoJ3t7c3JjfX0nKVwiPjwvZGl2PmAsXG59O1xuXG5leHBvcnQgY2xhc3MgVGh1bWJzIHtcbiAgY29uc3RydWN0b3IoZmFuY3lib3gpIHtcbiAgICB0aGlzLmZhbmN5Ym94ID0gZmFuY3lib3g7XG5cbiAgICB0aGlzLiRjb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBcImluaXRcIjtcblxuICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBbXCJvblByZXBhcmVcIiwgXCJvbkNsb3NpbmdcIiwgXCJvbktleWRvd25cIl0pIHtcbiAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSB0aGlzW21ldGhvZE5hbWVdLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudHMgPSB7XG4gICAgICBwcmVwYXJlOiB0aGlzLm9uUHJlcGFyZSxcbiAgICAgIGNsb3Npbmc6IHRoaXMub25DbG9zaW5nLFxuICAgICAga2V5ZG93bjogdGhpcy5vbktleWRvd24sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGBwcmVwYXJlYCBldmVudCB0byBidWlsZCB0aGUgbGF5b3V0XG4gICAqL1xuICBvblByZXBhcmUoKSB7XG4gICAgLy8gR2V0IHNsaWRlcywgc2tpcCBpZiB0aGUgdG90YWwgbnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bVxuICAgIGNvbnN0IHNsaWRlcyA9IHRoaXMuZ2V0U2xpZGVzKCk7XG5cbiAgICBpZiAoc2xpZGVzLmxlbmd0aCA8IHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVGh1bWJzLm1pblNsaWRlQ291bnRcIikpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBcImRpc2FibGVkXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUaHVtYnMuYXV0b1N0YXJ0XCIpID09PSB0cnVlICYmXG4gICAgICB0aGlzLmZhbmN5Ym94LkNhcm91c2VsLlBhbnpvb20uY29udGVudC5oZWlnaHQgPj0gdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUaHVtYnMubWluU2NyZWVuSGVpZ2h0XCIpXG4gICAgKSB7XG4gICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYGNsb3NpbmdgIGV2ZW50IHRvIGRpc2FibGUgYWxsIGV2ZW50c1xuICAgKi9cbiAgb25DbG9zaW5nKCkge1xuICAgIGlmICh0aGlzLkNhcm91c2VsKSB7XG4gICAgICB0aGlzLkNhcm91c2VsLlBhbnpvb20uZGV0YWNoRXZlbnRzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYGtleWRvd25gIGV2ZW50IHRvIGVuYWJsZSB0aHVtYm5haWwgbGlzdCB0b2dnbGluZyB1c2luZyBrZXlib2FyZCBrZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IGZhbmN5Ym94XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG4gIG9uS2V5ZG93bihmYW5jeWJveCwga2V5KSB7XG4gICAgaWYgKGtleSA9PT0gZmFuY3lib3gub3B0aW9uKFwiVGh1bWJzLmtleVwiKSkge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgbGF5b3V0IGFuZCBpbml0IHRodW1ibmFpbCBDYXJvdXNlbFxuICAgKi9cbiAgYnVpbGQoKSB7XG4gICAgaWYgKHRoaXMuJGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB3cmFwcGluZyBlbGVtZW50IGFuZCBhcHBlbmQgdG8gbGF5b3V0XG4gICAgY29uc3QgJGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICAkY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fdGh1bWJzXCIpO1xuXG4gICAgdGhpcy5mYW5jeWJveC4kY2Fyb3VzZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoJGNvbnRhaW5lciwgdGhpcy5mYW5jeWJveC4kY2Fyb3VzZWwubmV4dFNpYmxpbmcpO1xuXG4gICAgLy8gSW5pdGlhbGlzZSB0aHVtYm5haWwgY2Fyb3VzZWwgd2l0aCBhbGwgc2xpZGVzXG4gICAgdGhpcy5DYXJvdXNlbCA9IG5ldyBDYXJvdXNlbChcbiAgICAgICRjb250YWluZXIsXG4gICAgICBleHRlbmQoXG4gICAgICAgIHRydWUsXG4gICAgICAgIHtcbiAgICAgICAgICBEb3RzOiBmYWxzZSxcbiAgICAgICAgICBOYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICBTeW5jOiB7XG4gICAgICAgICAgICBmcmljdGlvbjogMCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluZmluaXRlOiBmYWxzZSxcbiAgICAgICAgICBjZW50ZXI6IHRydWUsXG4gICAgICAgICAgZmlsbDogdHJ1ZSxcbiAgICAgICAgICBkcmFnRnJlZTogdHJ1ZSxcbiAgICAgICAgICBzbGlkZXNQZXJQYWdlOiAxLFxuICAgICAgICAgIHByZWxvYWQ6IDEsXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVGh1bWJzLkNhcm91c2VsXCIpLFxuICAgICAgICB7XG4gICAgICAgICAgU3luYzoge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmZhbmN5Ym94LkNhcm91c2VsLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2xpZGVzOiB0aGlzLmdldFNsaWRlcygpLFxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIFNsaWRlIGNhcm91c2VsIG9uIHdoZWVsIGV2ZW50XG4gICAgdGhpcy5DYXJvdXNlbC5QYW56b29tLm9uKFwid2hlZWxcIiwgKHBhbnpvb20sIGV2ZW50KSA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLmZhbmN5Ym94W2V2ZW50LmRlbHRhWSA8IDAgPyBcInByZXZcIiA6IFwibmV4dFwiXSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy4kY29udGFpbmVyID0gJGNvbnRhaW5lcjtcblxuICAgIHRoaXMuc3RhdGUgPSBcInZpc2libGVcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFsbCBmYW5jeWJveCBzbGlkZXMgdG8gZ2V0IGFsbCB0aHVtYm5haWwgaW1hZ2VzXG4gICAqL1xuICBnZXRTbGlkZXMoKSB7XG4gICAgY29uc3Qgc2xpZGVzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIHRoaXMuZmFuY3lib3guaXRlbXMpIHtcbiAgICAgIGNvbnN0IHRodW1iID0gc2xpZGUudGh1bWI7XG5cbiAgICAgIGlmICh0aHVtYikge1xuICAgICAgICBzbGlkZXMucHVzaCh7XG4gICAgICAgICAgaHRtbDogdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUaHVtYnMudHBsXCIpLnJlcGxhY2UoL1xce1xce3NyY1xcfVxcfS9naSwgdGh1bWIpLFxuICAgICAgICAgIGN1c3RvbUNsYXNzOiBgaGFzLXRodW1iIGhhcy0ke3NsaWRlLnR5cGUgfHwgXCJpbWFnZVwifWAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzbGlkZXM7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIHZpc2liaWxpdHkgb2YgdGh1bWJuYWlsIGxpc3RcbiAgICogVGlwOiB5b3UgY2FuIHVzZSBgRmFuY3lib3guZ2V0SW5zdGFuY2UoKS5wbHVnaW5zLlRodW1icy50b2dnbGUoKWAgZnJvbSBhbnl3aGVyZSBpbiB5b3VyIGNvZGVcbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aHVtYm5haWwgbGlzdFxuICAgKi9cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgdGhpcy4kY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXG4gICAgICB0aGlzLkNhcm91c2VsLlBhbnpvb20uYXR0YWNoRXZlbnRzKCk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBcInZpc2libGVcIjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aHVtYm5haWwgbGlzdFxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgIHRoaXMuQ2Fyb3VzZWwuUGFuem9vbS5kZXRhY2hFdmVudHMoKTtcblxuICAgICAgdGhpcy4kY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgICAgdGhpcy5zdGF0ZSA9IFwiaGlkZGVuXCI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBzdGF0ZVxuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5DYXJvdXNlbCkge1xuICAgICAgdGhpcy5DYXJvdXNlbC5kZXN0cm95KCk7XG4gICAgICB0aGlzLkNhcm91c2VsID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kY29udGFpbmVyKSB7XG4gICAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlKCk7XG4gICAgICB0aGlzLiRjb250YWluZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBcImluaXRcIjtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmZhbmN5Ym94Lm9uKHRoaXMuZXZlbnRzKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmZhbmN5Ym94Lm9mZih0aGlzLmV2ZW50cyk7XG5cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxufVxuXG4vLyBFeHBvc2UgZGVmYXVsdHNcblRodW1icy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuIiwiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gXCIuLi8uLi8uLi9zaGFyZWQvdXRpbHMvaXNQbGFpbk9iamVjdC5qc1wiO1xyXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tIFwiLi4vLi4vLi4vc2hhcmVkL3V0aWxzL2V4dGVuZC5qc1wiO1xyXG5cclxuaW1wb3J0IHsgRnVsbHNjcmVlbiB9IGZyb20gXCIuLi8uLi8uLi9zaGFyZWQvdXRpbHMvRnVsbHNjcmVlbi5qc1wiO1xyXG5pbXBvcnQgeyBTbGlkZXNob3cgfSBmcm9tIFwiLi4vLi4vLi4vc2hhcmVkL3V0aWxzL1NsaWRlc2hvdy5qc1wiO1xyXG5cclxuY29uc3QgZGVmYXVsdHMgPSB7XHJcbiAgLy8gV2hhdCB0b29sYmFyIGl0ZW1zIHRvIGRpc3BsYXlcclxuICBkaXNwbGF5OiBbXHJcbiAgICBcImNvdW50ZXJcIixcclxuICAgIC8vXCJwcmV2XCIsXHJcbiAgICAvL1wibmV4dFwiLFxyXG4gICAgLy9cImRvd25sb2FkXCIsXHJcbiAgICBcInpvb21cIixcclxuICAgIFwic2xpZGVzaG93XCIsXHJcbiAgICBcImZ1bGxzY3JlZW5cIixcclxuICAgIFwidGh1bWJzXCIsXHJcbiAgICBcImNsb3NlXCIsXHJcbiAgXSxcclxuXHJcbiAgLy8gT25seSBjcmVhdGUgYSB0b29sYmFyIGl0ZW0gaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGltYWdlIGluIHRoZSBncm91cFxyXG4gIGF1dG9FbmFibGU6IHRydWUsXHJcblxyXG4gIC8vIFRvb2xiYXIgaXRlbXM7IGNhbiBiZSBsaW5rcywgYnV0dG9ucyBvciBgZGl2YCBlbGVtZW50c1xyXG4gIGl0ZW1zOiB7XHJcbiAgICBjb3VudGVyOiB7XHJcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIixcclxuICAgICAgdHlwZTogXCJkaXZcIixcclxuICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2NvdW50ZXJcIixcclxuICAgICAgaHRtbDogJzxzcGFuIGRhdGEtZmFuY3lib3gtaW5kZXg9XCJcIj48L3NwYW4+Jm5ic3A7LyZuYnNwOzxzcGFuIGRhdGEtZmFuY3lib3gtY291bnQ9XCJcIj48L3NwYW4+JyxcclxuICAgICAgYXR0cjogeyB0YWJpbmRleDogLTEgfSxcclxuICAgIH0sXHJcbiAgICBwcmV2OiB7XHJcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXHJcbiAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLXByZXZcIixcclxuICAgICAgbGFiZWw6IFwiUFJFVlwiLFxyXG4gICAgICBodG1sOiAnPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0xNSA0bC04IDggOCA4XCIvPjwvc3ZnPicsXHJcbiAgICAgIGF0dHI6IHsgXCJkYXRhLWZhbmN5Ym94LXByZXZcIjogXCJcIiB9LFxyXG4gICAgfSxcclxuICAgIG5leHQ6IHtcclxuICAgICAgdHlwZTogXCJidXR0b25cIixcclxuICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2J1dHRvbi0tbmV4dFwiLFxyXG4gICAgICBsYWJlbDogXCJORVhUXCIsXHJcbiAgICAgIGh0bWw6ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48cGF0aCBkPVwiTTggNGw4IDgtOCA4XCIvPjwvc3ZnPicsXHJcbiAgICAgIGF0dHI6IHsgXCJkYXRhLWZhbmN5Ym94LW5leHRcIjogXCJcIiB9LFxyXG4gICAgfSxcclxuICAgIGZ1bGxzY3JlZW46IHtcclxuICAgICAgdHlwZTogXCJidXR0b25cIixcclxuICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2J1dHRvbi0tZnVsbHNjcmVlblwiLFxyXG4gICAgICBsYWJlbDogXCJUT0dHTEVfRlVMTFNDUkVFTlwiLFxyXG4gICAgICBodG1sOiBgPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgICA8Zz48cGF0aCBkPVwiTTMgOCBWM2g1XCI+PC9wYXRoPjxwYXRoIGQ9XCJNMjEgOFYzaC01XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOCAyMUgzdi01XCI+PC9wYXRoPjxwYXRoIGQ9XCJNMTYgMjFoNXYtNVwiPjwvcGF0aD48L2c+XHJcbiAgICAgICAgICAgICAgICA8Zz48cGF0aCBkPVwiTTcgMnY1SDJNMTcgMnY1aDVNMiAxN2g1djVNMjIgMTdoLTV2NVwiLz48L2c+XHJcbiAgICAgICAgICAgIDwvc3ZnPmAsXHJcbiAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBpZiAoRnVsbHNjcmVlbi5lbGVtZW50KCkpIHtcclxuICAgICAgICAgIEZ1bGxzY3JlZW4uZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBGdWxsc2NyZWVuLmFjdGl2YXRlKHRoaXMuZmFuY3lib3guJGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIHNsaWRlc2hvdzoge1xyXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxyXG4gICAgICBjbGFzczogXCJmYW5jeWJveF9fYnV0dG9uLS1zbGlkZXNob3dcIixcclxuICAgICAgbGFiZWw6IFwiVE9HR0xFX1NMSURFU0hPV1wiLFxyXG4gICAgICBodG1sOiBgPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgICA8Zz48cGF0aCBkPVwiTTYgNHYxNlwiLz48cGF0aCBkPVwiTTIwIDEyTDYgMjBcIi8+PHBhdGggZD1cIk0yMCAxMkw2IDRcIi8+PC9nPlxyXG4gICAgICAgICAgICAgICAgPGc+PHBhdGggZD1cIk03IDR2MTVNMTcgNHYxNVwiLz48L2c+XHJcbiAgICAgICAgICAgIDwvc3ZnPmAsXHJcbiAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICB0aGlzLlNsaWRlc2hvdy50b2dnbGUoKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB6b29tOiB7XHJcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXHJcbiAgICAgIGNsYXNzOiBcImZhbmN5Ym94X19idXR0b24tLXpvb21cIixcclxuICAgICAgbGFiZWw6IFwiVE9HR0xFX1pPT01cIixcclxuICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxjaXJjbGUgY3g9XCIxMFwiIGN5PVwiMTBcIiByPVwiN1wiPjwvY2lyY2xlPjxwYXRoIGQ9XCJNMTYgMTYgTDIxIDIxXCI+PC9zdmc+JyxcclxuICAgICAgY2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHBhbnpvb20gPSB0aGlzLmZhbmN5Ym94LmdldFNsaWRlKCkuUGFuem9vbTtcclxuXHJcbiAgICAgICAgaWYgKHBhbnpvb20pIHtcclxuICAgICAgICAgIHBhbnpvb20udG9nZ2xlWm9vbSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBkb3dubG9hZDoge1xyXG4gICAgICB0eXBlOiBcImxpbmtcIixcclxuICAgICAgbGFiZWw6IFwiRE9XTkxPQURcIixcclxuICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2J1dHRvbi0tZG93bmxvYWRcIixcclxuICAgICAgaHRtbDogJzxzdmcgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxwYXRoIGQ9XCJNMTIgMTVWM20wIDEybC00LTRtNCA0bDQtNE0yIDE3bC42MiAyLjQ4QTIgMiAwIDAwNC41NiAyMWgxNC44OGEyIDIgMCAwMDEuOTQtMS41MUwyMiAxN1wiLz48L3N2Zz4nLFxyXG4gICAgICBjbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgdGh1bWJzOiB7XHJcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXHJcbiAgICAgIGxhYmVsOiBcIlRPR0dMRV9USFVNQlNcIixcclxuICAgICAgY2xhc3M6IFwiZmFuY3lib3hfX2J1dHRvbi0tdGh1bWJzXCIsXHJcbiAgICAgIGh0bWw6ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48Y2lyY2xlIGN4PVwiNFwiIGN5PVwiNFwiIHI9XCIxXCIgLz48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjRcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAxMiA0KVwiLz48Y2lyY2xlIGN4PVwiMjBcIiBjeT1cIjRcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAyMCA0KVwiLz48Y2lyY2xlIGN4PVwiNFwiIGN5PVwiMTJcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCA0IDEyKVwiLz48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjFcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgMTIgMTIpXCIvPjxjaXJjbGUgY3g9XCIyMFwiIGN5PVwiMTJcIiByPVwiMVwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAyMCAxMilcIi8+PGNpcmNsZSBjeD1cIjRcIiBjeT1cIjIwXCIgcj1cIjFcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgNCAyMClcIi8+PGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIyMFwiIHI9XCIxXCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDEyIDIwKVwiLz48Y2lyY2xlIGN4PVwiMjBcIiBjeT1cIjIwXCIgcj1cIjFcIiB0cmFuc2Zvcm09XCJyb3RhdGUoOTAgMjAgMjApXCIvPjwvc3ZnPicsXHJcbiAgICAgIGNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGh1bWJzID0gdGhpcy5mYW5jeWJveC5wbHVnaW5zLlRodW1icztcclxuXHJcbiAgICAgICAgaWYgKHRodW1icykge1xyXG4gICAgICAgICAgdGh1bWJzLnRvZ2dsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBjbG9zZToge1xyXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxyXG4gICAgICBsYWJlbDogXCJDTE9TRVwiLFxyXG4gICAgICBjbGFzczogXCJmYW5jeWJveF9fYnV0dG9uLS1jbG9zZVwiLFxyXG4gICAgICBodG1sOiAnPHN2ZyB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PHBhdGggZD1cIk0yMCAyMEw0IDRtMTYgMEw0IDIwXCI+PC9wYXRoPjwvc3ZnPicsXHJcbiAgICAgIGF0dHI6IHsgXCJkYXRhLWZhbmN5Ym94LWNsb3NlXCI6IFwiXCIsIHRhYmluZGV4OiAwIH0sXHJcbiAgICB9LFxyXG4gIH0sXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgVG9vbGJhciB7XHJcbiAgY29uc3RydWN0b3IoZmFuY3lib3gpIHtcclxuICAgIHRoaXMuZmFuY3lib3ggPSBmYW5jeWJveDtcclxuXHJcbiAgICB0aGlzLiRjb250YWluZXIgPSBudWxsO1xyXG4gICAgdGhpcy5zdGF0ZSA9IFwiaW5pdFwiO1xyXG5cclxuICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBbXHJcbiAgICAgIFwib25Jbml0XCIsXHJcbiAgICAgIFwib25QcmVwYXJlXCIsXHJcbiAgICAgIFwib25Eb25lXCIsXHJcbiAgICAgIFwib25LZXlkb3duXCIsXHJcbiAgICAgIFwib25DbG9zaW5nXCIsXHJcbiAgICAgIFwib25DaGFuZ2VcIixcclxuICAgICAgXCJvblNldHRsZVwiLFxyXG4gICAgICBcIm9uUmVmcmVzaFwiLFxyXG4gICAgXSkge1xyXG4gICAgICB0aGlzW21ldGhvZE5hbWVdID0gdGhpc1ttZXRob2ROYW1lXS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZXZlbnRzID0ge1xyXG4gICAgICBpbml0OiB0aGlzLm9uSW5pdCxcclxuICAgICAgcHJlcGFyZTogdGhpcy5vblByZXBhcmUsXHJcbiAgICAgIGRvbmU6IHRoaXMub25Eb25lLFxyXG4gICAgICBrZXlkb3duOiB0aGlzLm9uS2V5ZG93bixcclxuICAgICAgY2xvc2luZzogdGhpcy5vbkNsb3NpbmcsXHJcblxyXG4gICAgICAvLyBDbGVhciBTbGlkZXNob3cgd2hlbiB1c2VyIHN0cnRzIHRvIGNoYW5nZSBjdXJyZW50IHNsaWRlXHJcbiAgICAgIFwiQ2Fyb3VzZWwuY2hhbmdlXCI6IHRoaXMub25DaGFuZ2UsXHJcblxyXG4gICAgICAvLyBTZXQgdGltZXIgYWZ0ZXIgY2Fyb3VzZWwgY2hhbmdlcyBjdXJyZW50IHNsaWRlOyBkZWFjdGl2ZSBpZiBsYXN0IHNsaWRlIGlzIHJlYWNoZWRcclxuICAgICAgXCJDYXJvdXNlbC5zZXR0bGVcIjogdGhpcy5vblNldHRsZSxcclxuXHJcbiAgICAgIC8vIERlYWN0aXZhdGUgU2xpZGVzaG93IG9uIHVzZXIgaW50ZXJhY3Rpb25cclxuICAgICAgXCJDYXJvdXNlbC5QYW56b29tLnRvdWNoU3RhcnRcIjogKCkgPT4gdGhpcy5vblJlZnJlc2goKSxcclxuXHJcbiAgICAgIFwiSW1hZ2Uuc3RhcnRBbmltYXRpb25cIjogKGZhbmN5Ym94LCBzbGlkZSkgPT4gdGhpcy5vblJlZnJlc2goc2xpZGUpLFxyXG4gICAgICBcIkltYWdlLmFmdGVyVXBkYXRlXCI6IChmYW5jeWJveCwgc2xpZGUpID0+IHRoaXMub25SZWZyZXNoKHNsaWRlKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBvbkluaXQoKSB7XHJcbiAgICAvLyBEaXNhYmxlIHNlbGYgaWYgY3VycmVudCBncm91cCBkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZSBpbWFnZVxyXG4gICAgaWYgKHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVG9vbGJhci5hdXRvRW5hYmxlXCIpKSB7XHJcbiAgICAgIGxldCBoYXNJbWFnZSA9IGZhbHNlO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuZmFuY3lib3guaXRlbXMpIHtcclxuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImltYWdlXCIpIHtcclxuICAgICAgICAgIGhhc0ltYWdlID0gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFoYXNJbWFnZSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImRpc2FibGVkXCI7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzYWJsZSB0aGUgY3JlYXRpb24gb2YgYSBjbG9zZSBidXR0b24sIGlmIG9uZSBleGlzdHMgaW4gdGhlIHRvb2xiYXJcclxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuZmFuY3lib3gub3B0aW9uKFwiVG9vbGJhci5kaXNwbGF5XCIpKSB7XHJcbiAgICAgIGNvbnN0IGlkID0gaXNQbGFpbk9iamVjdChrZXkpID8ga2V5LmlkIDoga2V5O1xyXG5cclxuICAgICAgaWYgKGlkID09PSBcImNsb3NlXCIpIHtcclxuICAgICAgICB0aGlzLmZhbmN5Ym94Lm9wdGlvbnMuY2xvc2VCdXR0b24gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uUHJlcGFyZSgpIHtcclxuICAgIGNvbnN0IGZhbmN5Ym94ID0gdGhpcy5mYW5jeWJveDtcclxuICAgIC8vIFNraXAgaWYgZGlzYWJsZWRcclxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImluaXRcIikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5idWlsZCgpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlKCk7XHJcblxyXG4gICAgdGhpcy5TbGlkZXNob3cgPSBuZXcgU2xpZGVzaG93KGZhbmN5Ym94KTtcclxuXHJcbiAgICBpZiAoIWZhbmN5Ym94LkNhcm91c2VsLnByZXZQYWdlKSB7XHJcbiAgICAgIGlmIChmYW5jeWJveC5vcHRpb24oXCJzbGlkZXNob3cuYXV0b1N0YXJ0XCIpKSB7XHJcbiAgICAgICAgdGhpcy5TbGlkZXNob3cuYWN0aXZhdGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZhbmN5Ym94Lm9wdGlvbihcImZ1bGxzY3JlZW4uYXV0b1N0YXJ0XCIpICYmICFGdWxsc2NyZWVuLmVsZW1lbnQoKSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBGdWxsc2NyZWVuLmFjdGl2YXRlKGZhbmN5Ym94LiRjb250YWluZXIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkZzQ2hhbmdlKCkge1xyXG4gICAgd2luZG93LnNjcm9sbFRvKEZ1bGxzY3JlZW4ucGFnZVhPZmZzZXQsIEZ1bGxzY3JlZW4ucGFnZVlPZmZzZXQpO1xyXG4gIH1cclxuXHJcbiAgb25TZXR0bGUoKSB7XHJcbiAgICBjb25zdCBmYW5jeWJveCA9IHRoaXMuZmFuY3lib3g7XHJcbiAgICBjb25zdCBzbGlkZXNob3cgPSB0aGlzLlNsaWRlc2hvdztcclxuXHJcbiAgICBpZiAoc2xpZGVzaG93ICYmIHNsaWRlc2hvdy5pc0FjdGl2ZSgpKSB7XHJcbiAgICAgIGlmIChmYW5jeWJveC5nZXRTbGlkZSgpLmluZGV4ID09PSBmYW5jeWJveC5DYXJvdXNlbC5zbGlkZXMubGVuZ3RoIC0gMSAmJiAhZmFuY3lib3gub3B0aW9uKFwiaW5maW5pdGVcIikpIHtcclxuICAgICAgICBzbGlkZXNob3cuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICB9IGVsc2UgaWYgKGZhbmN5Ym94LmdldFNsaWRlKCkuc3RhdGUgPT09IFwiZG9uZVwiKSB7XHJcbiAgICAgICAgc2xpZGVzaG93LnNldFRpbWVyKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQ2hhbmdlKCkge1xyXG4gICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbiAgICBpZiAodGhpcy5TbGlkZXNob3cgJiYgdGhpcy5TbGlkZXNob3cuaXNBY3RpdmUoKSkge1xyXG4gICAgICB0aGlzLlNsaWRlc2hvdy5jbGVhclRpbWVyKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkRvbmUoZmFuY3lib3gsIHNsaWRlKSB7XHJcbiAgICBjb25zdCBzbGlkZXNob3cgPSB0aGlzLlNsaWRlc2hvdztcclxuXHJcbiAgICBpZiAoc2xpZGUuaW5kZXggPT09IGZhbmN5Ym94LmdldFNsaWRlKCkuaW5kZXgpIHtcclxuICAgICAgdGhpcy51cGRhdGUoKTtcclxuXHJcbiAgICAgIGlmIChzbGlkZXNob3cgJiYgc2xpZGVzaG93LmlzQWN0aXZlKCkpIHtcclxuICAgICAgICBpZiAoIWZhbmN5Ym94Lm9wdGlvbihcImluZmluaXRlXCIpICYmIHNsaWRlLmluZGV4ID09PSBmYW5jeWJveC5DYXJvdXNlbC5zbGlkZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgc2xpZGVzaG93LmRlYWN0aXZhdGUoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2xpZGVzaG93LnNldFRpbWVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvblJlZnJlc2goc2xpZGUpIHtcclxuICAgIGlmICghc2xpZGUgfHwgc2xpZGUuaW5kZXggPT09IHRoaXMuZmFuY3lib3guZ2V0U2xpZGUoKS5pbmRleCkge1xyXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuU2xpZGVzaG93ICYmIHRoaXMuU2xpZGVzaG93LmlzQWN0aXZlKCkgJiYgKCFzbGlkZSB8fCBzbGlkZS5zdGF0ZSA9PT0gXCJkb25lXCIpKSB7XHJcbiAgICAgICAgdGhpcy5TbGlkZXNob3cuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbktleWRvd24oZmFuY3lib3gsIGtleSwgZXZlbnQpIHtcclxuICAgIGlmIChrZXkgPT09IFwiIFwiICYmIHRoaXMuU2xpZGVzaG93KSB7XHJcbiAgICAgIHRoaXMuU2xpZGVzaG93LnRvZ2dsZSgpO1xyXG5cclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9uQ2xvc2luZygpIHtcclxuICAgIGlmICh0aGlzLlNsaWRlc2hvdykge1xyXG4gICAgICB0aGlzLlNsaWRlc2hvdy5kZWFjdGl2YXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgdGhpcy5vbkZzQ2hhbmdlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBsaW5rLCBidXR0b24gb3IgYGRpdmAgZWxlbWVudCBmb3IgdGhlIHRvb2xiYXJcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICogQHJldHVybnMgSFRNTEVsZW1lbnRcclxuICAgKi9cclxuICBjcmVhdGVFbGVtZW50KG9iaikge1xyXG4gICAgbGV0ICRlbDtcclxuXHJcbiAgICBpZiAob2JqLnR5cGUgPT09IFwiZGl2XCIpIHtcclxuICAgICAgJGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQob2JqLnR5cGUgPT09IFwibGlua1wiID8gXCJhXCIgOiBcImJ1dHRvblwiKTtcclxuICAgICAgJGVsLmNsYXNzTGlzdC5hZGQoXCJjYXJvdXNlbF9fYnV0dG9uXCIpO1xyXG4gICAgfVxyXG5cclxuICAgICRlbC5pbm5lckhUTUwgPSBvYmouaHRtbDtcclxuXHJcbiAgICAkZWwuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgb2JqLnRhYmluZGV4IHx8IDApO1xyXG5cclxuICAgIGlmIChvYmouY2xhc3MpIHtcclxuICAgICAgJGVsLmNsYXNzTGlzdC5hZGQoLi4ub2JqLmNsYXNzLnNwbGl0KFwiIFwiKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBwcm9wIGluIG9iai5hdHRyKSB7XHJcbiAgICAgICRlbC5zZXRBdHRyaWJ1dGUocHJvcCwgb2JqLmF0dHJbcHJvcF0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvYmoubGFiZWwpIHtcclxuICAgICAgJGVsLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRoaXMuZmFuY3lib3gubG9jYWxpemUoYHt7JHtvYmoubGFiZWx9fX1gKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG9iai5jbGljaykge1xyXG4gICAgICAkZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9iai5jbGljay5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob2JqLmlkID09PSBcInByZXZcIikge1xyXG4gICAgICAkZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1mYW5jeWJveC1wcmV2XCIsIFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvYmouaWQgPT09IFwibmV4dFwiKSB7XHJcbiAgICAgICRlbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWZhbmN5Ym94LW5leHRcIiwgXCJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgJHN2ZyA9ICRlbC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpO1xyXG5cclxuICAgIGlmICgkc3ZnKSB7XHJcbiAgICAgICRzdmcuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKTtcclxuICAgICAgJHN2Zy5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xyXG4gICAgICAkc3ZnLnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICRlbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXHJcbiAgICovXHJcbiAgYnVpbGQoKSB7XHJcbiAgICB0aGlzLmNsZWFudXAoKTtcclxuXHJcbiAgICBjb25zdCBhbGxfaXRlbXMgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcIlRvb2xiYXIuaXRlbXNcIik7XHJcbiAgICBjb25zdCBhbGxfZ3JvdXBzID0gW1xyXG4gICAgICB7XHJcbiAgICAgICAgcG9zaXRpb246IFwibGVmdFwiLFxyXG4gICAgICAgIGl0ZW1zOiBbXSxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBcImNlbnRlclwiLFxyXG4gICAgICAgIGl0ZW1zOiBbXSxcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXHJcbiAgICAgICAgaXRlbXM6IFtdLFxyXG4gICAgICB9LFxyXG4gICAgXTtcclxuXHJcbiAgICBjb25zdCB0aHVtYnMgPSB0aGlzLmZhbmN5Ym94LnBsdWdpbnMuVGh1bWJzO1xyXG5cclxuICAgIC8vIDFzdCBzdGVwIC0gZ3JvdXAgdG9vbGJhciBlbGVtZW50cyBieSBwb3NpdGlvblxyXG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5mYW5jeWJveC5vcHRpb24oXCJUb29sYmFyLmRpc3BsYXlcIikpIHtcclxuICAgICAgbGV0IGlkLCBpdGVtO1xyXG5cclxuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoa2V5KSkge1xyXG4gICAgICAgIGlkID0ga2V5LmlkO1xyXG4gICAgICAgIGl0ZW0gPSBleHRlbmQoe30sIGFsbF9pdGVtc1tpZF0sIGtleSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWQgPSBrZXk7XHJcbiAgICAgICAgaXRlbSA9IGFsbF9pdGVtc1tpZF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChbXCJjb3VudGVyXCIsIFwibmV4dFwiLCBcInByZXZcIiwgXCJzbGlkZXNob3dcIl0uaW5jbHVkZXMoaWQpICYmIHRoaXMuZmFuY3lib3guaXRlbXMubGVuZ3RoIDwgMikge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaWQgPT09IFwiZnVsbHNjcmVlblwiKSB7XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCB8fCB3aW5kb3cuZnVsbFNjcmVlbikge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZnVsbHNjcmVlbmNoYW5nZVwiLCB0aGlzLm9uRnNDaGFuZ2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaWQgPT09IFwidGh1bWJzXCIgJiYgKCF0aHVtYnMgfHwgdGh1bWJzLnN0YXRlID09PSBcImRpc2FibGVkXCIpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgcG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8IFwicmlnaHRcIjtcclxuXHJcbiAgICAgIGxldCBncm91cCA9IGFsbF9ncm91cHMuZmluZCgob2JqKSA9PiBvYmoucG9zaXRpb24gPT09IHBvc2l0aW9uKTtcclxuXHJcbiAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgIGdyb3VwLml0ZW1zLnB1c2goaXRlbSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyAyc3Qgc3RlcCAtIGNyZWF0ZSBET00gZWxlbWVudHNcclxuICAgIGNvbnN0ICRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZmFuY3lib3hfX3Rvb2xiYXJcIik7XHJcblxyXG4gICAgZm9yIChjb25zdCBncm91cCBvZiBhbGxfZ3JvdXBzKSB7XHJcbiAgICAgIGlmIChncm91cC5pdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCAkd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgJHdyYXAuY2xhc3NMaXN0LmFkZChcImZhbmN5Ym94X190b29sYmFyX19pdGVtc1wiKTtcclxuICAgICAgICAkd3JhcC5jbGFzc0xpc3QuYWRkKGBmYW5jeWJveF9fdG9vbGJhcl9faXRlbXMtLSR7Z3JvdXAucG9zaXRpb259YCk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIGdyb3VwLml0ZW1zKSB7XHJcbiAgICAgICAgICAkd3JhcC5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUVsZW1lbnQob2JqKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkY29udGFpbmVyLmFwcGVuZENoaWxkKCR3cmFwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0b29sYmFyIGNvbnRhaW5lciB0byBET01cclxuICAgIHRoaXMuZmFuY3lib3guJGNhcm91c2VsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCRjb250YWluZXIsIHRoaXMuZmFuY3lib3guJGNhcm91c2VsKTtcclxuXHJcbiAgICB0aGlzLiRjb250YWluZXIgPSAkY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGVsZW1lbnQgc3RhdGUgZGVwZW5kaW5nIG9uIGluZGV4IG9mIGN1cnJlbnQgc2xpZGVcclxuICAgKi9cclxuICB1cGRhdGUoKSB7XHJcbiAgICBjb25zdCBzbGlkZSA9IHRoaXMuZmFuY3lib3guZ2V0U2xpZGUoKTtcclxuICAgIGNvbnN0IGlkeCA9IHNsaWRlLmluZGV4O1xyXG4gICAgY29uc3QgY250ID0gdGhpcy5mYW5jeWJveC5pdGVtcy5sZW5ndGg7XHJcblxyXG4gICAgLy8gRG93bmxvYWQgbGlua3NcclxuICAgIC8vID09PT1cclxuICAgIGNvbnN0IHNyYyA9IHNsaWRlLmRvd25sb2FkU3JjIHx8IChzbGlkZS50eXBlID09PSBcImltYWdlXCIgJiYgIXNsaWRlLmVycm9yID8gc2xpZGUuc3JjIDogbnVsbCk7XHJcblxyXG4gICAgZm9yIChjb25zdCAkZWwgb2YgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJhLmZhbmN5Ym94X19idXR0b24tLWRvd25sb2FkXCIpKSB7XHJcbiAgICAgIGlmIChzcmMpIHtcclxuICAgICAgICAkZWwucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgJGVsLnJlbW92ZUF0dHJpYnV0ZShcInRhYmluZGV4XCIpO1xyXG5cclxuICAgICAgICAkZWwuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBzcmMpO1xyXG4gICAgICAgICRlbC5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCBzcmMpO1xyXG4gICAgICAgICRlbC5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJGVsLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpO1xyXG4gICAgICAgICRlbC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCAtMSk7XHJcblxyXG4gICAgICAgICRlbC5yZW1vdmVBdHRyaWJ1dGUoXCJocmVmXCIpO1xyXG4gICAgICAgICRlbC5yZW1vdmVBdHRyaWJ1dGUoXCJkb3dubG9hZFwiKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFpvb20gYnV0dG9uXHJcbiAgICAvLyA9PT1cclxuICAgIGNvbnN0IHBhbnpvb20gPSBzbGlkZS5QYW56b29tO1xyXG4gICAgY29uc3QgY2FuWm9vbSA9IHBhbnpvb20gJiYgcGFuem9vbS5vcHRpb24oXCJtYXhTY2FsZVwiKSA+IHBhbnpvb20ub3B0aW9uKFwiYmFzZVNjYWxlXCIpO1xyXG5cclxuICAgIGZvciAoY29uc3QgJGVsIG9mIHRoaXMuZmFuY3lib3guJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmZhbmN5Ym94X19idXR0b24tLXpvb21cIikpIHtcclxuICAgICAgaWYgKGNhblpvb20pIHtcclxuICAgICAgICAkZWwucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgJGVsLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ291bnRlclxyXG4gICAgLy8gPT09PVxyXG4gICAgZm9yIChjb25zdCAkZWwgb2YgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1mYW5jeWJveC1pbmRleF1cIikpIHtcclxuICAgICAgJGVsLmlubmVySFRNTCA9IHNsaWRlLmluZGV4ICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0ICRlbCBvZiB0aGlzLmZhbmN5Ym94LiRjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWZhbmN5Ym94LWNvdW50XVwiKSkge1xyXG4gICAgICAkZWwuaW5uZXJIVE1MID0gY250O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc2FibGUgcHJldmlvdXMvbmV4dCBsaW5rcyBpZiBnYWxsZXJ5IGlzIG5vdCBpbmZpbml0ZSBhbmQgaGFzIHJlYWNoZWQgc3RhcnQvZW5kXHJcbiAgICAvLyA9PT1cclxuICAgIGlmICghdGhpcy5mYW5jeWJveC5vcHRpb24oXCJpbmZpbml0ZVwiKSkge1xyXG4gICAgICBmb3IgKGNvbnN0ICRlbCBvZiB0aGlzLmZhbmN5Ym94LiRjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWZhbmN5Ym94LXByZXZdXCIpKSB7XHJcbiAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xyXG4gICAgICAgICAgJGVsLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkZWwucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGNvbnN0ICRlbCBvZiB0aGlzLmZhbmN5Ym94LiRjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWZhbmN5Ym94LW5leHRdXCIpKSB7XHJcbiAgICAgICAgaWYgKGlkeCA9PT0gY250IC0gMSkge1xyXG4gICAgICAgICAgJGVsLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAkZWwucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjbGVhbnVwKCkge1xyXG4gICAgaWYgKHRoaXMuU2xpZGVzaG93ICYmIHRoaXMuU2xpZGVzaG93LmlzQWN0aXZlKCkpIHtcclxuICAgICAgdGhpcy5TbGlkZXNob3cuY2xlYXJUaW1lcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLiRjb250YWluZXIpIHtcclxuICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuJGNvbnRhaW5lciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBhdHRhY2goKSB7XHJcbiAgICB0aGlzLmZhbmN5Ym94Lm9uKHRoaXMuZXZlbnRzKTtcclxuICB9XHJcblxyXG4gIGRldGFjaCgpIHtcclxuICAgIHRoaXMuZmFuY3lib3gub2ZmKHRoaXMuZXZlbnRzKTtcclxuXHJcbiAgICB0aGlzLmNsZWFudXAoKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIEV4cG9zZSBkZWZhdWx0c1xyXG5Ub29sYmFyLmRlZmF1bHRzID0gZGVmYXVsdHM7XHJcbiIsImltcG9ydCB7IFNjcm9sbExvY2sgfSBmcm9tIFwiLi9TY3JvbGxMb2NrL1Njcm9sbExvY2suanNcIjtcbmltcG9ydCB7IFRodW1icyB9IGZyb20gXCIuL1RodW1icy9UaHVtYnMuanNcIjtcbmltcG9ydCB7IEh0bWwgfSBmcm9tIFwiLi9IdG1sL0h0bWwuanNcIjtcbmltcG9ydCB7IEltYWdlIH0gZnJvbSBcIi4vSW1hZ2UvSW1hZ2UuanNcIjtcbmltcG9ydCB7IEhhc2ggfSBmcm9tIFwiLi9IYXNoL0hhc2guanNcIjtcbmltcG9ydCB7IFRvb2xiYXIgfSBmcm9tIFwiLi9Ub29sYmFyL1Rvb2xiYXIuanNcIjtcblxuZXhwb3J0IGNvbnN0IFBsdWdpbnMgPSB7XG4gIFNjcm9sbExvY2ssXG4gIFRodW1icyxcbiAgSHRtbCxcbiAgVG9vbGJhcixcbiAgSW1hZ2UsXG4gIEhhc2gsXG59O1xuIiwiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSBcIi4uL3NoYXJlZC91dGlscy9leHRlbmQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3NoYXJlZC91dGlscy9yb3VuZC5qc1wiO1xuaW1wb3J0IHsgaXNTY3JvbGxhYmxlIH0gZnJvbSBcIi4uL3NoYXJlZC91dGlscy9pc1Njcm9sbGFibGUuanNcIjtcblxuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXIgfSBmcm9tIFwiLi4vc2hhcmVkL3V0aWxzL1Jlc2l6ZU9ic2VydmVyLmpzXCI7XG5pbXBvcnQgeyBQb2ludGVyVHJhY2tlciwgZ2V0TWlkcG9pbnQsIGdldERpc3RhbmNlIH0gZnJvbSBcIi4uL3NoYXJlZC91dGlscy9Qb2ludGVyVHJhY2tlci5qc1wiO1xuXG5pbXBvcnQgeyBnZXRUZXh0Tm9kZUZyb21Qb2ludCB9IGZyb20gXCIuLi9zaGFyZWQvdXRpbHMvZ2V0VGV4dE5vZGVGcm9tUG9pbnQuanNcIjtcblxuaW1wb3J0IHsgZ2V0RnVsbFdpZHRoLCBnZXRGdWxsSGVpZ2h0LCBjYWxjdWxhdGVBc3BlY3RSYXRpb0ZpdCB9IGZyb20gXCIuLi9zaGFyZWQvdXRpbHMvZ2V0RGltZW5zaW9ucy5qc1wiO1xuXG5pbXBvcnQgeyBCYXNlIH0gZnJvbSBcIi4uL3NoYXJlZC9CYXNlL0Jhc2UuanNcIjtcblxuaW1wb3J0IHsgUGx1Z2lucyB9IGZyb20gXCIuL3BsdWdpbnMvaW5kZXguanNcIjtcblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIC8vIEVuYWJsZSB0b3VjaCBndWVzdHVyZXNcbiAgdG91Y2g6IHRydWUsXG5cbiAgLy8gRW5hYmxlIHpvb21pbmdcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBFbmFibGUgcGluY2ggZ2VzdHVyZSB0byB6b29tIGluL291dCB1c2luZyB0d28gZmluZ2Vyc1xuICBwaW5jaFRvWm9vbTogdHJ1ZSxcblxuICAvLyBEaXNhYmxlIGRyYWdnaW5nIGlmIHNjYWxlIGxldmVsIGlzIGVxdWFsIHRvIHZhbHVlIG9mIGBiYXNlU2NhbGVgIG9wdGlvblxuICBwYW5Pbmx5Wm9vbWVkOiBmYWxzZSxcblxuICAvLyBMb2NrIGF4aXMgd2hpbGUgZHJhZ2dpbmcsXG4gIC8vIHBvc3NpYmxlIHZhbHVlczogZmFsc2UgfCBcInhcIiB8IFwieVwiIHwgXCJ4eVwiXG4gIGxvY2tBeGlzOiBmYWxzZSxcblxuICAvLyAqIEFsbCBmcmljdGlvbiB2YWx1ZXMgYXJlIGluc2lkZSBbMCwgMSkgaW50ZXJ2YWwsXG4gIC8vICogd2hlcmUgMCB3b3VsZCBjaGFuZ2UgaW5zdGFudGx5LCBidXQgMC45OSB3b3VsZCB1cGRhdGUgZXh0cmVtZWx5IHNsb3dseVxuXG4gIC8vIEZyaWN0aW9uIHdoaWxlIHBhbm5pbmcvZHJhZ2dpbmdcbiAgZnJpY3Rpb246IDAuNjQsXG5cbiAgLy8gRnJpY3Rpb24gd2hpbGUgZGVjZWxlcmF0aW5nIGFmdGVyIGRyYWcgZW5kXG4gIGRlY2VsRnJpY3Rpb246IDAuODgsXG5cbiAgLy8gRnJpY3Rpb24gd2hpbGUgc2NhbGluZ1xuICB6b29tRnJpY3Rpb246IDAuNzQsXG5cbiAgLy8gQm91bmNpbmVzcyBhZnRlciBoaXR0aW5nIHRoZSBlZGdlXG4gIGJvdW5jZUZvcmNlOiAwLjIsXG5cbiAgLy8gSW5pdGlhbCBzY2FsZSBsZXZlbFxuICBiYXNlU2NhbGU6IDEsXG5cbiAgLy8gTWluaW11bSBzY2FsZSBsZXZlbFxuICBtaW5TY2FsZTogMSxcblxuICAvLyBNYXhpbXVtIHNjYWxlIGxldmVsXG4gIG1heFNjYWxlOiAyLFxuXG4gIC8vIERlZmF1bHQgc2NhbGUgc3RlcCB3aGlsZSB6b29taW5nXG4gIHN0ZXA6IDAuNSxcblxuICAvLyBBbGxvdyB0byBzZWxlY3QgdGV4dCxcbiAgLy8gaWYgZW5hYmxlZCwgZHJhZ2dpbmcgd2lsbCBiZSBkaXNhYmxlZCB3aGVuIHRleHQgc2VsZWN0aW9uIGlzIGRldGVjdGVkXG4gIHRleHRTZWxlY3Rpb246IGZhbHNlLFxuXG4gIC8vIEFkZCBgY2xpY2tgIGV2ZW50IGxpc3RlbmVyLFxuICAvLyBwb3NzaWJsZSB2YWx1ZXM6IHRydWUgfCBmYWxzZSB8IGZ1bmN0aW9uIHwgXCJ0b2dnbGVab29tXCJcbiAgY2xpY2s6IFwidG9nZ2xlWm9vbVwiLFxuXG4gIC8vIEFkZCBgd2hlZWxgIGV2ZW50IGxpc3RlbmVyLFxuICAvLyBwb3NzaWJsZSB2YWx1ZXM6IHRydWUgfCBmYWxzZSB8IGZ1bmN0aW9uIHwgIFwiem9vbVwiXG4gIHdoZWVsOiBcInpvb21cIixcblxuICAvLyBWYWx1ZSBmb3Igem9vbSBvbiBtb3VzZSB3aGVlbFxuICB3aGVlbEZhY3RvcjogNDIsXG5cbiAgLy8gTnVtYmVyIG9mIHdoZWVsIGV2ZW50cyBhZnRlciB3aGljaCBpdCBzaG91bGQgc3RvcCBwcmV2ZW50aW5nIGRlZmF1bHQgYmVoYXZpb3VyIG9mIG1vdXNlIHdoZWVsXG4gIHdoZWVsTGltaXQ6IDUsXG5cbiAgLy8gQ2xhc3MgbmFtZSBhZGRlZCB0byBgJHZpZXdwb3J0YCBlbGVtZW50IHRvIGluZGljYXRlIGlmIGNvbnRlbnQgaXMgZHJhZ2dhYmxlXG4gIGRyYWdnYWJsZUNsYXNzOiBcImlzLWRyYWdnYWJsZVwiLFxuXG4gIC8vIENsYXNzIG5hbWUgYWRkZWQgdG8gYCR2aWV3cG9ydGAgZWxlbWVudCB0byBpbmRpY2F0ZSB0aGF0IHVzZXIgaXMgY3VycmVudGx5IGRyYWdnaW5nXG4gIGRyYWdnaW5nQ2xhc3M6IFwiaXMtZHJhZ2dpbmdcIixcblxuICAvLyBDb250ZW50IHdpbGwgYmUgc2NhbGVkIGJ5IHRoaXMgbnVtYmVyLFxuICAvLyB0aGlzIGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIHJldHVybiBhIG51bWJlciwgZm9yIGV4YW1wbGU6XG4gIC8vIHJhdGlvOiBmdW5jdGlvbigpIHsgcmV0dXJuIDEgLyAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgfVxuICByYXRpbzogMSxcbn07XG5cbmV4cG9ydCBjbGFzcyBQYW56b29tIGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBQYW56b29tIGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RzIFBhbnpvb21cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gJHZpZXdwb3J0IFBhbnpvb20gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgUGFuem9vbVxuICAgKi9cbiAgY29uc3RydWN0b3IoJGNvbnRhaW5lciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucykpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFwiaW5pdFwiO1xuXG4gICAgdGhpcy4kY29udGFpbmVyID0gJGNvbnRhaW5lcjtcblxuICAgIC8vIEJpbmQgZXZlbnQgaGFuZGxlcnMgZm9yIHJlZmVyZW5jYWJpbGl0eVxuICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBbXCJvbkxvYWRcIiwgXCJvbldoZWVsXCIsIFwib25DbGlja1wiXSkge1xuICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IHRoaXNbbWV0aG9kTmFtZV0uYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRMYXlvdXQoKTtcblxuICAgIHRoaXMucmVzZXRWYWx1ZXMoKTtcblxuICAgIHRoaXMuYXR0YWNoUGx1Z2lucyhQYW56b29tLlBsdWdpbnMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKFwiaW5pdFwiKTtcblxuICAgIHRoaXMudXBkYXRlTWV0cmljcygpO1xuXG4gICAgdGhpcy5hdHRhY2hFdmVudHMoKTtcblxuICAgIHRoaXMudHJpZ2dlcihcInJlYWR5XCIpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9uKFwiY2VudGVyT25TdGFydFwiKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBcInJlYWR5XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFuVG8oe1xuICAgICAgICBmcmljdGlvbjogMCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgICRjb250YWluZXIuX19QYW56b29tID0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgcmVmZXJlbmNlcyB0byBjb250YWluZXIsIHZpZXdwb3J0IGFuZCBjb250ZW50IGVsZW1lbnRzXG4gICAqL1xuICBpbml0TGF5b3V0KCkge1xuICAgIGNvbnN0ICRjb250YWluZXIgPSB0aGlzLiRjb250YWluZXI7XG5cbiAgICAvLyBNYWtlIHN1cmUgY29udGVudCBlbGVtZW50IGV4aXN0c1xuICAgIGlmICghKCRjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhbnpvb206IENvbnRhaW5lciBub3QgZm91bmRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgJGNvbnRlbnQgPSB0aGlzLm9wdGlvbihcImNvbnRlbnRcIikgfHwgJGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLnBhbnpvb21fX2NvbnRlbnRcIik7XG5cbiAgICAvLyBNYWtlIHN1cmUgY29udGVudCBlbGVtZW50IGV4aXN0c1xuICAgIGlmICghJGNvbnRlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhbnpvb206IENvbnRlbnQgbm90IGZvdW5kXCIpO1xuICAgIH1cblxuICAgIHRoaXMuJGNvbnRlbnQgPSAkY29udGVudDtcblxuICAgIGxldCAkdmlld3BvcnQgPSB0aGlzLm9wdGlvbihcInZpZXdwb3J0XCIpIHx8ICRjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5wYW56b29tX192aWV3cG9ydFwiKTtcblxuICAgIGlmICghJHZpZXdwb3J0ICYmIHRoaXMub3B0aW9uKFwid3JhcElubmVyXCIpICE9PSBmYWxzZSkge1xuICAgICAgJHZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICR2aWV3cG9ydC5jbGFzc0xpc3QuYWRkKFwicGFuem9vbV9fdmlld3BvcnRcIik7XG5cbiAgICAgICR2aWV3cG9ydC5hcHBlbmQoLi4uJGNvbnRhaW5lci5jaGlsZE5vZGVzKTtcblxuICAgICAgJGNvbnRhaW5lci5hcHBlbmRDaGlsZCgkdmlld3BvcnQpO1xuICAgIH1cblxuICAgIHRoaXMuJHZpZXdwb3J0ID0gJHZpZXdwb3J0IHx8ICRjb250ZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBpbnN0YW5jZSB2YXJpYWJsZXMgdG8gZGVmYXVsdCB2YWx1ZXNcbiAgICovXG4gIHJlc2V0VmFsdWVzKCkge1xuICAgIHRoaXMudXBkYXRlUmF0ZSA9IHRoaXMub3B0aW9uKFwidXBkYXRlUmF0ZVwiLCAvaVBob25lfGlQYWR8aVBvZHxBbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA/IDI1MCA6IDI0KTtcblxuICAgIHRoaXMuY29udGFpbmVyID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgfTtcblxuICAgIHRoaXMudmlld3BvcnQgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICB9O1xuXG4gICAgdGhpcy5jb250ZW50ID0ge1xuICAgICAgLy8gRnVsbCBjb250ZW50IGRpbWVuc2lvbnMgKG5hdHVyYWxXaWR0aC9uYXR1cmFsSGVpZ2h0IGZvciBpbWFnZXMpXG4gICAgICBvcmlnV2lkdGg6IDAsXG4gICAgICBvcmlnSGVpZ2h0OiAwLFxuXG4gICAgICAvLyBDdXJyZW50IGRpbWVuc2lvbnMgb2YgdGhlIGNvbnRlbnRcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuXG4gICAgICAvLyBDdXJyZW50IHBvc2l0aW9uOyB0aGVzZSB2YWx1ZXMgcmVmbGVjdCBDU1MgYHRyYW5zZm9ybWAgdmFsdWVcbiAgICAgIHg6IHRoaXMub3B0aW9uKFwieFwiLCAwKSxcbiAgICAgIHk6IHRoaXMub3B0aW9uKFwieVwiLCAwKSxcblxuICAgICAgLy8gQ3VycmVudCBzY2FsZTsgZG9lcyBub3QgcmVmbGVjdCBDU1MgYHRyYW5zZm9ybWAgdmFsdWVcbiAgICAgIHNjYWxlOiB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKSxcbiAgICB9O1xuXG4gICAgLy8gRW5kIHZhbHVlcyBvZiBjdXJyZW50IHBhbiAvIHpvb20gYW5pbWF0aW9uXG4gICAgdGhpcy50cmFuc2Zvcm0gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHNjYWxlOiAxLFxuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0RHJhZ1Bvc2l0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGBsb2FkYCBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgb25Mb2FkKGV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVNZXRyaWNzKCk7XG5cbiAgICB0aGlzLnBhblRvKHsgc2NhbGU6IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpLCBmcmljdGlvbjogMCB9KTtcblxuICAgIHRoaXMudHJpZ2dlcihcImxvYWRcIiwgZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsb3Nlc3QoXCJbY29udGVudGVkaXRhYmxlXVwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNraXAgaWYgdGV4dCBpcyBzZWxlY3RlZFxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9uKFwidGV4dFNlbGVjdGlvblwiKSAmJlxuICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCkubGVuZ3RoICYmXG4gICAgICAhKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuaGFzQXR0cmlidXRlKFwiZGF0YS1mYW5jeWJveC1jbG9zZVwiKSlcbiAgICApIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLiRjb250ZW50LmdldENsaWVudFJlY3RzKClbMF07XG5cbiAgICAvLyBDaGVjayBpZiBjb250YWluZXIgaGFzIGNoYW5nZWQgcG9zaXRpb24gKGZvciBleGFtcGxlLCB3aGVuIGN1cnJlbnQgaW5zdGFuY2UgaXMgaW5zaWRlIGFub3RoZXIgb25lKVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBcInJlYWR5XCIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5kcmFnUG9zaXRpb24ubWlkUG9pbnQgfHxcbiAgICAgICAgTWF0aC5hYnMocmVjdC50b3AgLSB0aGlzLmRyYWdTdGFydC5yZWN0LnRvcCkgPiAxIHx8XG4gICAgICAgIE1hdGguYWJzKHJlY3QubGVmdCAtIHRoaXMuZHJhZ1N0YXJ0LnJlY3QubGVmdCkgPiAxXG4gICAgICApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRyaWdnZXIoXCJjbGlja1wiLCBldmVudCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9uKFwiem9vbVwiKSAmJiB0aGlzLm9wdGlvbihcImNsaWNrXCIpID09PSBcInRvZ2dsZVpvb21cIikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICB0aGlzLnpvb21XaXRoQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYHdoZWVsYCBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgb25XaGVlbChldmVudCkge1xuICAgIGlmICh0aGlzLnRyaWdnZXIoXCJ3aGVlbFwiLCBldmVudCkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9uKFwiem9vbVwiKSAmJiB0aGlzLm9wdGlvbihcIndoZWVsXCIpKSB7XG4gICAgICB0aGlzLnpvb21XaXRoV2hlZWwoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2Ugem9vbSBsZXZlbCBkZXBlbmRpbmcgb24gc2Nyb2xsIGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBgd2hlZWxgIGV2ZW50XG4gICAqL1xuICB6b29tV2l0aFdoZWVsKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuY2hhbmdlZERlbHRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2hhbmdlZERlbHRhID0gMDtcbiAgICB9XG5cbiAgICBjb25zdCBkZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCAtZXZlbnQuZGVsdGFZIHx8IC1ldmVudC5kZWx0YVggfHwgZXZlbnQud2hlZWxEZWx0YSB8fCAtZXZlbnQuZGV0YWlsKSk7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLmNvbnRlbnQuc2NhbGU7XG5cbiAgICBsZXQgbmV3U2NhbGUgPSAoc2NhbGUgKiAoMTAwICsgZGVsdGEgKiB0aGlzLm9wdGlvbihcIndoZWVsRmFjdG9yXCIpKSkgLyAxMDA7XG5cbiAgICBpZiAoXG4gICAgICAoZGVsdGEgPCAwICYmIE1hdGguYWJzKHNjYWxlIC0gdGhpcy5vcHRpb24oXCJtaW5TY2FsZVwiKSkgPCAwLjAxKSB8fFxuICAgICAgKGRlbHRhID4gMCAmJiBNYXRoLmFicyhzY2FsZSAtIHRoaXMub3B0aW9uKFwibWF4U2NhbGVcIikpIDwgMC4wMSlcbiAgICApIHtcbiAgICAgIHRoaXMuY2hhbmdlZERlbHRhICs9IE1hdGguYWJzKGRlbHRhKTtcbiAgICAgIG5ld1NjYWxlID0gc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hhbmdlZERlbHRhID0gMDtcbiAgICAgIG5ld1NjYWxlID0gTWF0aC5tYXgoTWF0aC5taW4obmV3U2NhbGUsIHRoaXMub3B0aW9uKFwibWF4U2NhbGVcIikpLCB0aGlzLm9wdGlvbihcIm1pblNjYWxlXCIpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jaGFuZ2VkRGVsdGEgPiB0aGlzLm9wdGlvbihcIndoZWVsTGltaXRcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKG5ld1NjYWxlID09PSBzY2FsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY3QgPSB0aGlzLiRjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcblxuICAgIHRoaXMuem9vbVRvKG5ld1NjYWxlLCB7IHgsIHkgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHpvb20gbGV2ZWwgZGVwZW5kaW5nIG9uIGNsaWNrIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IGBjbGlja2AgZXZlbnRcbiAgICovXG4gIHpvb21XaXRoQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy4kY29udGVudC5nZXRDbGllbnRSZWN0cygpWzBdO1xuXG4gICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcDtcblxuICAgIHRoaXMudG9nZ2xlWm9vbSh7IHgsIHkgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIGxvYWQsIHdoZWVsIGFuZCBjbGljayBldmVudCBsaXN0ZW5lcnMsIGluaXRpYWxpemUgYHJlc2l6ZU9ic2VydmVyYCBhbmQgYFBvaW50ZXJUcmFja2VyYFxuICAgKi9cbiAgYXR0YWNoRXZlbnRzKCkge1xuICAgIHRoaXMuJGNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgdGhpcy5vbkxvYWQpO1xuXG4gICAgdGhpcy4kY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLm9uV2hlZWwsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgdGhpcy4kY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uQ2xpY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG5cbiAgICB0aGlzLmluaXRPYnNlcnZlcigpO1xuXG4gICAgY29uc3QgcG9pbnRlclRyYWNrZXIgPSBuZXcgUG9pbnRlclRyYWNrZXIodGhpcy4kY29udGFpbmVyLCB7XG4gICAgICBzdGFydDogKHBvaW50ZXIsIGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb24oXCJ0b3VjaFwiKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5LnNjYWxlIDwgMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuXG4gICAgICAgIGlmICghcG9pbnRlclRyYWNrZXIuY3VycmVudFBvaW50ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGlnbm9yZUNsaWNrZWRFbGVtZW50ID1cbiAgICAgICAgICAgIFtcIkJVVFRPTlwiLCBcIlRFWFRBUkVBXCIsIFwiT1BUSU9OXCIsIFwiSU5QVVRcIiwgXCJTRUxFQ1RcIiwgXCJWSURFT1wiXS5pbmRleE9mKHRhcmdldC5ub2RlTmFtZSkgIT09IC0xO1xuXG4gICAgICAgICAgaWYgKGlnbm9yZUNsaWNrZWRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWxsb3cgdGV4dCBzZWxlY3Rpb25cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb24oXCJ0ZXh0U2VsZWN0aW9uXCIpICYmIGdldFRleHROb2RlRnJvbVBvaW50KHRhcmdldCwgcG9pbnRlci5jbGllbnRYLCBwb2ludGVyLmNsaWVudFkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU2Nyb2xsYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlcihcInRvdWNoU3RhcnRcIiwgZXZlbnQpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1vdXNlZG93blwiKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBcInBvaW50ZXJkb3duXCI7XG5cbiAgICAgICAgdGhpcy5yZXNldERyYWdQb3NpdGlvbigpO1xuXG4gICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLm1pZFBvaW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnUG9zaXRpb24udGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgbW92ZTogKHByZXZpb3VzUG9pbnRlcnMsIGN1cnJlbnRQb2ludGVycywgZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwicG9pbnRlcmRvd25cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIoXCJ0b3VjaE1vdmVcIiwgZXZlbnQpID09PSBmYWxzZSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzYWJsZSB0b3VjaCBhY3Rpb24gaWYgY3VycmVudCB6b29tIGxldmVsIGlzIGJlbG93IGJhc2UgbGV2ZWxcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGN1cnJlbnRQb2ludGVycy5sZW5ndGggPCAyICYmXG4gICAgICAgICAgdGhpcy5vcHRpb24oXCJwYW5Pbmx5Wm9vbWVkXCIpID09PSB0cnVlICYmXG4gICAgICAgICAgdGhpcy5jb250ZW50LndpZHRoIDw9IHRoaXMudmlld3BvcnQud2lkdGggJiZcbiAgICAgICAgICB0aGlzLmNvbnRlbnQuaGVpZ2h0IDw9IHRoaXMudmlld3BvcnQuaGVpZ2h0ICYmXG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUgPD0gdGhpcy5vcHRpb24oXCJiYXNlU2NhbGVcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQb2ludGVycy5sZW5ndGggPiAxICYmICghdGhpcy5vcHRpb24oXCJ6b29tXCIpIHx8IHRoaXMub3B0aW9uKFwicGluY2hUb1pvb21cIikgPT09IGZhbHNlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZXZNaWRwb2ludCA9IGdldE1pZHBvaW50KHByZXZpb3VzUG9pbnRlcnNbMF0sIHByZXZpb3VzUG9pbnRlcnNbMV0pO1xuICAgICAgICBjb25zdCBuZXdNaWRwb2ludCA9IGdldE1pZHBvaW50KGN1cnJlbnRQb2ludGVyc1swXSwgY3VycmVudFBvaW50ZXJzWzFdKTtcblxuICAgICAgICBjb25zdCBwYW5YID0gbmV3TWlkcG9pbnQuY2xpZW50WCAtIHByZXZNaWRwb2ludC5jbGllbnRYO1xuICAgICAgICBjb25zdCBwYW5ZID0gbmV3TWlkcG9pbnQuY2xpZW50WSAtIHByZXZNaWRwb2ludC5jbGllbnRZO1xuXG4gICAgICAgIGNvbnN0IHByZXZEaXN0YW5jZSA9IGdldERpc3RhbmNlKHByZXZpb3VzUG9pbnRlcnNbMF0sIHByZXZpb3VzUG9pbnRlcnNbMV0pO1xuICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IGdldERpc3RhbmNlKGN1cnJlbnRQb2ludGVyc1swXSwgY3VycmVudFBvaW50ZXJzWzFdKTtcblxuICAgICAgICBjb25zdCBzY2FsZURpZmYgPSBwcmV2RGlzdGFuY2UgJiYgbmV3RGlzdGFuY2UgPyBuZXdEaXN0YW5jZSAvIHByZXZEaXN0YW5jZSA6IDE7XG5cbiAgICAgICAgdGhpcy5kcmFnT2Zmc2V0LnggKz0gcGFuWDtcbiAgICAgICAgdGhpcy5kcmFnT2Zmc2V0LnkgKz0gcGFuWTtcblxuICAgICAgICB0aGlzLmRyYWdPZmZzZXQuc2NhbGUgKj0gc2NhbGVEaWZmO1xuXG4gICAgICAgIHRoaXMuZHJhZ09mZnNldC50aW1lID0gRGF0ZS5ub3coKSAtIHRoaXMuZHJhZ1Bvc2l0aW9uLnRpbWU7XG5cbiAgICAgICAgY29uc3QgYXhpc1RvTG9jayA9IHRoaXMuZHJhZ1N0YXJ0LnNjYWxlID09PSAxICYmIHRoaXMub3B0aW9uKFwibG9ja0F4aXNcIik7XG5cbiAgICAgICAgaWYgKGF4aXNUb0xvY2sgJiYgIXRoaXMubG9ja0F4aXMpIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5kcmFnT2Zmc2V0LngpIDwgNiAmJiBNYXRoLmFicyh0aGlzLmRyYWdPZmZzZXQueSkgPCA2KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hYnMoKE1hdGguYXRhbjIodGhpcy5kcmFnT2Zmc2V0LnksIHRoaXMuZHJhZ09mZnNldC54KSAqIDE4MCkgLyBNYXRoLlBJKTtcblxuICAgICAgICAgIHRoaXMubG9ja0F4aXMgPSBhbmdsZSA+IDQ1ICYmIGFuZ2xlIDwgMTM1ID8gXCJ5XCIgOiBcInhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGlzVG9Mb2NrICE9PSBcInh5XCIgJiYgdGhpcy5sb2NrQXhpcyA9PT0gXCJ5XCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5sb2NrQXhpcykge1xuICAgICAgICAgIHRoaXMuZHJhZ09mZnNldFt0aGlzLmxvY2tBeGlzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9uKFwiZHJhZ2dpbmdDbGFzc1wiKSk7XG5cbiAgICAgICAgaWYgKCEodGhpcy50cmFuc2Zvcm0uc2NhbGUgPT09IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpICYmIHRoaXMubG9ja0F4aXMgPT09IFwieVwiKSkge1xuICAgICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnggPSB0aGlzLmRyYWdTdGFydC54ICsgdGhpcy5kcmFnT2Zmc2V0Lng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzLnRyYW5zZm9ybS5zY2FsZSA9PT0gdGhpcy5vcHRpb24oXCJiYXNlU2NhbGVcIikgJiYgdGhpcy5sb2NrQXhpcyA9PT0gXCJ4XCIpKSB7XG4gICAgICAgICAgdGhpcy5kcmFnUG9zaXRpb24ueSA9IHRoaXMuZHJhZ1N0YXJ0LnkgKyB0aGlzLmRyYWdPZmZzZXQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnNjYWxlID0gdGhpcy5kcmFnU3RhcnQuc2NhbGUgKiB0aGlzLmRyYWdPZmZzZXQuc2NhbGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQb2ludGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRQb2ludCA9IGdldE1pZHBvaW50KHBvaW50ZXJUcmFja2VyLnN0YXJ0UG9pbnRlcnNbMF0sIHBvaW50ZXJUcmFja2VyLnN0YXJ0UG9pbnRlcnNbMV0pO1xuXG4gICAgICAgICAgY29uc3QgeFBvcyA9IHN0YXJ0UG9pbnQuY2xpZW50WCAtIHRoaXMuZHJhZ1N0YXJ0LnJlY3QueDtcbiAgICAgICAgICBjb25zdCB5UG9zID0gc3RhcnRQb2ludC5jbGllbnRZIC0gdGhpcy5kcmFnU3RhcnQucmVjdC55O1xuXG4gICAgICAgICAgY29uc3QgeyBkZWx0YVgsIGRlbHRhWSB9ID0gdGhpcy5nZXRab29tRGVsdGEodGhpcy5jb250ZW50LnNjYWxlICogdGhpcy5kcmFnT2Zmc2V0LnNjYWxlLCB4UG9zLCB5UG9zKTtcblxuICAgICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnggLT0gZGVsdGFYO1xuICAgICAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnkgLT0gZGVsdGFZO1xuXG4gICAgICAgICAgdGhpcy5kcmFnUG9zaXRpb24ubWlkUG9pbnQgPSBuZXdNaWRwb2ludDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldERyYWdSZXNpc3RhbmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgZmluYWwgcG9zaXRpb25cbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgeDogdGhpcy5kcmFnUG9zaXRpb24ueCxcbiAgICAgICAgICB5OiB0aGlzLmRyYWdQb3NpdGlvbi55LFxuICAgICAgICAgIHNjYWxlOiB0aGlzLmRyYWdQb3NpdGlvbi5zY2FsZSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICB9LFxuICAgICAgZW5kOiAocG9pbnRlciwgZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwicG9pbnRlcmRvd25cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RyYWdPZmZzZXQgPSB7IC4uLnRoaXMuZHJhZ09mZnNldCB9O1xuXG4gICAgICAgIGlmIChwb2ludGVyVHJhY2tlci5jdXJyZW50UG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5yZXNldERyYWdQb3NpdGlvbigpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiZGVjZWxcIjtcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IHRoaXMub3B0aW9uKFwiZGVjZWxGcmljdGlvblwiKTtcblxuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb24oXCJkcmFnZ2luZ0NsYXNzXCIpKTtcblxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyKFwidG91Y2hFbmRcIiwgZXZlbnQpID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImRlY2VsXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyAqIENoZWNrIGlmIHNjYWxlZCBjb250ZW50IHBhc3QgbGltaXRzXG5cbiAgICAgICAgLy8gQmVsb3cgbWluaW11bVxuICAgICAgICBjb25zdCBtaW5TY2FsZSA9IHRoaXMub3B0aW9uKFwibWluU2NhbGVcIik7XG5cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtLnNjYWxlIDwgbWluU2NhbGUpIHtcbiAgICAgICAgICB0aGlzLnpvb21UbyhtaW5TY2FsZSwgeyBmcmljdGlvbjogMC42NCB9KTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4Y2VlZCBtYXhpbXVtXG4gICAgICAgIGNvbnN0IG1heFNjYWxlID0gdGhpcy5vcHRpb24oXCJtYXhTY2FsZVwiKTtcblxuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0uc2NhbGUgLSBtYXhTY2FsZSA+IDAuMDEpIHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5kcmFnUG9zaXRpb24ubWlkUG9pbnQgfHwgcG9pbnRlcjtcbiAgICAgICAgICBjb25zdCByZWN0ID0gdGhpcy4kY29udGVudC5nZXRDbGllbnRSZWN0cygpWzBdO1xuXG4gICAgICAgICAgdGhpcy56b29tVG8obWF4U2NhbGUsIHtcbiAgICAgICAgICAgIGZyaWN0aW9uOiAwLjY0LFxuICAgICAgICAgICAgeDogbGFzdC5jbGllbnRYIC0gcmVjdC5sZWZ0LFxuICAgICAgICAgICAgeTogbGFzdC5jbGllbnRZIC0gcmVjdC50b3AsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLnBvaW50ZXJUcmFja2VyID0gcG9pbnRlclRyYWNrZXI7XG4gIH1cblxuICBpbml0T2JzZXJ2ZXIoKSB7XG4gICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnVwZGF0ZVRpbWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy4kY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGlmICghKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVUaW1lciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgICBpZiAoTWF0aC5hYnMocmVjdC53aWR0aCAtIHRoaXMuY29udGFpbmVyLndpZHRoKSA+IDEgfHwgTWF0aC5hYnMocmVjdC5oZWlnaHQgLSB0aGlzLmNvbnRhaW5lci5oZWlnaHQpID4gMSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQW5pbWF0aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kQW5pbWF0aW9uKHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudXBkYXRlTWV0cmljcygpO1xuXG4gICAgICAgICAgdGhpcy5wYW5Ubyh7XG4gICAgICAgICAgICB4OiB0aGlzLmNvbnRlbnQueCxcbiAgICAgICAgICAgIHk6IHRoaXMuY29udGVudC55LFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpLFxuICAgICAgICAgICAgZnJpY3Rpb246IDAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgIH0sIHRoaXMudXBkYXRlUmF0ZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy4kY29udGFpbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIGRyYWcgcmVsYXRlZCB2YXJpYWJsZXMgdG8gZGVmYXVsdCB2YWx1ZXNcbiAgICovXG4gIHJlc2V0RHJhZ1Bvc2l0aW9uKCkge1xuICAgIHRoaXMubG9ja0F4aXMgPSBudWxsO1xuICAgIHRoaXMuZnJpY3Rpb24gPSB0aGlzLm9wdGlvbihcImZyaWN0aW9uXCIpO1xuXG4gICAgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgc2NhbGU6IDAsXG4gICAgfTtcblxuICAgIGNvbnN0IHsgeCwgeSwgc2NhbGUgfSA9IHRoaXMuY29udGVudDtcblxuICAgIHRoaXMuZHJhZ1N0YXJ0ID0ge1xuICAgICAgcmVjdDogdGhpcy4kY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgc2NhbGUsXG4gICAgfTtcblxuICAgIHRoaXMuZHJhZ1Bvc2l0aW9uID0ge1xuICAgICAgLi4udGhpcy5kcmFnUG9zaXRpb24sXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHNjYWxlLFxuICAgIH07XG5cbiAgICB0aGlzLmRyYWdPZmZzZXQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgdGltZTogMCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdXBkYXRlIGV2ZW50cyBiZWZvcmUvYWZ0ZXIgcmVzaXppbmcgY29udGVudCBhbmQgdmlld3BvcnRcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaWxlbnRseSBTaG91bGQgdHJpZ2dlciBgYWZ0ZXJVcGRhdGVgIGV2ZW50IGF0IHRoZSBlbmRcbiAgICovXG4gIHVwZGF0ZU1ldHJpY3Moc2lsZW50bHkpIHtcbiAgICBpZiAoc2lsZW50bHkgIT09IHRydWUpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcImJlZm9yZVVwZGF0ZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCAkY29udGFpbmVyID0gdGhpcy4kY29udGFpbmVyO1xuICAgIGNvbnN0ICRjb250ZW50ID0gdGhpcy4kY29udGVudDtcbiAgICBjb25zdCAkdmlld3BvcnQgPSB0aGlzLiR2aWV3cG9ydDtcblxuICAgIGNvbnN0IGNvbnRlbnRJc0ltYWdlID0gJGNvbnRlbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICAgIGNvbnN0IGNvbnRlbnRJc1pvb21hYmxlID0gdGhpcy5vcHRpb24oXCJ6b29tXCIpO1xuICAgIGNvbnN0IHNob3VsZFJlc2l6ZVBhcmVudCA9IHRoaXMub3B0aW9uKFwicmVzaXplUGFyZW50XCIsIGNvbnRlbnRJc1pvb21hYmxlKTtcblxuICAgIGxldCB3aWR0aCA9IHRoaXMub3B0aW9uKFwid2lkdGhcIik7XG4gICAgbGV0IGhlaWdodCA9IHRoaXMub3B0aW9uKFwiaGVpZ2h0XCIpO1xuXG4gICAgbGV0IG9yaWdXaWR0aCA9IHdpZHRoIHx8IGdldEZ1bGxXaWR0aCgkY29udGVudCk7XG4gICAgbGV0IG9yaWdIZWlnaHQgPSBoZWlnaHQgfHwgZ2V0RnVsbEhlaWdodCgkY29udGVudCk7XG5cbiAgICBPYmplY3QuYXNzaWduKCRjb250ZW50LnN0eWxlLCB7XG4gICAgICB3aWR0aDogd2lkdGggPyBgJHt3aWR0aH1weGAgOiBcIlwiLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgPyBgJHtoZWlnaHR9cHhgIDogXCJcIixcbiAgICAgIG1heFdpZHRoOiBcIlwiLFxuICAgICAgbWF4SGVpZ2h0OiBcIlwiLFxuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZFJlc2l6ZVBhcmVudCkge1xuICAgICAgT2JqZWN0LmFzc2lnbigkdmlld3BvcnQuc3R5bGUsIHsgd2lkdGg6IFwiXCIsIGhlaWdodDogXCJcIiB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByYXRpbyA9IHRoaXMub3B0aW9uKFwicmF0aW9cIik7XG5cbiAgICBvcmlnV2lkdGggPSByb3VuZChvcmlnV2lkdGggKiByYXRpbyk7XG4gICAgb3JpZ0hlaWdodCA9IHJvdW5kKG9yaWdIZWlnaHQgKiByYXRpbyk7XG5cbiAgICB3aWR0aCA9IG9yaWdXaWR0aDtcbiAgICBoZWlnaHQgPSBvcmlnSGVpZ2h0O1xuXG4gICAgY29uc3QgY29udGVudFJlY3QgPSAkY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB2aWV3cG9ydFJlY3QgPSAkdmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBjb25zdCBjb250YWluZXJSZWN0ID0gJHZpZXdwb3J0ID09ICRjb250YWluZXIgPyB2aWV3cG9ydFJlY3QgOiAkY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgbGV0IHZpZXdwb3J0V2lkdGggPSBNYXRoLm1heCgkdmlld3BvcnQub2Zmc2V0V2lkdGgsIHJvdW5kKHZpZXdwb3J0UmVjdC53aWR0aCkpO1xuICAgIGxldCB2aWV3cG9ydEhlaWdodCA9IE1hdGgubWF4KCR2aWV3cG9ydC5vZmZzZXRIZWlnaHQsIHJvdW5kKHZpZXdwb3J0UmVjdC5oZWlnaHQpKTtcblxuICAgIGxldCB2aWV3cG9ydFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCR2aWV3cG9ydCk7XG4gICAgdmlld3BvcnRXaWR0aCAtPSBwYXJzZUZsb2F0KHZpZXdwb3J0U3R5bGVzLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQodmlld3BvcnRTdHlsZXMucGFkZGluZ1JpZ2h0KTtcbiAgICB2aWV3cG9ydEhlaWdodCAtPSBwYXJzZUZsb2F0KHZpZXdwb3J0U3R5bGVzLnBhZGRpbmdUb3ApICsgcGFyc2VGbG9hdCh2aWV3cG9ydFN0eWxlcy5wYWRkaW5nQm90dG9tKTtcblxuICAgIHRoaXMudmlld3BvcnQud2lkdGggPSB2aWV3cG9ydFdpZHRoO1xuICAgIHRoaXMudmlld3BvcnQuaGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQ7XG5cbiAgICBpZiAoY29udGVudElzWm9vbWFibGUpIHtcbiAgICAgIGlmIChNYXRoLmFicyhvcmlnV2lkdGggLSBjb250ZW50UmVjdC53aWR0aCkgPiAwLjEgfHwgTWF0aC5hYnMob3JpZ0hlaWdodCAtIGNvbnRlbnRSZWN0LmhlaWdodCkgPiAwLjEpIHtcbiAgICAgICAgY29uc3QgcmV6ID0gY2FsY3VsYXRlQXNwZWN0UmF0aW9GaXQoXG4gICAgICAgICAgb3JpZ1dpZHRoLFxuICAgICAgICAgIG9yaWdIZWlnaHQsXG4gICAgICAgICAgTWF0aC5taW4ob3JpZ1dpZHRoLCBjb250ZW50UmVjdC53aWR0aCksXG4gICAgICAgICAgTWF0aC5taW4ob3JpZ0hlaWdodCwgY29udGVudFJlY3QuaGVpZ2h0KVxuICAgICAgICApO1xuXG4gICAgICAgIHdpZHRoID0gcm91bmQocmV6LndpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gcm91bmQocmV6LmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oJGNvbnRlbnQuc3R5bGUsIHtcbiAgICAgICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgICAgaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxuICAgICAgICB0cmFuc2Zvcm06IFwiXCIsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUmVzaXplUGFyZW50KSB7XG4gICAgICBPYmplY3QuYXNzaWduKCR2aWV3cG9ydC5zdHlsZSwgeyB3aWR0aDogYCR7d2lkdGh9cHhgLCBoZWlnaHQ6IGAke2hlaWdodH1weGAgfSk7XG5cbiAgICAgIHRoaXMudmlld3BvcnQgPSB7IC4uLnRoaXMudmlld3BvcnQsIHdpZHRoLCBoZWlnaHQgfTtcbiAgICB9XG5cbiAgICBpZiAoY29udGVudElzSW1hZ2UgJiYgY29udGVudElzWm9vbWFibGUgJiYgdHlwZW9mIHRoaXMub3B0aW9ucy5tYXhTY2FsZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBtYXhTY2FsZSA9IHRoaXMub3B0aW9uKFwibWF4U2NhbGVcIik7XG5cbiAgICAgIHRoaXMub3B0aW9ucy5tYXhTY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5vcmlnV2lkdGggPiAwICYmIHRoaXMuY29udGVudC5maXRXaWR0aCA+IDBcbiAgICAgICAgICA/IHRoaXMuY29udGVudC5vcmlnV2lkdGggLyB0aGlzLmNvbnRlbnQuZml0V2lkdGhcbiAgICAgICAgICA6IG1heFNjYWxlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRlbnQgPSB7XG4gICAgICAuLi50aGlzLmNvbnRlbnQsXG4gICAgICBvcmlnV2lkdGgsXG4gICAgICBvcmlnSGVpZ2h0LFxuICAgICAgZml0V2lkdGg6IHdpZHRoLFxuICAgICAgZml0SGVpZ2h0OiBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgaXNab29tYWJsZTogY29udGVudElzWm9vbWFibGUsXG4gICAgfTtcblxuICAgIHRoaXMuY29udGFpbmVyID0geyB3aWR0aDogY29udGFpbmVyUmVjdC53aWR0aCwgaGVpZ2h0OiBjb250YWluZXJSZWN0LmhlaWdodCB9O1xuXG4gICAgaWYgKHNpbGVudGx5ICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJhZnRlclVwZGF0ZVwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVhc2Ugem9vbSBsZXZlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0ZXBdIFpvb20gcmF0aW87IGAwLjVgIHdvdWxkIGluY3JlYXNlIHNjYWxlIGZyb20gMSB0byAxLjVcbiAgICovXG4gIHpvb21JbihzdGVwKSB7XG4gICAgdGhpcy56b29tVG8odGhpcy5jb250ZW50LnNjYWxlICsgKHN0ZXAgfHwgdGhpcy5vcHRpb24oXCJzdGVwXCIpKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcmVhc2Ugem9vbSBsZXZlbFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0ZXBdIFpvb20gcmF0aW87IGAwLjVgIHdvdWxkIGRlY3JlYXNlIHNjYWxlIGZyb20gMS41IHRvIDFcbiAgICovXG4gIHpvb21PdXQoc3RlcCkge1xuICAgIHRoaXMuem9vbVRvKHRoaXMuY29udGVudC5zY2FsZSAtIChzdGVwIHx8IHRoaXMub3B0aW9uKFwic3RlcFwiKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgem9vbSBsZXZlbCBiZXR3ZWVuIG1heCBhbmQgYmFzZSBsZXZlbHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAgICovXG4gIHRvZ2dsZVpvb20ocHJvcHMgPSB7fSkge1xuICAgIGNvbnN0IG1heFNjYWxlID0gdGhpcy5vcHRpb24oXCJtYXhTY2FsZVwiKTtcbiAgICBjb25zdCBiYXNlU2NhbGUgPSB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKTtcblxuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5jb250ZW50LnNjYWxlID4gYmFzZVNjYWxlICsgKG1heFNjYWxlIC0gYmFzZVNjYWxlKSAqIDAuNSA/IGJhc2VTY2FsZSA6IG1heFNjYWxlO1xuXG4gICAgdGhpcy56b29tVG8oc2NhbGUsIHByb3BzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRlIHRvIGdpdmVuIHpvb20gbGV2ZWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIE5ldyB6b29tIGxldmVsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zXG4gICAqL1xuICB6b29tVG8oc2NhbGUgPSB0aGlzLm9wdGlvbihcImJhc2VTY2FsZVwiKSwgeyB4ID0gbnVsbCwgeSA9IG51bGwgfSA9IHt9KSB7XG4gICAgc2NhbGUgPSBNYXRoLm1heChNYXRoLm1pbihzY2FsZSwgdGhpcy5vcHRpb24oXCJtYXhTY2FsZVwiKSksIHRoaXMub3B0aW9uKFwibWluU2NhbGVcIikpO1xuXG4gICAgLy8gQWRqdXN0IHpvb20gcG9zaXRpb25cbiAgICBjb25zdCBjdXJyZW50U2NhbGUgPSByb3VuZCh0aGlzLmNvbnRlbnQuc2NhbGUgLyAodGhpcy5jb250ZW50LndpZHRoIC8gdGhpcy5jb250ZW50LmZpdFdpZHRoKSwgMTAwMDAwMDApO1xuXG4gICAgaWYgKHggPT09IG51bGwpIHtcbiAgICAgIHggPSB0aGlzLmNvbnRlbnQud2lkdGggKiBjdXJyZW50U2NhbGUgKiAwLjU7XG4gICAgfVxuXG4gICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgIHkgPSB0aGlzLmNvbnRlbnQuaGVpZ2h0ICogY3VycmVudFNjYWxlICogMC41O1xuICAgIH1cblxuICAgIGNvbnN0IHsgZGVsdGFYLCBkZWx0YVkgfSA9IHRoaXMuZ2V0Wm9vbURlbHRhKHNjYWxlLCB4LCB5KTtcblxuICAgIHggPSB0aGlzLmNvbnRlbnQueCAtIGRlbHRhWDtcbiAgICB5ID0gdGhpcy5jb250ZW50LnkgLSBkZWx0YVk7XG5cbiAgICB0aGlzLnBhblRvKHsgeCwgeSwgc2NhbGUsIGZyaWN0aW9uOiB0aGlzLm9wdGlvbihcInpvb21GcmljdGlvblwiKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgZGlmZmVyZW5jZSBmb3IgdG9wL2xlZnQgdmFsdWVzIGlmIGNvbnRlbnQgd291bGQgc2NhbGUgYXQgZ2l2ZW4gY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBnZXRab29tRGVsdGEoc2NhbGUsIHggPSAwLCB5ID0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHRoaXMuY29udGVudC5maXRXaWR0aCAqIHRoaXMuY29udGVudC5zY2FsZTtcbiAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gdGhpcy5jb250ZW50LmZpdEhlaWdodCAqIHRoaXMuY29udGVudC5zY2FsZTtcblxuICAgIGNvbnN0IHBlcmNlbnRYSW5DdXJyZW50Qm94ID0geCA+IDAgJiYgY3VycmVudFdpZHRoID8geCAvIGN1cnJlbnRXaWR0aCA6IDA7XG4gICAgY29uc3QgcGVyY2VudFlJbkN1cnJlbnRCb3ggPSB5ID4gMCAmJiBjdXJyZW50SGVpZ2h0ID8geSAvIGN1cnJlbnRIZWlnaHQgOiAwO1xuXG4gICAgY29uc3QgbmV4dFdpZHRoID0gdGhpcy5jb250ZW50LmZpdFdpZHRoICogc2NhbGU7XG4gICAgY29uc3QgbmV4dEhlaWdodCA9IHRoaXMuY29udGVudC5maXRIZWlnaHQgKiBzY2FsZTtcblxuICAgIGNvbnN0IGRlbHRhWCA9IChuZXh0V2lkdGggLSBjdXJyZW50V2lkdGgpICogcGVyY2VudFhJbkN1cnJlbnRCb3g7XG4gICAgY29uc3QgZGVsdGFZID0gKG5leHRIZWlnaHQgLSBjdXJyZW50SGVpZ2h0KSAqIHBlcmNlbnRZSW5DdXJyZW50Qm94O1xuXG4gICAgcmV0dXJuIHsgZGVsdGFYLCBkZWx0YVkgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRlIHRvIGdpdmVuIHBvc2l0b24gYW5kL29yIHpvb20gbGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAgICovXG4gIHBhblRvKHtcbiAgICB4ID0gdGhpcy5jb250ZW50LngsXG4gICAgeSA9IHRoaXMuY29udGVudC55LFxuICAgIHNjYWxlLFxuICAgIGZyaWN0aW9uID0gdGhpcy5vcHRpb24oXCJmcmljdGlvblwiKSxcbiAgICBpZ25vcmVCb3VuZHMgPSBmYWxzZSxcbiAgfSA9IHt9KSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCB0aGlzLmNvbnRlbnQuc2NhbGUgfHwgMTtcblxuICAgIGlmICghaWdub3JlQm91bmRzKSB7XG4gICAgICBjb25zdCB7IGJvdW5kWCwgYm91bmRZIH0gPSB0aGlzLmdldEJvdW5kcyhzY2FsZSk7XG5cbiAgICAgIGlmIChib3VuZFgpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KE1hdGgubWluKHgsIGJvdW5kWC50byksIGJvdW5kWC5mcm9tKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kWSkge1xuICAgICAgICB5ID0gTWF0aC5tYXgoTWF0aC5taW4oeSwgYm91bmRZLnRvKSwgYm91bmRZLmZyb20pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZnJpY3Rpb24gPSBmcmljdGlvbjtcblxuICAgIHRoaXMudHJhbnNmb3JtID0ge1xuICAgICAgLi4udGhpcy50cmFuc2Zvcm0sXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHNjYWxlLFxuICAgIH07XG5cbiAgICBpZiAoZnJpY3Rpb24pIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBcInBhbm5pbmdcIjtcblxuICAgICAgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgICAgeDogKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSkgKiAoeCAtIHRoaXMuY29udGVudC54KSxcbiAgICAgICAgeTogKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSkgKiAoeSAtIHRoaXMuY29udGVudC55KSxcbiAgICAgICAgc2NhbGU6ICgxIC8gdGhpcy5mcmljdGlvbiAtIDEpICogKHNjYWxlIC0gdGhpcy5jb250ZW50LnNjYWxlKSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmRBbmltYXRpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uIGxvb3BcbiAgICovXG4gIHN0YXJ0QW5pbWF0aW9uKCkge1xuICAgIGlmICghdGhpcy5yQUYpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcInN0YXJ0QW5pbWF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJBRik7XG4gICAgfVxuXG4gICAgdGhpcy5yQUYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hbmltYXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYW5pbWF0aW9uIGZyYW1lXG4gICAqL1xuICBhbmltYXRlKCkge1xuICAgIHRoaXMuc2V0RWRnZUZvcmNlKCk7XG4gICAgdGhpcy5zZXREcmFnRm9yY2UoKTtcblxuICAgIHRoaXMudmVsb2NpdHkueCAqPSB0aGlzLmZyaWN0aW9uO1xuICAgIHRoaXMudmVsb2NpdHkueSAqPSB0aGlzLmZyaWN0aW9uO1xuXG4gICAgdGhpcy52ZWxvY2l0eS5zY2FsZSAqPSB0aGlzLmZyaWN0aW9uO1xuXG4gICAgdGhpcy5jb250ZW50LnggKz0gdGhpcy52ZWxvY2l0eS54O1xuICAgIHRoaXMuY29udGVudC55ICs9IHRoaXMudmVsb2NpdHkueTtcblxuICAgIHRoaXMuY29udGVudC5zY2FsZSArPSB0aGlzLnZlbG9jaXR5LnNjYWxlO1xuXG4gICAgaWYgKHRoaXMuaXNBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgIT09IFwicG9pbnRlcmRvd25cIikge1xuICAgICAgdGhpcy5lbmRBbmltYXRpb24oKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuckFGID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYW5pbWF0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgYm91bmRhcmllc1xuICAgKi9cbiAgZ2V0Qm91bmRzKHNjYWxlKSB7XG4gICAgbGV0IGJvdW5kWCA9IHRoaXMuYm91bmRYO1xuICAgIGxldCBib3VuZFkgPSB0aGlzLmJvdW5kWTtcblxuICAgIGlmIChib3VuZFggIT09IHVuZGVmaW5lZCAmJiBib3VuZFkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHsgYm91bmRYLCBib3VuZFkgfTtcbiAgICB9XG5cbiAgICBib3VuZFggPSB7IGZyb206IDAsIHRvOiAwIH07XG4gICAgYm91bmRZID0geyBmcm9tOiAwLCB0bzogMCB9O1xuXG4gICAgc2NhbGUgPSBzY2FsZSB8fCB0aGlzLnRyYW5zZm9ybS5zY2FsZTtcblxuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jb250ZW50LmZpdFdpZHRoICogc2NhbGU7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jb250ZW50LmZpdEhlaWdodCAqIHNjYWxlO1xuXG4gICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IHRoaXMudmlld3BvcnQud2lkdGg7XG4gICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSB0aGlzLnZpZXdwb3J0LmhlaWdodDtcblxuICAgIGlmICh3aWR0aCA8IHZpZXdwb3J0V2lkdGgpIHtcbiAgICAgIGNvbnN0IGRlbHRhWCA9IHJvdW5kKCh2aWV3cG9ydFdpZHRoIC0gd2lkdGgpICogMC41KTtcblxuICAgICAgYm91bmRYLmZyb20gPSBkZWx0YVg7XG4gICAgICBib3VuZFgudG8gPSBkZWx0YVg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kWC5mcm9tID0gcm91bmQodmlld3BvcnRXaWR0aCAtIHdpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0IDwgdmlld3BvcnRIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGRlbHRhWSA9ICh2aWV3cG9ydEhlaWdodCAtIGhlaWdodCkgKiAwLjU7XG5cbiAgICAgIGJvdW5kWS5mcm9tID0gZGVsdGFZO1xuICAgICAgYm91bmRZLnRvID0gZGVsdGFZO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZFkuZnJvbSA9IHJvdW5kKHZpZXdwb3J0SGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBib3VuZFgsIGJvdW5kWSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSBhbmltYXRpb24gdmVsb2NpdHkgaWYgYm91bmRhcnkgaXMgcmVhY2hlZFxuICAgKi9cbiAgc2V0RWRnZUZvcmNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBcImRlY2VsXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBib3VuY2VGb3JjZSA9IHRoaXMub3B0aW9uKFwiYm91bmNlRm9yY2VcIik7XG5cbiAgICBjb25zdCB7IGJvdW5kWCwgYm91bmRZIH0gPSB0aGlzLmdldEJvdW5kcyhNYXRoLm1heCh0aGlzLnRyYW5zZm9ybS5zY2FsZSwgdGhpcy5jb250ZW50LnNjYWxlKSk7XG5cbiAgICBsZXQgcGFzdExlZnQsIHBhc3RSaWdodCwgcGFzdFRvcCwgcGFzdEJvdHRvbTtcblxuICAgIGlmIChib3VuZFgpIHtcbiAgICAgIHBhc3RMZWZ0ID0gdGhpcy5jb250ZW50LnggPCBib3VuZFguZnJvbTtcbiAgICAgIHBhc3RSaWdodCA9IHRoaXMuY29udGVudC54ID4gYm91bmRYLnRvO1xuICAgIH1cblxuICAgIGlmIChib3VuZFkpIHtcbiAgICAgIHBhc3RUb3AgPSB0aGlzLmNvbnRlbnQueSA8IGJvdW5kWS5mcm9tO1xuICAgICAgcGFzdEJvdHRvbSA9IHRoaXMuY29udGVudC55ID4gYm91bmRZLnRvO1xuICAgIH1cblxuICAgIGlmIChwYXN0TGVmdCB8fCBwYXN0UmlnaHQpIHtcbiAgICAgIGNvbnN0IGJvdW5kID0gcGFzdExlZnQgPyBib3VuZFguZnJvbSA6IGJvdW5kWC50bztcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gYm91bmQgLSB0aGlzLmNvbnRlbnQueDtcblxuICAgICAgbGV0IGZvcmNlID0gZGlzdGFuY2UgKiBib3VuY2VGb3JjZTtcblxuICAgICAgY29uc3QgcmVzdFggPSB0aGlzLmNvbnRlbnQueCArICh0aGlzLnZlbG9jaXR5LnggKyBmb3JjZSkgLyB0aGlzLmZyaWN0aW9uO1xuXG4gICAgICBpZiAocmVzdFggPj0gYm91bmRYLmZyb20gJiYgcmVzdFggPD0gYm91bmRYLnRvKSB7XG4gICAgICAgIGZvcmNlICs9IHRoaXMudmVsb2NpdHkueDtcbiAgICAgIH1cblxuICAgICAgdGhpcy52ZWxvY2l0eS54ID0gZm9yY2U7XG5cbiAgICAgIHRoaXMucmVjYWxjdWxhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG5cbiAgICBpZiAocGFzdFRvcCB8fCBwYXN0Qm90dG9tKSB7XG4gICAgICBjb25zdCBib3VuZCA9IHBhc3RUb3AgPyBib3VuZFkuZnJvbSA6IGJvdW5kWS50bztcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gYm91bmQgLSB0aGlzLmNvbnRlbnQueTtcblxuICAgICAgbGV0IGZvcmNlID0gZGlzdGFuY2UgKiBib3VuY2VGb3JjZTtcblxuICAgICAgY29uc3QgcmVzdFkgPSB0aGlzLmNvbnRlbnQueSArIChmb3JjZSArIHRoaXMudmVsb2NpdHkueSkgLyB0aGlzLmZyaWN0aW9uO1xuXG4gICAgICBpZiAocmVzdFkgPj0gYm91bmRZLmZyb20gJiYgcmVzdFkgPD0gYm91bmRZLnRvKSB7XG4gICAgICAgIGZvcmNlICs9IHRoaXMudmVsb2NpdHkueTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52ZWxvY2l0eS55ID0gZm9yY2U7XG5cbiAgICAgIHRoaXMucmVjYWxjdWxhdGVUcmFuc2Zvcm0oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIGRyYWdnaW5nIHBvc2l0aW9uIGlmIGJvdW5kYXJ5IGlzIHJlYWNoZWRcbiAgICovXG4gIHNldERyYWdSZXNpc3RhbmNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBcInBvaW50ZXJkb3duXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGJvdW5kWCwgYm91bmRZIH0gPSB0aGlzLmdldEJvdW5kcyh0aGlzLmRyYWdQb3NpdGlvbi5zY2FsZSk7XG5cbiAgICBsZXQgcGFzdExlZnQsIHBhc3RSaWdodCwgcGFzdFRvcCwgcGFzdEJvdHRvbTtcblxuICAgIGlmIChib3VuZFgpIHtcbiAgICAgIHBhc3RMZWZ0ID0gdGhpcy5kcmFnUG9zaXRpb24ueCA8IGJvdW5kWC5mcm9tO1xuICAgICAgcGFzdFJpZ2h0ID0gdGhpcy5kcmFnUG9zaXRpb24ueCA+IGJvdW5kWC50bztcbiAgICB9XG5cbiAgICBpZiAoYm91bmRZKSB7XG4gICAgICBwYXN0VG9wID0gdGhpcy5kcmFnUG9zaXRpb24ueSA8IGJvdW5kWS5mcm9tO1xuICAgICAgcGFzdEJvdHRvbSA9IHRoaXMuZHJhZ1Bvc2l0aW9uLnkgPiBib3VuZFkudG87XG4gICAgfVxuXG4gICAgaWYgKChwYXN0TGVmdCB8fCBwYXN0UmlnaHQpICYmICEocGFzdExlZnQgJiYgcGFzdFJpZ2h0KSkge1xuICAgICAgY29uc3QgYm91bmQgPSBwYXN0TGVmdCA/IGJvdW5kWC5mcm9tIDogYm91bmRYLnRvO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBib3VuZCAtIHRoaXMuZHJhZ1Bvc2l0aW9uLng7XG5cbiAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnggPSBib3VuZCAtIGRpc3RhbmNlICogMC4zO1xuICAgIH1cblxuICAgIGlmICgocGFzdFRvcCB8fCBwYXN0Qm90dG9tKSAmJiAhKHBhc3RUb3AgJiYgcGFzdEJvdHRvbSkpIHtcbiAgICAgIGNvbnN0IGJvdW5kID0gcGFzdFRvcCA/IGJvdW5kWS5mcm9tIDogYm91bmRZLnRvO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBib3VuZCAtIHRoaXMuZHJhZ1Bvc2l0aW9uLnk7XG5cbiAgICAgIHRoaXMuZHJhZ1Bvc2l0aW9uLnkgPSBib3VuZCAtIGRpc3RhbmNlICogMC4zO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdmVsb2NpdHkgdG8gbW92ZSBjb250ZW50IHRvIGRyYWcgcG9zaXRpb25cbiAgICovXG4gIHNldERyYWdGb3JjZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJwb2ludGVyZG93blwiKSB7XG4gICAgICB0aGlzLnZlbG9jaXR5LnggPSB0aGlzLmRyYWdQb3NpdGlvbi54IC0gdGhpcy5jb250ZW50Lng7XG4gICAgICB0aGlzLnZlbG9jaXR5LnkgPSB0aGlzLmRyYWdQb3NpdGlvbi55IC0gdGhpcy5jb250ZW50Lnk7XG4gICAgICB0aGlzLnZlbG9jaXR5LnNjYWxlID0gdGhpcy5kcmFnUG9zaXRpb24uc2NhbGUgLSB0aGlzLmNvbnRlbnQuc2NhbGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlbmQgdmFsdWVzIGJhc2VkIG9uIGN1cnJlbnQgdmVsb2NpdHkgYW5kIGZyaWN0aW9uO1xuICAgKi9cbiAgcmVjYWxjdWxhdGVUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ueCA9IHRoaXMuY29udGVudC54ICsgdGhpcy52ZWxvY2l0eS54IC8gKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSk7XG4gICAgdGhpcy50cmFuc2Zvcm0ueSA9IHRoaXMuY29udGVudC55ICsgdGhpcy52ZWxvY2l0eS55IC8gKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSk7XG4gICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUgPSB0aGlzLmNvbnRlbnQuc2NhbGUgKyB0aGlzLnZlbG9jaXR5LnNjYWxlIC8gKDEgLyB0aGlzLmZyaWN0aW9uIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgY29udGVudCBpcyBjdXJyZW50bHkgYW5pbWF0aW5nXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmltYXRpbmcoKSB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgdGhpcy5mcmljdGlvbiAmJlxuICAgICAgKE1hdGguYWJzKHRoaXMudmVsb2NpdHkueCkgPiAwLjA1IHx8IE1hdGguYWJzKHRoaXMudmVsb2NpdHkueSkgPiAwLjA1IHx8IE1hdGguYWJzKHRoaXMudmVsb2NpdHkuc2NhbGUpID4gMC4wNSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb250ZW50IGBzdHlsZS50cmFuc2Zvcm1gIHZhbHVlIGJhc2VkIG9uIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lXG4gICAqL1xuICBzZXRUcmFuc2Zvcm0oZmluYWwpIHtcbiAgICBsZXQgeCwgeSwgc2NhbGU7XG5cbiAgICBpZiAoZmluYWwpIHtcbiAgICAgIHggPSByb3VuZCh0aGlzLnRyYW5zZm9ybS54KTtcbiAgICAgIHkgPSByb3VuZCh0aGlzLnRyYW5zZm9ybS55KTtcblxuICAgICAgc2NhbGUgPSB0aGlzLnRyYW5zZm9ybS5zY2FsZTtcblxuICAgICAgdGhpcy5jb250ZW50ID0geyAuLi50aGlzLmNvbnRlbnQsIHgsIHksIHNjYWxlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSByb3VuZCh0aGlzLmNvbnRlbnQueCk7XG4gICAgICB5ID0gcm91bmQodGhpcy5jb250ZW50LnkpO1xuXG4gICAgICBzY2FsZSA9IHRoaXMuY29udGVudC5zY2FsZSAvICh0aGlzLmNvbnRlbnQud2lkdGggLyB0aGlzLmNvbnRlbnQuZml0V2lkdGgpO1xuXG4gICAgICB0aGlzLmNvbnRlbnQgPSB7IC4uLnRoaXMuY29udGVudCwgeCwgeSB9O1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcihcImJlZm9yZVRyYW5zZm9ybVwiKTtcblxuICAgIHggPSByb3VuZCh0aGlzLmNvbnRlbnQueCk7XG4gICAgeSA9IHJvdW5kKHRoaXMuY29udGVudC55KTtcblxuICAgIGlmIChmaW5hbCAmJiB0aGlzLm9wdGlvbihcInpvb21cIikpIHtcbiAgICAgIGxldCB3aWR0aDtcbiAgICAgIGxldCBoZWlnaHQ7XG5cbiAgICAgIHdpZHRoID0gcm91bmQodGhpcy5jb250ZW50LmZpdFdpZHRoICogc2NhbGUpO1xuICAgICAgaGVpZ2h0ID0gcm91bmQodGhpcy5jb250ZW50LmZpdEhlaWdodCAqIHNjYWxlKTtcblxuICAgICAgdGhpcy5jb250ZW50LndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmNvbnRlbnQuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IHsgLi4udGhpcy50cmFuc2Zvcm0sIHdpZHRoLCBoZWlnaHQsIHNjYWxlIH07XG5cbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy4kY29udGVudC5zdHlsZSwge1xuICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgICAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgICAgIG1heFdpZHRoOiBcIm5vbmVcIixcbiAgICAgICAgbWF4SGVpZ2h0OiBcIm5vbmVcIixcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt4fXB4LCAke3l9cHgsIDApIHNjYWxlKDEpYCxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRjb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMCkgc2NhbGUoJHtzY2FsZX0pYDtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJhZnRlclRyYW5zZm9ybVwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGFuaW1hdGlvbiBsb29wXG4gICAqL1xuICBlbmRBbmltYXRpb24oc2lsZW50bHkpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJBRik7XG4gICAgdGhpcy5yQUYgPSBudWxsO1xuXG4gICAgdGhpcy52ZWxvY2l0eSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgc2NhbGU6IDAsXG4gICAgfTtcblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKHRydWUpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFwicmVhZHlcIjtcblxuICAgIHRoaXMuaGFuZGxlQ3Vyc29yKCk7XG5cbiAgICBpZiAoc2lsZW50bHkgIT09IHRydWUpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihcImVuZEFuaW1hdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjbGFzcyBuYW1lIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBjb250ZW50IGlzIHNjYWxlZFxuICAgKi9cbiAgaGFuZGxlQ3Vyc29yKCkge1xuICAgIGNvbnN0IGRyYWdnYWJsZUNsYXNzID0gdGhpcy5vcHRpb24oXCJkcmFnZ2FibGVDbGFzc1wiKTtcblxuICAgIGlmICghZHJhZ2dhYmxlQ2xhc3MgfHwgIXRoaXMub3B0aW9uKFwidG91Y2hcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbihcInBhbk9ubHlab29tZWRcIikgPT0gdHJ1ZSAmJlxuICAgICAgdGhpcy5jb250ZW50LndpZHRoIDw9IHRoaXMudmlld3BvcnQud2lkdGggJiZcbiAgICAgIHRoaXMuY29udGVudC5oZWlnaHQgPD0gdGhpcy52aWV3cG9ydC5oZWlnaHQgJiZcbiAgICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlIDw9IHRoaXMub3B0aW9uKFwiYmFzZVNjYWxlXCIpXG4gICAgKSB7XG4gICAgICB0aGlzLiRjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShkcmFnZ2FibGVDbGFzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGRyYWdnYWJsZUNsYXNzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIG9ic2VydmF0aW9uIGFuZCBkZXRhY2ggZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICBkZXRhY2hFdmVudHMoKSB7XG4gICAgdGhpcy4kY29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLm9uTG9hZCk7XG5cbiAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMub25XaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25DbGljaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIGlmICh0aGlzLnBvaW50ZXJUcmFja2VyKSB7XG4gICAgICB0aGlzLnBvaW50ZXJUcmFja2VyLnN0b3AoKTtcbiAgICAgIHRoaXMucG9pbnRlclRyYWNrZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cFxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJkZXN0cm95XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gXCJkZXN0cm95XCI7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVUaW1lcik7XG4gICAgdGhpcy51cGRhdGVUaW1lciA9IG51bGw7XG5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJBRik7XG4gICAgdGhpcy5yQUYgPSBudWxsO1xuXG4gICAgdGhpcy5kZXRhY2hFdmVudHMoKTtcblxuICAgIHRoaXMuZGV0YWNoUGx1Z2lucygpO1xuXG4gICAgdGhpcy5yZXNldERyYWdQb3NpdGlvbigpO1xuICB9XG59XG5cbi8vIEV4cG9zZSB2ZXJzaW9uXG5QYW56b29tLnZlcnNpb24gPSBcIl9fVkVSU0lPTl9fXCI7XG5cbi8vIFN0YXRpYyBwcm9wZXJ0aWVzIGFyZSBhIHJlY2VudCBhZGRpdGlvbiB0aGF0IGRvbnQgd29yayBpbiBhbGwgYnJvd3NlcnMgeWV0XG5QYW56b29tLlBsdWdpbnMgPSBQbHVnaW5zO1xuIiwiZXhwb3J0IGNvbnN0IFBsdWdpbnMgPSB7fTtcbiIsImltcG9ydCB7IGV4dGVuZCB9IGZyb20gXCIuLi91dGlscy9leHRlbmQuanNcIjtcbmltcG9ydCB7IHJlc29sdmUgfSBmcm9tIFwiLi4vdXRpbHMvcmVzb2x2ZS5qc1wiO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gXCIuLi91dGlscy9pc1BsYWluT2JqZWN0LmpzXCI7XG5cbi8qKlxuICogQmFzZSBjbGFzcywgYWxsIGNvbXBvbmVudHMgaW5oZXJpdCBmcm9tIHRoaXMgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2Uge1xuICAvKipcbiAgICogQmFzZSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBhcyBga2V5OiB2YWx1ZWAgcGFpcnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuXG4gICAgLy8gKiBQcmVmaWxsIHdpdGggaW5pdGlhbCBldmVudHNcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgW1wib25cIiwgXCJvbmNlXCJdKSB7XG4gICAgICBmb3IgKGNvbnN0IGFyZ3Mgb2YgT2JqZWN0LmVudHJpZXModGhpcy5vcHRpb25zW3R5cGVdIHx8IHt9KSkge1xuICAgICAgICB0aGlzW3R5cGVdKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBvcHRpb24gdmFsdWUgYnkga2V5LCBzdXBwb3J0cyBzdWJrZXlzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgT3B0aW9uIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbZmFsbGJhY2tdIEZhbGxiYWNrIHZhbHVlIGZvciBub24tZXhpc3Rpbmcga2V5XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgb3B0aW9uKGtleSwgZmFsbGJhY2ssIC4uLnJlc3QpIHtcbiAgICAvLyBNYWtlIHN1cmUgaXQgaXMgc3RyaW5nXG4gICAga2V5ID0gU3RyaW5nKGtleSk7XG5cbiAgICBsZXQgdmFsdWUgPSByZXNvbHZlKGtleSwgdGhpcy5vcHRpb25zKTtcblxuICAgIC8vIEFsbG93IHRvIGhhdmUgZnVuY3Rpb25zIGFzIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbCh0aGlzLCB0aGlzLCAuLi5yZXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGZhbGxiYWNrIDogdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2ltcGxlIGwxMG4gc3VwcG9ydCAtIHJlcGxhY2VzIG9iamVjdCBrZXlzXG4gICAqIGZvdW5kIGluIHRlbXBsYXRlIHdpdGggY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgY29udGFpbmluZyB2YWx1ZXMgdG8gbG9jYWxpemVcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIFN1YnN0aXR1dGUgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgbG9jYWxpemUoc3RyLCBwYXJhbXMgPSBbXSkge1xuICAgIHN0ciA9IFN0cmluZyhzdHIpLnJlcGxhY2UoL1xce1xceyhcXHcrKS4/KFxcdyspP1xcfVxcfS9nLCAobWF0Y2gsIGtleSwgc3Via2V5KSA9PiB7XG4gICAgICBsZXQgcmV6ID0gXCJcIjtcblxuICAgICAgLy8gUGx1Z2lucyBoYXZlIGBQbHVnaW4ubDEwbi5LRVlgXG4gICAgICBpZiAoc3Via2V5KSB7XG4gICAgICAgIHJleiA9IHRoaXMub3B0aW9uKGAke2tleVswXSArIGtleS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygxKX0ubDEwbi4ke3N1YmtleX1gKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgIHJleiA9IHRoaXMub3B0aW9uKGBsMTBuLiR7a2V5fWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJleikge1xuICAgICAgICByZXogPSBtYXRjaDtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhcmFtcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcmV6ID0gcmV6LnNwbGl0KHBhcmFtc1tpbmRleF1bMF0pLmpvaW4ocGFyYW1zW2luZGV4XVsxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXo7XG4gICAgfSk7XG5cbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx7XFx7KC4qKVxcfVxcfS8sIChtYXRjaCwga2V5KSA9PiB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gYW4gZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIG9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgIGZvciAoY29uc3QgYXJncyBvZiBPYmplY3QuZW50cmllcyhuYW1lKSkge1xuICAgICAgICB0aGlzLm9uKC4uLmFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBTdHJpbmcobmFtZSlcbiAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgIC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9ICh0aGlzLmV2ZW50c1tpdGVtXSA9IHRoaXMuZXZlbnRzW2l0ZW1dIHx8IFtdKTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spID09IC0xKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhbiBldmVudCBvbmx5IG9uY2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIG9uY2UobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgZm9yIChjb25zdCBhcmdzIG9mIE9iamVjdC5lbnRyaWVzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMub25jZSguLi5hcmdzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU3RyaW5nKG5hbWUpXG4gICAgICAuc3BsaXQoXCIgXCIpXG4gICAgICAuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICguLi5kZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5vZmYoaXRlbSwgbGlzdGVuZXIpO1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcywgLi4uZGV0YWlscyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbGlzdGVuZXIuXyA9IGNhbGxiYWNrO1xuXG4gICAgICAgIHRoaXMub24oaXRlbSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBldmVudCB3aXRoIG5hbWUgYW5kIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBvZmYobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgZm9yIChjb25zdCBhcmdzIG9mIE9iamVjdC5lbnRyaWVzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMub2ZmKC4uLmFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmFtZS5zcGxpdChcIiBcIikuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbaXRlbV07XG5cbiAgICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsZXQgaW5kZXggPSAtMTtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICBpZiAobGlzdGVuZXIgJiYgKGxpc3RlbmVyID09PSBjYWxsYmFjayB8fCBsaXN0ZW5lci5fID09PSBjYWxsYmFjaykpIHtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhbiBldmVudC5cbiAgICogSWYgcHJlc2VudCwgYFwiKlwiYCBoYW5kbGVycyBhcmUgaW52b2tlZCBhZnRlciBuYW1lLW1hdGNoZWQgaGFuZGxlcnMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSAgey4uLmFueX0gZGV0YWlsc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHRyaWdnZXIobmFtZSwgLi4uZGV0YWlscykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgWy4uLih0aGlzLmV2ZW50c1tuYW1lXSB8fCBbXSldLnNsaWNlKCkpIHtcbiAgICAgIGlmIChsaXN0ZW5lciAmJiBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMsIC4uLmRldGFpbHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQSB3aWxkY2FyZCBcIipcIiBldmVudCB0eXBlXG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBbLi4uKHRoaXMuZXZlbnRzW1wiKlwiXSB8fCBbXSldLnNsaWNlKCkpIHtcbiAgICAgIGlmIChsaXN0ZW5lciAmJiBsaXN0ZW5lci5jYWxsKHRoaXMsIG5hbWUsIHRoaXMsIC4uLmRldGFpbHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGdpdmVuIHBsdWdpbnMgdG8gdGhpcyBpbnN0YW5jZSxcbiAgICogdGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nIGBhdHRhY2hgIG1ldGhvZCBvZiBlYWNoIHBsdWdpblxuICAgKiBAcGFyYW0ge09iamVjdH0gUGx1Z2luc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgYXR0YWNoUGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgY29uc3QgbmV3UGx1Z2lucyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBQbHVnaW5dIG9mIE9iamVjdC5lbnRyaWVzKHBsdWdpbnMgfHwge30pKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIHBsdWdpbiBpcyBub3QgZGlzYWJsZWQgYnkgb3B0aW9uXG4gICAgICBpZiAodGhpcy5vcHRpb25zW2tleV0gIT09IGZhbHNlICYmICF0aGlzLnBsdWdpbnNba2V5XSkge1xuICAgICAgICAvLyBQb3B1bGF0ZSBvcHRpb25zIHdpdGggZGVmYXVsdHMgZnJvbSB0aGUgcGx1Z2luXG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gZXh0ZW5kKHt9LCBQbHVnaW4uZGVmYXVsdHMgfHwge30sIHRoaXMub3B0aW9uc1trZXldKTtcblxuICAgICAgICAvLyBJbml0aWFsaXNlIHBsdWdpblxuICAgICAgICBuZXdQbHVnaW5zW2tleV0gPSBuZXcgUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2tleSwgcGx1Z2luXSBvZiBPYmplY3QuZW50cmllcyhuZXdQbHVnaW5zKSkge1xuICAgICAgcGx1Z2luLmF0dGFjaCh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLnBsdWdpbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBsdWdpbnMsIG5ld1BsdWdpbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBwbHVnaW4gaW5zdGFuY2VzIGZyb20gdGhpcyBpbnN0YW5jZSxcbiAgICogdGhpcyB3aWxsIGVuZCB1cCBjYWxsaW5nIGBkZXRhY2hgIG1ldGhvZCBvZiBlYWNoIHBsdWdpblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZGV0YWNoUGx1Z2lucygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGxldCBwbHVnaW47XG5cbiAgICAgIGlmICgocGx1Z2luID0gdGhpcy5wbHVnaW5zW2tleV0pICYmIHR5cGVvZiBwbHVnaW4uZGV0YWNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcGx1Z2luLmRldGFjaCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCJleHBvcnQgY29uc3QgRnVsbHNjcmVlbiA9IHtcclxuICBwYWdlWE9mZnNldDogMCxcclxuICBwYWdlWU9mZnNldDogMCxcclxuXHJcbiAgZWxlbWVudCgpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudDtcclxuICB9LFxyXG5cclxuICBhY3RpdmF0ZShlbGVtZW50KSB7XHJcbiAgICBGdWxsc2NyZWVuLnBhZ2VYT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xyXG4gICAgRnVsbHNjcmVlbi5wYWdlWU9mZnNldCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcclxuXHJcbiAgICBpZiAoZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xyXG4gICAgICBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7IC8vIFczQyBzcGVjXHJcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcclxuICAgICAgZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpOyAvLyBGaXJlZm94XHJcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgZWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbigpOyAvLyBTYWZhcmlcclxuICAgIH0gZWxzZSBpZiAoZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKSB7XHJcbiAgICAgIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpOyAvLyBJRS9FZGdlXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZGVhY3RpdmF0ZSgpIHtcclxuICAgIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xyXG4gICAgICBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xyXG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKSB7XHJcbiAgICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcclxuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcclxuICAgIH1cclxuICB9LFxyXG59O1xyXG4iLCJjbGFzcyBQb2ludGVyIHtcclxuICBjb25zdHJ1Y3RvcihuYXRpdmVQb2ludGVyKSB7XHJcbiAgICB0aGlzLmlkID0gc2VsZi5Ub3VjaCAmJiBuYXRpdmVQb2ludGVyIGluc3RhbmNlb2YgVG91Y2ggPyBuYXRpdmVQb2ludGVyLmlkZW50aWZpZXIgOiAtMTtcclxuXHJcbiAgICB0aGlzLnBhZ2VYID0gbmF0aXZlUG9pbnRlci5wYWdlWDtcclxuICAgIHRoaXMucGFnZVkgPSBuYXRpdmVQb2ludGVyLnBhZ2VZO1xyXG5cclxuICAgIHRoaXMuY2xpZW50WCA9IG5hdGl2ZVBvaW50ZXIuY2xpZW50WDtcclxuICAgIHRoaXMuY2xpZW50WSA9IG5hdGl2ZVBvaW50ZXIuY2xpZW50WTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGdldERpc3RhbmNlID0gKGEsIGIpID0+IHtcclxuICBpZiAoIWIpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIE1hdGguc3FydCgoYi5jbGllbnRYIC0gYS5jbGllbnRYKSAqKiAyICsgKGIuY2xpZW50WSAtIGEuY2xpZW50WSkgKiogMik7XHJcbn07XHJcblxyXG5jb25zdCBnZXRNaWRwb2ludCA9IChhLCBiKSA9PiB7XHJcbiAgaWYgKCFiKSB7XHJcbiAgICByZXR1cm4gYTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBjbGllbnRYOiAoYS5jbGllbnRYICsgYi5jbGllbnRYKSAvIDIsXHJcbiAgICBjbGllbnRZOiAoYS5jbGllbnRZICsgYi5jbGllbnRZKSAvIDIsXHJcbiAgfTtcclxufTtcclxuXHJcbmNvbnN0IGlzVG91Y2hFdmVudCA9IChldmVudCkgPT4gXCJjaGFuZ2VkVG91Y2hlc1wiIGluIGV2ZW50O1xyXG5cclxuY2xhc3MgUG9pbnRlclRyYWNrZXIge1xyXG4gIGNvbnN0cnVjdG9yKF9lbGVtZW50LCB7IHN0YXJ0ID0gKCkgPT4gdHJ1ZSwgbW92ZSA9ICgpID0+IHt9LCBlbmQgPSAoKSA9PiB7fSB9ID0ge30pIHtcclxuICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcclxuXHJcbiAgICB0aGlzLnN0YXJ0UG9pbnRlcnMgPSBbXTtcclxuICAgIHRoaXMuY3VycmVudFBvaW50ZXJzID0gW107XHJcblxyXG4gICAgdGhpcy5fcG9pbnRlclN0YXJ0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGlmIChldmVudC5idXR0b25zID4gMCAmJiBldmVudC5idXR0b24gIT09IDApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSBuZXcgUG9pbnRlcihldmVudCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5jdXJyZW50UG9pbnRlcnMuc29tZSgocCkgPT4gcC5pZCA9PT0gcG9pbnRlci5pZCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghdGhpcy5fdHJpZ2dlclBvaW50ZXJTdGFydChwb2ludGVyLCBldmVudCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdmUpO1xyXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5fcG9pbnRlckVuZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3RvdWNoU3RhcnQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgZm9yIChjb25zdCB0b3VjaCBvZiBBcnJheS5mcm9tKGV2ZW50LmNoYW5nZWRUb3VjaGVzIHx8IFtdKSkge1xyXG4gICAgICAgIHRoaXMuX3RyaWdnZXJQb2ludGVyU3RhcnQobmV3IFBvaW50ZXIodG91Y2gpLCBldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fbW92ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICBjb25zdCBwcmV2aW91c1BvaW50ZXJzID0gdGhpcy5jdXJyZW50UG9pbnRlcnMuc2xpY2UoKTtcclxuICAgICAgY29uc3QgY2hhbmdlZFBvaW50ZXJzID0gaXNUb3VjaEV2ZW50KGV2ZW50KVxyXG4gICAgICAgID8gQXJyYXkuZnJvbShldmVudC5jaGFuZ2VkVG91Y2hlcykubWFwKCh0KSA9PiBuZXcgUG9pbnRlcih0KSlcclxuICAgICAgICA6IFtuZXcgUG9pbnRlcihldmVudCldO1xyXG5cclxuICAgICAgY29uc3QgdHJhY2tlZENoYW5nZWRQb2ludGVycyA9IFtdO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBwb2ludGVyIG9mIGNoYW5nZWRQb2ludGVycykge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jdXJyZW50UG9pbnRlcnMuZmluZEluZGV4KChwKSA9PiBwLmlkID09PSBwb2ludGVyLmlkKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0cmFja2VkQ2hhbmdlZFBvaW50ZXJzLnB1c2gocG9pbnRlcik7XHJcblxyXG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzW2luZGV4XSA9IHBvaW50ZXI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX21vdmVDYWxsYmFjayhwcmV2aW91c1BvaW50ZXJzLCB0aGlzLmN1cnJlbnRQb2ludGVycy5zbGljZSgpLCBldmVudCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3RyaWdnZXJQb2ludGVyRW5kID0gKHBvaW50ZXIsIGV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jdXJyZW50UG9pbnRlcnMuZmluZEluZGV4KChwKSA9PiBwLmlkID09PSBwb2ludGVyLmlkKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuY3VycmVudFBvaW50ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIHRoaXMuc3RhcnRQb2ludGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgdGhpcy5fZW5kQ2FsbGJhY2socG9pbnRlciwgZXZlbnQpO1xyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3BvaW50ZXJFbmQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbnMgPiAwICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF0aGlzLl90cmlnZ2VyUG9pbnRlckVuZChuZXcgUG9pbnRlcihldmVudCksIGV2ZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5fbW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuX3BvaW50ZXJFbmQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuX3RvdWNoRW5kID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgIGZvciAoY29uc3QgdG91Y2ggb2YgQXJyYXkuZnJvbShldmVudC5jaGFuZ2VkVG91Y2hlcyB8fCBbXSkpIHtcclxuICAgICAgICB0aGlzLl90cmlnZ2VyUG9pbnRlckVuZChuZXcgUG9pbnRlcih0b3VjaCksIGV2ZW50KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9zdGFydENhbGxiYWNrID0gc3RhcnQ7XHJcbiAgICB0aGlzLl9tb3ZlQ2FsbGJhY2sgPSBtb3ZlO1xyXG4gICAgdGhpcy5fZW5kQ2FsbGJhY2sgPSBlbmQ7XHJcblxyXG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuX3BvaW50ZXJTdGFydCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9tb3ZlLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hFbmQpO1xyXG4gICAgdGhpcy5fZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy5fdG91Y2hFbmQpO1xyXG4gIH1cclxuXHJcbiAgc3RvcCgpIHtcclxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLl9wb2ludGVyU3RhcnQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX3RvdWNoU3RhcnQsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fbW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcclxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuX3RvdWNoRW5kKTtcclxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMuX3RvdWNoRW5kKTtcclxuXHJcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3ZlKTtcclxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLl9wb2ludGVyRW5kKTtcclxuICB9XHJcblxyXG4gIF90cmlnZ2VyUG9pbnRlclN0YXJ0KHBvaW50ZXIsIGV2ZW50KSB7XHJcbiAgICBpZiAoIXRoaXMuX3N0YXJ0Q2FsbGJhY2socG9pbnRlciwgZXZlbnQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmN1cnJlbnRQb2ludGVycy5wdXNoKHBvaW50ZXIpO1xyXG4gICAgdGhpcy5zdGFydFBvaW50ZXJzLnB1c2gocG9pbnRlcik7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBQb2ludGVyVHJhY2tlciwgZ2V0RGlzdGFuY2UsIGdldE1pZHBvaW50IH07XHJcbiIsIi8qKlxuICogUmVzaXplT2JzZXJ2ZXIgUG9seWZpbGxcbiAqL1xuZXhwb3J0IGNvbnN0IFJlc2l6ZU9ic2VydmVyID1cbiAgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LlJlc2l6ZU9ic2VydmVyKSB8fFxuICBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBbXTtcbiAgICAgIC8vIEFycmF5IG9mIG9ic2VydmVkIGVsZW1lbnRzIHRoYXQgbG9va3MgbGlrZSB0aGlzOlxuICAgICAgLy8gW3tcbiAgICAgIC8vICAgZWw6IGRvbU5vZGUsXG4gICAgICAvLyAgIHNpemU6IHtoZWlnaHQ6IHgsIHdpZHRoOiB5fVxuICAgICAgLy8gfV1cbiAgICAgIHRoaXMuYm91bmRDaGVjayA9IHRoaXMuY2hlY2suYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYm91bmRDaGVjaygpO1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIG9ic2VydmUoZWwpIHtcbiAgICAgIGlmICh0aGlzLm9ic2VydmFibGVzLnNvbWUoKG9ic2VydmFibGUpID0+IG9ic2VydmFibGUuZWwgPT09IGVsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld09ic2VydmFibGUgPSB7XG4gICAgICAgIGVsOiBlbCxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIGhlaWdodDogZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBlbC5jbGllbnRXaWR0aCxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub2JzZXJ2YWJsZXMucHVzaChuZXdPYnNlcnZhYmxlKTtcbiAgICB9XG5cbiAgICB1bm9ic2VydmUoZWwpIHtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSB0aGlzLm9ic2VydmFibGVzLmZpbHRlcigob2JqKSA9PiBvYmouZWwgIT09IGVsKTtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IFtdO1xuICAgIH1cblxuICAgIGNoZWNrKCkge1xuICAgICAgY29uc3QgY2hhbmdlZEVudHJpZXMgPSB0aGlzLm9ic2VydmFibGVzXG4gICAgICAgIC5maWx0ZXIoKG9iaikgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBvYmouZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IG9iai5lbC5jbGllbnRXaWR0aDtcbiAgICAgICAgICBpZiAob2JqLnNpemUuaGVpZ2h0ICE9PSBjdXJyZW50SGVpZ2h0IHx8IG9iai5zaXplLndpZHRoICE9PSBjdXJyZW50V2lkdGgpIHtcbiAgICAgICAgICAgIG9iai5zaXplLmhlaWdodCA9IGN1cnJlbnRIZWlnaHQ7XG4gICAgICAgICAgICBvYmouc2l6ZS53aWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm1hcCgob2JqKSA9PiBvYmouZWwpO1xuXG4gICAgICBpZiAoY2hhbmdlZEVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGNoYW5nZWRFbnRyaWVzKTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kQ2hlY2spO1xuICAgIH1cbiAgfTtcbiIsImV4cG9ydCBjbGFzcyBTbGlkZXNob3cge1xyXG4gIGNvbnN0cnVjdG9yKGZhbmN5Ym94KSB7XHJcbiAgICB0aGlzLmZhbmN5Ym94ID0gZmFuY3lib3g7XHJcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgaXNBY3RpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hY3RpdmU7XHJcbiAgfVxyXG5cclxuICBzZXRUaW1lcigpIHtcclxuICAgIGlmICghdGhpcy5hY3RpdmUgfHwgdGhpcy50aW1lcikge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGVsYXkgPSB0aGlzLmZhbmN5Ym94Lm9wdGlvbihcInNsaWRlc2hvdy5kZWxheVwiLCAzMDAwKTtcclxuXHJcbiAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xyXG5cclxuICAgICAgaWYgKFxyXG4gICAgICAgICF0aGlzLmZhbmN5Ym94Lm9wdGlvbihcImluZmluaXRlXCIpICYmXHJcbiAgICAgICAgdGhpcy5mYW5jeWJveC5nZXRTbGlkZSgpLmluZGV4ID09PSB0aGlzLmZhbmN5Ym94LkNhcm91c2VsLnNsaWRlcy5sZW5ndGggLSAxXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMuZmFuY3lib3guanVtcFRvKDAsIHsgZnJpY3Rpb246IDAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5mYW5jeWJveC5uZXh0KCk7XHJcbiAgICAgIH1cclxuICAgIH0sIGRlbGF5KTtcclxuXHJcbiAgICBsZXQgJHByb2dyZXNzID0gdGhpcy4kcHJvZ3Jlc3M7XHJcblxyXG4gICAgaWYgKCEkcHJvZ3Jlc3MpIHtcclxuICAgICAgJHByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgJHByb2dyZXNzLmNsYXNzTGlzdC5hZGQoXCJmYW5jeWJveF9fcHJvZ3Jlc3NcIik7XHJcblxyXG4gICAgICB0aGlzLmZhbmN5Ym94LiRjYXJvdXNlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSgkcHJvZ3Jlc3MsIHRoaXMuZmFuY3lib3guJGNhcm91c2VsKTtcclxuXHJcbiAgICAgIHRoaXMuJHByb2dyZXNzID0gJHByb2dyZXNzO1xyXG5cclxuICAgICAgJHByb2dyZXNzLm9mZnNldEhlaWdodDsgLyogdHJpZ2dlciByZWZsb3cgKi9cclxuICAgIH1cclxuXHJcbiAgICAkcHJvZ3Jlc3Muc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7ZGVsYXl9bXNgO1xyXG4gICAgJHByb2dyZXNzLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGVYKDEpXCI7XHJcbiAgfVxyXG5cclxuICBjbGVhclRpbWVyKCkge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xyXG4gICAgdGhpcy50aW1lciA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRoaXMuJHByb2dyZXNzKSB7XHJcbiAgICAgIHRoaXMuJHByb2dyZXNzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiXCI7XHJcbiAgICAgIHRoaXMuJHByb2dyZXNzLnN0eWxlLnRyYW5zZm9ybSA9IFwiXCI7XHJcblxyXG4gICAgICB0aGlzLiRwcm9ncmVzcy5vZmZzZXRIZWlnaHQ7IC8qIHRyaWdnZXIgcmVmbG93ICovXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhY3RpdmF0ZSgpIHtcclxuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgdGhpcy5mYW5jeWJveC4kY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXMtc2xpZGVzaG93XCIpO1xyXG5cclxuICAgIGlmICh0aGlzLmZhbmN5Ym94LmdldFNsaWRlKCkuc3RhdGUgPT09IFwiZG9uZVwiKSB7XHJcbiAgICAgIHRoaXMuc2V0VGltZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKSB7XHJcbiAgICB0aGlzLmRlYWN0aXZhdGUoKTtcclxuICB9XHJcblxyXG4gIGRlYWN0aXZhdGUoKSB7XHJcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xyXG5cclxuICAgIHRoaXMuZmFuY3lib3guJGNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiaGFzLXNsaWRlc2hvd1wiKTtcclxuXHJcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsIGZhbHNlKTtcclxuICB9XHJcblxyXG4gIHRvZ2dsZSgpIHtcclxuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5mYW5jeWJveC5DYXJvdXNlbC5zbGlkZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICB0aGlzLmFjdGl2YXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBEZXRlY3QgaWYgcmVuZGVyaW5nIGZyb20gdGhlIGNsaWVudCBvciB0aGUgc2VydmVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xyXG4iLCJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSBcIi4vaXNQbGFpbk9iamVjdC5qc1wiO1xuXG4vKipcbiAqIE1lcmdlIHRoZSBjb250ZW50cyBvZiB0d28gb3IgbW9yZSBvYmplY3RzIHRvZ2V0aGVyIGludG8gdGhlIGZpcnN0IG9iamVjdC5cbiAqIElmIHBhc3NpbmcgXCJ0cnVlXCIgZm9yIGZpcnN0IGFyZ3VtZW50LCB0aGUgbWVyZ2UgYmVjb21lcyByZWN1cnNpdmUgKGFrYS4gZGVlcCBjb3B5KS5cbiAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGV4dGVuZCA9ICguLi5hcmdzKSA9PiB7XG4gIGxldCBkZWVwID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09IFwiYm9vbGVhblwiKSB7XG4gICAgZGVlcCA9IGFyZ3Muc2hpZnQoKTtcbiAgfVxuXG4gIGxldCByZXN1bHQgPSBhcmdzWzBdO1xuXG4gIGlmICghcmVzdWx0IHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbmRlZSBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuXG4gIGNvbnN0IGV4dGVuZGVycyA9IGFyZ3Muc2xpY2UoMSk7XG4gIGNvbnN0IGxlbiA9IGV4dGVuZGVycy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGV4dGVuZGVyID0gZXh0ZW5kZXJzW2ldO1xuXG4gICAgZm9yIChsZXQga2V5IGluIGV4dGVuZGVyKSB7XG4gICAgICBpZiAoZXh0ZW5kZXIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuZGVyW2tleV07XG5cbiAgICAgICAgaWYgKGRlZXAgJiYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSkge1xuICAgICAgICAgIGNvbnN0IGJhc2UgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge307XG5cbiAgICAgICAgICByZXN1bHRba2V5XSA9IGV4dGVuZCh0cnVlLCByZXN1bHQuaGFzT3duUHJvcGVydHkoa2V5KSA/IHJlc3VsdFtrZXldIDogYmFzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8qKlxuICogR2V0IGFjdHVhbCB3aWR0aCBvZiB0aGUgZWxlbWVudCwgcmVnYXJkbGVzcyBvZiBob3cgbXVjaCBvZiBjb250ZW50IGlzIGN1cnJlbnRseSB2aXNpYmxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0RnVsbFdpZHRoID0gKGVsZW0pID0+IHtcbiAgcmV0dXJuIE1hdGgubWF4KFxuICAgIHBhcnNlRmxvYXQoZWxlbS5uYXR1cmFsV2lkdGggfHwgMCksXG4gICAgcGFyc2VGbG9hdCgoZWxlbS53aWR0aCAmJiBlbGVtLndpZHRoLmJhc2VWYWwgJiYgZWxlbS53aWR0aC5iYXNlVmFsLnZhbHVlKSB8fCAwKSxcbiAgICBwYXJzZUZsb2F0KGVsZW0ub2Zmc2V0V2lkdGggfHwgMCksXG4gICAgcGFyc2VGbG9hdChlbGVtLnNjcm9sbFdpZHRoIHx8IDApXG4gICk7XG59O1xuXG4vKipcbiAqIEdldCBhY3R1YWwgaGVpZ2h0IG9mIHRoZSBlbGVtZW50LCByZWdhcmRsZXNzIG9mIGhvdyBtdWNoIG9mIGNvbnRlbnQgaXMgY3VycmVudGx5IHZpc2libGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge0ludGVnZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGdWxsSGVpZ2h0ID0gKGVsZW0pID0+IHtcbiAgcmV0dXJuIE1hdGgubWF4KFxuICAgIHBhcnNlRmxvYXQoZWxlbS5uYXR1cmFsSGVpZ2h0IHx8IDApLFxuICAgIHBhcnNlRmxvYXQoKGVsZW0uaGVpZ2h0ICYmIGVsZW0uaGVpZ2h0LmJhc2VWYWwgJiYgZWxlbS5oZWlnaHQuYmFzZVZhbC52YWx1ZSkgfHwgMCksXG4gICAgcGFyc2VGbG9hdChlbGVtLm9mZnNldEhlaWdodCB8fCAwKSxcbiAgICBwYXJzZUZsb2F0KGVsZW0uc2Nyb2xsSGVpZ2h0IHx8IDApXG4gICk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBib3VuZGluZyBzaXplIHRvIGZpdCBkaW1lbnNpb25zIHdoaWxlIHByZXNlcnZpbmcgYXNwZWN0IHJhdGlvXG4gKiBAcGFyYW0ge051bWJlcn0gc3JjV2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcmNIZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhXaWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEhlaWdodFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZUFzcGVjdFJhdGlvRml0ID0gKHNyY1dpZHRoLCBzcmNIZWlnaHQsIG1heFdpZHRoLCBtYXhIZWlnaHQpID0+IHtcbiAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhXaWR0aCAvIHNyY1dpZHRoIHx8IDAsIG1heEhlaWdodCAvIHNyY0hlaWdodCk7XG5cbiAgcmV0dXJuIHsgd2lkdGg6IHNyY1dpZHRoICogcmF0aW8gfHwgMCwgaGVpZ2h0OiBzcmNIZWlnaHQgKiByYXRpbyB8fCAwIH07XG59O1xuIiwiLyoqXG4gKiBHZXQgZWxlbWVudCBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlc1xuICogQHBhcmFtIHtFbGVtZW50fSBIVE1MIGVsZW1lbnRcbiAqIEBwYXJhbSB7RmxvYXR8SW50ZWdlcn0geFxuICogQHBhcmFtIHtGbG9hdHxJbnRlZ2VyfSB5XG4gKiBAcmV0dXJucyB7Tm9kZXxCb29sZWFufX1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRleHROb2RlRnJvbVBvaW50ID0gKGVsZW1lbnQsIHgsIHkpID0+IHtcbiAgY29uc3Qgbm9kZXMgPSBlbGVtZW50LmNoaWxkTm9kZXM7XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG5cbiAgICBjb25zdCByZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAoeCA+PSByZWN0LmxlZnQgJiYgeSA+PSByZWN0LnRvcCAmJiB4IDw9IHJlY3QucmlnaHQgJiYgeSA8PSByZWN0LmJvdHRvbSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIi8qKlxuICogQ2hlY2sgdG8gc2VlIGlmIGFuIG9iamVjdCBpcyBhIHBsYWluIG9iamVjdCAoY3JlYXRlZCB1c2luZyBcInt9XCIgb3IgXCJuZXcgT2JqZWN0XCIpLlxuICogQHBhcmFtIHsqfSBvYmogVmFyaWFibGUgb2YgYW55IHR5cGVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IHtcbiAgcmV0dXJuIChcbiAgICAvLyBzZXBhcmF0ZSBmcm9tIHByaW1pdGl2ZXNcbiAgICB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmXG4gICAgLy8gaXMgb2J2aW91c1xuICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgIC8vIHNlcGFyYXRlIGluc3RhbmNlcyAoQXJyYXksIERPTSwgLi4uKVxuICAgIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmXG4gICAgLy8gc2VwYXJhdGUgYnVpbGQtaW4gbGlrZSBNYXRoXG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCJcbiAgKTtcbn07XG4iLCIvKipcbiAqIENoZWNrIGlmICBlbGVtZW50IGhhcyBzY3JvbGxhYmxlIGNvbnRlbnRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNTY3JvbGxiYXJzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3Qgb3ZlcmZsb3dZID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKVtcIm92ZXJmbG93LXlcIl0sXG4gICAgb3ZlcmZsb3dYID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKVtcIm92ZXJmbG93LXhcIl0sXG4gICAgdmVydGljYWwgPSAob3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8IG92ZXJmbG93WSA9PT0gXCJhdXRvXCIpICYmIE1hdGguYWJzKG5vZGUuc2Nyb2xsSGVpZ2h0IC0gbm9kZS5jbGllbnRIZWlnaHQpID4gMSxcbiAgICBob3Jpem9udGFsID0gKG92ZXJmbG93WCA9PT0gXCJzY3JvbGxcIiB8fCBvdmVyZmxvd1ggPT09IFwiYXV0b1wiKSAmJiBNYXRoLmFicyhub2RlLnNjcm9sbFdpZHRoIC0gbm9kZS5jbGllbnRXaWR0aCkgPiAxO1xuXG4gIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBlbGVtZW50IG9yIG9uZSBvZiB0aGUgcGFyZW50cyBpcyBzY3JvbGxhYmxlXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgIERPTSBOb2RlIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNTY3JvbGxhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKCFub2RlIHx8ICEodHlwZW9mIG5vZGUgPT09IFwib2JqZWN0XCIgJiYgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHx8IG5vZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobm9kZS5fX1Bhbnpvb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaGFzU2Nyb2xsYmFycyhub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2Nyb2xsYWJsZShub2RlLnBhcmVudE5vZGUpO1xufTtcbiIsIi8qKlxuICogQWNjZXNzIG5lc3RlZCBKYXZhU2NyaXB0IG9iamVjdHMgYnkgc3RyaW5nIHBhdGguXG4gKiBFeGFtcGxlOiBgcmVzb2x2ZShcImEuYi5jXCIsIHthOntiOntjOlwiZFwifX0pYCB3b3VsZCByZXR1cm4gYGRgXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlID0gZnVuY3Rpb24gKHBhdGgsIG9iaikge1xuICByZXR1cm4gcGF0aC5zcGxpdChcIi5cIikucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XG4gICAgcmV0dXJuIHByZXYgJiYgcHJldltjdXJyXTtcbiAgfSwgb2JqKTtcbn07XG4iLCIvKipcbiAqIFJvdW5kIGhhbGYgdXA7IHRvIGJlIG1vcmUgc3BlY2lmaWMgYW5kIHRvIGVuc3VyZSB0aGluZ3MgbGlrZSAxLjAwNSByb3VuZCBjb3JyZWN0bHlcbiAqIEBwYXJhbSB7RmxvYXR9IHZhbHVlXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHByZWNpc2lvblxuICogQHJldHVybnMge0Zsb2F0fVxuICovXG5leHBvcnQgY29uc3Qgcm91bmQgPSAodmFsdWUsIHByZWNpc2lvbiA9IDEwMDAwKSA9PiB7XG4gIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcblxuICByZXR1cm4gTWF0aC5yb3VuZCgodmFsdWUgKyBOdW1iZXIuRVBTSUxPTikgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xufTtcbiIsImltcG9ydCB7IGNhblVzZURPTSB9IGZyb20gXCIuL2NhblVzZURPTS5qc1wiO1xyXG5cclxubGV0IHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBudWxsO1xyXG5cclxuZXhwb3J0IGNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UUyA9IFtcclxuICBcImFbaHJlZl1cIixcclxuICBcImFyZWFbaHJlZl1cIixcclxuICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdHlwZT1cImhpZGRlblwiXSk6bm90KFthcmlhLWhpZGRlbl0pJyxcclxuICBcInNlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsXHJcbiAgXCJ0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pXCIsXHJcbiAgXCJidXR0b246bm90KFtkaXNhYmxlZF0pOm5vdChbYXJpYS1oaWRkZW5dKVwiLFxyXG4gIFwiaWZyYW1lXCIsXHJcbiAgXCJvYmplY3RcIixcclxuICBcImVtYmVkXCIsXHJcbiAgXCJ2aWRlb1wiLFxyXG4gIFwiYXVkaW9cIixcclxuICBcIltjb250ZW50ZWRpdGFibGVdXCIsXHJcbiAgJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleF49XCItXCJdKTpub3QoW2Rpc2FibGVkXSk6bm90KFthcmlhLWhpZGRlbl0pJyxcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBzZXRGb2N1c09uID0gKG5vZGUpID0+IHtcclxuICBpZiAoIW5vZGUgfHwgIWNhblVzZURPTSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT09IG51bGwpIHtcclxuICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuZm9jdXMoe1xyXG4gICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcclxuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB0cnkge1xyXG4gICAgaWYgKG5vZGUuc2V0QWN0aXZlKSB7XHJcbiAgICAgIC8vIElFL0VkZ2VcclxuICAgICAgbm9kZS5zZXRBY3RpdmUoKTtcclxuICAgIH0gZWxzZSBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xyXG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlcnNcclxuICAgICAgbm9kZS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTYWZhcmkgZG9lcyBub3Qgc3VwcG9ydCBgcHJldmVudFNjcm9sbGAgb3B0aW9uXHJcbiAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzg1ODNcclxuXHJcbiAgICAgIC8vIFNhdmUgcG9zaXRpb25cclxuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xyXG4gICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcclxuXHJcbiAgICAgIG5vZGUuZm9jdXMoKTtcclxuXHJcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG8oe1xyXG4gICAgICAgIHRvcDogc2Nyb2xsVG9wLFxyXG4gICAgICAgIGxlZnQ6IHNjcm9sbExlZnQsXHJcbiAgICAgICAgYmVoYXZpb3I6IFwiYXV0b1wiLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7fVxyXG59O1xyXG4iLCIvKipcbiAqIFRocm90dGxpbmcgZW5mb3JjZXMgYSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyBhIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgb3ZlciB0aW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGxpbWl0IE1pbGxpc2Vjb25kc1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgY29uc3QgdGhyb3R0bGUgPSAoZnVuYywgbGltaXQpID0+IHtcbiAgbGV0IGxhc3RDYWxsID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIGlmIChub3cgLSBsYXN0Q2FsbCA8IGxpbWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGFzdENhbGwgPSBub3c7XG5cbiAgICByZXR1cm4gZnVuYyguLi5hcmdzKTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=